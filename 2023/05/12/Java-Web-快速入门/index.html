<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="楼兰"><meta name="copyright" content="楼兰"><meta name="generator" content="Hexo 6.3.0"><meta name="theme" content="hexo-theme-yun"><title>Java Web 快速入门 | 楼兰</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"trevoewu.github.io","root":"/","title":"楼兰的小站","version":"1.10.9","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="楼兰" type="application/atom+xml"><meta name="description" content="狂神说JavaWeb快速入门笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Web 快速入门">
<meta property="og:url" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="楼兰">
<meta property="og:description" content="狂神说JavaWeb快速入门笔记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512175355319.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512175943702.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512180405774.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512180642215.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512182111384.png">
<meta property="og:image" content="https://cdn4.iconfinder.com/data/icons/web-hosting-pack-vol-1/512/HTTP_Cookie-512.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image1.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512202849320.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512203239731.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70-20230512204121432.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512204634669.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70-20230512210458691.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70-20230512210458822.png">
<meta property="og:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Kapture%202023-05-13%20at%2011.38.21-3950252.gif">
<meta property="article:published_time" content="2023-05-12T09:45:29.000Z">
<meta property="article:modified_time" content="2023-06-10T12:58:44.545Z">
<meta property="article:author" content="楼兰">
<meta property="article:tag" content="JavaWeb">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512175355319.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="楼兰"><img width="96" loading="lazy" src="/icon/avatar.png" alt="楼兰"></a><div class="site-author-name"><a href="/about/">楼兰</a></div><span class="site-name">楼兰</span><sub class="site-subtitle"></sub><div class="site-description">楼兰的Blog</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">20</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">12</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">28</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81web%E5%92%8C%E5%8A%A8%E6%80%81web"><span class="toc-number">1.</span> <span class="toc-text">静态web和动态web</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat"><span class="toc-number">2.1.</span> <span class="toc-text">Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Tomcat%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">Tomcat文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99"><span class="toc-number">2.1.3.</span> <span class="toc-text">发布一个网站</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet"><span class="toc-number">3.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAServlet%E7%A8%8B%E5%BA%8F-HelloServlet"><span class="toc-number">3.2.</span> <span class="toc-text">第一个Servlet程序 HelloServlet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#write-%E5%92%8Cprintln"><span class="toc-number">3.2.1.</span> <span class="toc-text">write( )和println( )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet-Mapping"><span class="toc-number">3.2.2.</span> <span class="toc-text">Servlet Mapping</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet-Context"><span class="toc-number">3.3.</span> <span class="toc-text">Servlet Context</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8servletContext%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8CServlet%E4%B9%8B%E5%89%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-number">3.3.1.</span> <span class="toc-text">利用servletContext实现不同Servlet之前的数据共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Servlet%E8%8E%B7%E5%8F%96%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">利用Servlet获取初始化参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BD%AC%E5%8F%91"><span class="toc-number">3.3.3.</span> <span class="toc-text">实现请求的转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%9D%A5%E8%AF%BB%E5%8F%96%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.4.</span> <span class="toc-text">用来读取资源文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpServletResponse"><span class="toc-number">3.4.</span> <span class="toc-text">HttpServletResponse</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">1.简单分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.下载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.验证码功能*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.实现重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">3.4.5.</span> <span class="toc-text">5.简单实现登录重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpServletRequest"><span class="toc-number">3.5.</span> <span class="toc-text">HttpServletRequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E4%BC%9A%E8%AF%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">3.6.</span> <span class="toc-text">保存会话的两种技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookies"><span class="toc-number">3.6.1.</span> <span class="toc-text">Cookies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Cookies%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%99%BB%E5%BD%95%E6%97%B6%E9%97%B4"><span class="toc-number">3.6.2.</span> <span class="toc-text">利用Cookies记录用户上一次登录时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session"><span class="toc-number">3.6.3.</span> <span class="toc-text">session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">3.6.4.</span> <span class="toc-text">Session和cookie的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Session%E8%BF%94%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E4%B8%AAPerson%E5%AF%B9%E8%B1%A1-%E5%B9%B6%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E6%89%93%E5%8D%B0"><span class="toc-number">3.6.5.</span> <span class="toc-text">利用Session返回客户端一个Person对象, 并在浏览器上打印</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSP-Java-Server-Pages"><span class="toc-number">3.7.</span> <span class="toc-text">JSP (Java Server Pages)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text">JSP原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP%E8%AF%AD%E6%B3%95"><span class="toc-number">3.7.2.</span> <span class="toc-text">JSP语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JSP%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">JSP表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jsp%E8%84%9A%E6%9C%AC%E7%89%87%E6%AE%B5"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">jsp脚本片段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JSP%E6%8C%87%E4%BB%A4-404%E4%B8%8E500%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">JSP指令: 404与500页面实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E5%92%8C%E5%B0%BE%E9%83%A8%E9%A1%B5%E9%9D%A2%E6%8B%BC%E6%8E%A5"><span class="toc-number">3.7.2.3.1.</span> <span class="toc-text">头部和尾部页面拼接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.7.3.</span> <span class="toc-text">内置对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP%E6%A0%87%E7%AD%BE-JSTL%E6%A0%87%E7%AD%BE-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.7.4.</span> <span class="toc-text">JSP标签.JSTL标签.EL表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean"><span class="toc-number">4.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">MVC三层架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A9%E4%BA%9B%E5%B9%B4"><span class="toc-number">5.1.</span> <span class="toc-text">1.早些年</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">2.MVC三层架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter-%E9%87%8D%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">Filter(重点)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8-Listener"><span class="toc-number">7.</span> <span class="toc-text">监听器(Listener)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8-%E7%9B%91%E5%90%AC%E5%99%A8%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">过滤器.监听器常见应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%9AGUI%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%EF%BC%9B"><span class="toc-number">7.1.1.</span> <span class="toc-text">监听器：GUI编程中经常使用；</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%B9%8B%E5%90%8E%E6%89%8D%E8%83%BD%E8%BF%9B%E5%85%A5%E4%B8%BB%E9%A1%B5%EF%BC%81%E7%94%A8%E6%88%B7%E6%B3%A8%E9%94%80%E5%90%8E%E5%B0%B1%E4%B8%8D%E8%83%BD%E8%BF%9B%E5%85%A5%E4%B8%BB%E9%A1%B5%E4%BA%86"><span class="toc-number">7.1.2.</span> <span class="toc-text">过滤器：用户登录之后才能进入主页！用户注销后就不能进入主页了</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC"><span class="toc-number">8.</span> <span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91-%E4%BD%BF%E7%94%A8%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="toc-number">8.0.1.</span> <span class="toc-text">预编译: 使用占位符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">8.0.2.</span> <span class="toc-text">SQL注入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-%E8%B6%85%E5%B8%82%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">实战: 超市订单管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6"><span class="toc-number">9.1.</span> <span class="toc-text">搭建项目框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E5%85%AC%E5%85%B1%E7%B1%BBDB"><span class="toc-number">9.1.1.</span> <span class="toc-text">编写数据库操作的基础公共类DB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.</span> <span class="toc-text">登录功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%BC%96%E5%86%99"><span class="toc-number">9.2.1.</span> <span class="toc-text">前端页面编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%A4%84%E7%90%86Servlet%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.2.</span> <span class="toc-text">登录处理Servlet实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.</span> <span class="toc-text">密码修改实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2"><span class="toc-number">9.3.1.</span> <span class="toc-text">前端页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A4%84%E7%90%86Servlet"><span class="toc-number">9.3.2.</span> <span class="toc-text">编写处理Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84Servlet"><span class="toc-number">9.3.2.1.</span> <span class="toc-text">映射Servlet</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="楼兰"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="楼兰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java Web 快速入门</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2023-05-12 17:45:29" itemprop="dateCreated datePublished" datetime="2023-05-12T17:45:29+08:00">2023-05-12</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="Modified: 2023-06-10 20:58:44" itemprop="dateModified" datetime="2023-06-10T20:58:44+08:00">2023-06-10</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Java-web/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Java web</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/JavaWeb/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">JavaWeb</span></a><a class="tag-item" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">学习笔记</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="静态web和动态web">静态web和动态web</h2>
<p>静态Web和动态Web都是Web应用程序的不同类型，它们的主要区别在于页面内容是如何生成和呈现的。</p>
<p>静态Web是由静态网页组成的Web应用程序，网页的内容在页面请求时已经存在，并且不会随着用户的请求而发生变化。网页内容通常是由HTML、CSS、JavaScript等静态文件组成的，这些文件都是在服务器端预先生成的，当用户访问这些网页时，服务器只需将这些文件发送给用户的浏览器，浏览器将文件解析并显示给用户即可。静态Web通常包含少量的网页，内容不会发生频繁变化，适合于展示企业宣传网站、个人博客等简单的网站。</p>
<p>动态Web是由动态网页组成的Web应用程序，网页内容是在用户请求时根据请求参数和服务器端的处理生成的。网页内容可以根据用户的不同请求参数、数据库查询结果等实时生成。动态Web需要使用服务器端脚本语言（如Java、PHP、Python Servlet/JSP等）来生成HTML页面内容，通常使用数据库来存储和管理数据。动态Web可以实现更复杂的功能，例如在线商城、社交网络、新闻门户等。</p>
<p>总的来说，静态Web适合于内容不会频繁变化，网站规模较小的场景，可以使用简单的HTML、CSS、JavaScript等前端技术来实现；而动态Web适合于内容需要频繁变化、网站规模较大的场景，需要使用服务器端脚本语言和数据库来实现。</p>
<h2 id="web服务器">web服务器</h2>
<h3 id="Tomcat">Tomcat</h3>
<p>Web服务器是一种软件程序，主要用于处理客户端和服务器之间的HTTP请求和响应。它可以接收来自客户端（通常是Web浏览器）的HTTP请求，并返回处理后的HTTP响应。Web服务器通常运行在互联网上，提供各种各样的服务，例如Web网站、电子邮件服务、文件传输等。</p>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512175355319.png" alt="image-20230512175355319" loading="lazy"></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Tomcat</a>是一种流行的开源Web服务器，它实现了Java Servlet和JavaServer Pages (JSP) 规范。Tomcat支持多种操作系统，包括Windows、Linux和Mac OS等，它提供了一个简单的、易于使用的管理界面，允许管理员对服务器进行配置和管理。</p>
<p>Tomcat的主要特点包括：</p>
<ol>
<li>
<p>支持Java Servlet和JSP规范：Tomcat可以运行和处理Java Web应用程序，例如Java Servlet、JSP和JavaServer Faces (JSF) 等。</p>
</li>
<li>
<p>可扩展性：Tomcat支持各种插件和扩展，可以根据需要添加新功能或修改现有功能。</p>
</li>
<li>
<p>易于配置和管理：Tomcat提供了一个简单的管理界面，允许管理员轻松地配置和管理Web服务器，包括添加或删除Web应用程序、配置访问权限等。</p>
</li>
<li>
<p>开源免费：Tomcat是一个开源项目，可以免费使用和修改。这意味着用户可以根据自己的需要进行定制和修改，而不需要支付高昂的授权费用。</p>
</li>
</ol>
<p>总的来说，Tomcat是一种功能强大的Web服务器，非常适合运行Java Web应用程序。它具有可扩展性、易于配置和管理、开源免费等优点，因此在企业和个人用户中非常受欢迎。</p>
<h4 id="Tomcat文件结构">Tomcat文件结构</h4>
<pre><code class="language-shell">cd ~/tomcat //tomcart 安装目录
</code></pre>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512175943702.png" alt="image-20230512175943702" loading="lazy"></p>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512180405774.png" alt="image-20230512180405774" loading="lazy"></p>
<p>访问测试：<a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8080</a></p>
<p>默认端口8080</p>
<h4 id="配置文件">配置文件</h4>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512180642215.png" alt="image-20230512180642215" loading="lazy"></p>
<ul>
<li>可以修改配置的启动端口号, 默认为8080</li>
</ul>
<pre><code class="language-xml">    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<ul>
<li>
<p>可以配置主机的名称, 默认网站的存放位置</p>
<ul>
<li>name=“locahost” 默认主机名对于的ip地址 127.0.0.1</li>
<li>默认网站存放地址: webapps</li>
</ul>
<pre><code class="language-xml"> &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre>
</li>
</ul>
<h4 id="发布一个网站">发布一个网站</h4>
<ul>
<li>将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了。</li>
</ul>
<h3 id="HTTP">HTTP</h3>
<p>HTPP 请求</p>
<pre><code class="language-json">Request URL:https://www.baidu.com/   请求地址
Request Method:GET    get方法/post方法
Status Code:200 OK    状态码：200
Remote（远程） Address:14.215.177.39:443
Accept:text/html  客户端可以接受的语言
Accept-Encoding:gzip, deflate, br 编码
Accept-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0 是否设置缓存
Connection:keep-alive 是否为持续性链接
</code></pre>
<h2 id="Servlet">Servlet</h2>
<h3 id="简介">简介</h3>
<ul>
<li>Servlet就是sun公司开发动态web的一门技术。</li>
<li>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：
<ul>
<li>编写一个类，实现Servlet接口。</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
<li><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong>。</li>
</ul>
<h3 id="第一个Servlet程序-HelloServlet">第一个Servlet程序 HelloServlet</h3>
<ol>
<li>修改web.xml为最新的</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;true&quot;&gt;

&lt;/web-app&gt;
</code></pre>
<ol start="2">
<li>编写一个Servlet程序。</li>
</ol>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512182111384.png" alt="image-20230512182111384" loading="lazy"></p>
<ol start="3">
<li>
<p>编写一个普通类Bean</p>
</li>
<li>
<p>实现servlet接口, 这里我们直接继承HttpServlet</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet &#123;
    // 由于get或post只是请求实现的不同的方式，可以相互调用，业务逻辑都是一样；
  //HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，
//HTTP请求中的所有信息会被封装到HttpServletRequest，
//通过这个HttpServletRequest的方法，获得客户端的所有信息；
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        PrintWriter writer = resp.getWriter();  // 响应流
        writer.print(&quot;Hello,Serlvet&quot;);
	      writer.flush()
    &#125;
</code></pre>
</li>
</ol>
<h4 id="write-和println">write( )和println( )</h4>
<p><code>servletResponse.getWriter().write()``servletResponse.getWriter().println()</code>都是用于将字符串写入到HTTP响应中的方法，但是它们之间有一些关键的区别。</p>
<p><code>servletResponse.getWriter().write()</code>方法是将指定的字符串写入到HTTP响应输出流中，它不会在字符串末尾添加任何换行符或其他字符。如果需要在输出的字符串后面添加换行符或其他字符，就需要在字符串后面显式添加这些字符。</p>
<p><code>servletResponse.getWriter().println()</code>方法也是将指定的字符串写入到HTTP响应输出流中，但是它会在字符串末尾自动添加一个换行符。这个换行符的样式和操作系统相关，通常是<code>\n</code>或<code>\r\n</code>。使用<code>println()</code>方法可以让每个输出的字符串都独占一行，使得输出更易于阅读和处理。</p>
<p>因此，<code>write()</code>方法适合于需要将多个字符串写入到同一行的情况，例如输出CSV格式的数据或者HTML代码的片段。而<code>println()</code>方法适合于需要输出多行字符串的情况，例如输出日志信息或HTML代码的整个页面。</p>
<p>需要注意的是，无论使用哪种方法，都需要在使用完之后调用<code>servletResponse.getWriter().flush()</code>方法将输出流刷新并将数据发送到客户端。如果不调用<code>flush()</code>方法，可能会导致响应数据无法正常发送到客户端。</p>
<ol start="5">
<li>
<p>编写Servlet的映射</p>
<ul>
<li>为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；</li>
</ul>
<pre><code class="language-xml">    &lt;!--注册Servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;cn.loulan.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;!--Servlet的请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
</ol>
<h4 id="Servlet-Mapping">Servlet Mapping</h4>
<ol>
<li>
<p>一个Servlet可以指定一个映射路径。</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>一个Servlet可以指定多个映射路径。</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>一个Servlet可以指定通用映射路径。</p>
<pre><code class="language-xml">    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>默认请求路径。</p>
<pre><code class="language-xml">    &lt;!--默认请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>指定一些后缀或者前缀等等….</p>
<pre><code class="language-xml">    &lt;!-- 可以自定义后缀实现请求映射
         注意点，*前面不能加项目映射的路径
         hello/subei.github
        --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.github&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>优先级问题。</p>
<ul>
<li>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</li>
</ul>
</li>
</ol>
<h3 id="Servlet-Context">Servlet Context</h3>
<ul>
<li>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用(Application)；</li>
</ul>
<p>ServletContext是Java Web应用程序的一个接口，它提供了一个Web应用程序的运行环境，可以访问应用程序的配置信息、资源、请求和会话等。每个Web应用程序都有一个ServletContext实例，可以通过getServletContext()方法获取。</p>
<p>ServletContext提供了以下功能：</p>
<ol>
<li>
<p>应用程序作用域：ServletContext对象是一个应用程序级别的对象，可以在整个应用程序范围内共享数据。</p>
</li>
<li>
<p>应用程序配置信息：ServletContext对象提供了访问Web应用程序的配置信息的方法，例如Web.xml中配置的上下文参数，初始化参数等。</p>
</li>
<li>
<p>资源访问：ServletContext对象提供了一些方法，例如getRealPath()和getResourceAsStream()，可以访问Web应用程序中的资源文件。</p>
</li>
<li>
<p>请求转发：ServletContext对象提供了getRequestDispatcher()方法，可以将请求转发到其他Web组件，例如Servlet或JSP。</p>
</li>
<li>
<p>会话管理：ServletContext对象提供了创建和管理会话的方法，例如getSession()和getSessionCookieConfig()。</p>
</li>
</ol>
<p>ServletContex为Java Web应用程序提供了一个环境，使开发人员可以访问应用程序的配置信息、资源、请求和会话等，并且可以将请求转发到其他Web组件。这使得Java Web应用程序开发变得更加容易和灵活。</p>
<h4 id="利用servletContext实现不同Servlet之前的数据共享">利用servletContext实现不同Servlet之前的数据共享</h4>
<ul>
<li>在这个Servlet中保存的数据，可以在另外一个servlet中拿到；</li>
</ul>
<pre><code class="language-java">public class HelloServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
        String name = &quot;学习超好&quot;;   // 数据
        context.setAttribute(&quot;name&quot;,name);
    &#125;
&#125;
public class GetServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
        String name = (String)context.getAttribute(&quot;name&quot;);
        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字:&quot;+name);
    &#125;
</code></pre>
<h4 id="利用Servlet获取初始化参数">利用Servlet获取初始化参数</h4>
<pre><code class="language-xml">&lt;!-- 配置一些Web应用初始化参数 --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;gp&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.github.servlet.ServletDemo03&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;gp&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/gp&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<pre><code class="language-java">public class ServletDemo03 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
        String url = context.getInitParameter(&quot;url&quot;);
        resp.getWriter().print(url);
    &#125;
</code></pre>
<h4 id="实现请求的转发">实现请求的转发</h4>
<ol start="2">
<li>利用ServletContext实现请求的转发</li>
</ol>
<pre><code class="language-java">public class ServletDemo04 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        ServletContext context = this.getServletContext();
//        调用forward实现请求转发;
//        requestDispatcher.forward(req,resp);
      context.getRequestDispatcher(&quot;url&quot;).forward(req,resp);
    &#125;
</code></pre>
<h4 id="用来读取资源文件">用来读取资源文件</h4>
<ul>
<li>
<p>在resources目录下新建properties</p>
</li>
<li>
<p>思路：需要一个文件流；</p>
</li>
</ul>
<pre><code class="language-properties">username=&quot;楼兰&quot;
</code></pre>
<pre><code class="language-java">public class ServletDemo05 extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;
       InputStream stream = this.getServletContext().getResourceAsStream(&quot;WEB-INF/classes/db.properties&quot;);
        Properties prop = new Properties();
        prop.load(is);
				 String user = prop.getProperty(&quot;username&quot;);
//        但是如果配置文件中如果包含中文，就会出现乱码，所以可以通过中转的形式优化一下：
        prop.load(new InputStreamReader(stream,&quot;UTF-8&quot;));
        resp.getWriter().print(user);
    &#125;
</code></pre>
<h3 id="HttpServletResponse">HttpServletResponse</h3>
<ul>
<li>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；
<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletRequest；</li>
<li>如果要给客户端响应一些信息：找HttpServletResponse。</li>
</ul>
</li>
</ul>
<h4 id="1-简单分类">1.简单分类</h4>
<ul>
<li>负责向浏览器发送数据的方法。</li>
</ul>
<pre><code class="language-java">ServletOutputStream getOutputStream();
PrintWriter getWriter();
</code></pre>
<ul>
<li>负责向浏览器发送响应头的方法。</li>
</ul>
<pre><code class="language-java">    void setCharacterEncoding(String var1);
    void setContentType(String var1);
</code></pre>
<ul>
<li>响应的状态码。</li>
</ul>
<pre><code class="language-java">    int SC_OK = 200;
    int SC_MOVED_PERMANENTLY = 301;
    int SC_NOT_FOUND = 404;
    int SC_INTERNAL_SERVER_ERROR = 500;
</code></pre>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h4 id="2-下载文件">2.下载文件</h4>
<ol>
<li>向浏览器输出消息；</li>
<li>下载文件：
<ol>
<li>要获取下载文件的路径；</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西；</li>
<li>获取下载文件的输入流；</li>
<li>创建缓冲区；</li>
<li>获取OutputStream对象；</li>
<li>将FileOutputStream流写入到buffer缓冲区；</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
</li>
</ol>
<pre><code class="language-java">public class FIleServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
//        1. 获取下载文件的路径；
    String url = &quot;/Users/trevorwu/Maven_03/HelloServlet/src/main/resources/Peekaboo.png&quot;;
//        2. 获取文件名
        String fileName = &quot;downFile.png&quot;;
//        3. 让浏览器能够支持下载我们需要的东西；
//        这段代码是用来设置 HTTP 响应头，将服务器返回的内容作为文件附件（attachment）下载，而非直接在浏览器中打开。
//        具体地，`resp.setHeader()` 方法设置了一个名为 &quot;Content-Disposition&quot; 的响应头，
//        其值为 &quot;attachment;filename=xxxxx&quot;，其中 &quot;xxxxx&quot; 是要下载的文件名。
//        这个文件名可以是服务器上的文件名，也可以是通过代码生成的文件名。
//        这个文件名决定了用户下载得到的文件名， 而非服务器上的文件名， 服务器的文件名在下载文件的地址中指定
        resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;
                + URLEncoder.encode(fileName,&quot;UTF-8&quot;));
//        4. 获取下载文件的输入流；
        FileInputStream in = new FileInputStream(url);
//        5. 创建缓冲区；
        int len = 0;
        byte buffer[] = new byte[1024];
//        6. 获取OutputStream对象；
        ServletOutputStream out = resp.getOutputStream();
//        7. 将FileOutputStream流写入到buffer缓冲区；
//        这段代码是将输入流 `in` 中的数据读取到缓冲区 `buffer` 中，再通过输出流 `out` 输出到目标位置。
//        具体地，循环读取操作会在输入流中读取数据，并将数据写入到缓冲区中，
//        当读取到的数据长度为0时，说明已经读取完毕，退出循环。
//在每次循环中，通过调用 `out.write(buffer, 0, len)` 方法，将缓冲区中的数据写入输出流中。
// 这里的 `buffer` 是一个字节数组，`len` 是每次读取的字节数。
// 第二个参数 `0` 表示从缓冲区的第一个字节开始写入，而不是从数组的第一个元素开始写入。
//通过这段代码，我们可以实现从输入流中读取数据，然后将数据输出到目标位置的操作，通常用于文件下载或数据传输等场景。
        while ((len=in.read(buffer)) &gt; 0)&#123;
            out.write(buffer,0,len);
        &#125;
//        close input output stream
        in.close();
        out.close();
    &#125;
</code></pre>
<h4 id="3-验证码功能">3.验证码功能*</h4>
<ul>
<li>验证怎么来的？
<ul>
<li>前端实现；</li>
<li>后端实现，需要用到 Java 的图片类，生产一个图片。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class ImageServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;
//        如何让浏览器3秒自动刷新一次;
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
//        在内存中创建一个图片
        BufferedImage image = new BufferedImage(90,40,BufferedImage.TYPE_INT_RGB);
//        得到图片,笔
        Graphics2D g = (Graphics2D) image.getGraphics();
//        设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,90,40);
//        给图片写数据
        g.setColor(Color.RED);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),8,30);

//        告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpeg&quot;);
//        网站存在缓存，不让浏览器缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);

//        把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());

    &#125;

//    生成随机数
    private String makeNum()&#123;
        Random random = new Random();
        String num = random.nextInt(9999999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 7-num.length() ; i++) &#123;
            sb.append(&quot;0&quot;);
        &#125;
        num = sb.toString() + num;
        return num;
    &#125;
</code></pre>
<h4 id="4-实现重定向">4.实现重定向</h4>
<p>之前我们学过利用Servlet实现请求的转发, 这里我们利用response来实现请求重定向</p>
<ol>
<li>重定向和转发的区别</li>
</ol>
<p>重定向和转发是在Java Servlet编程中常用的两种将请求从一个Servlet转发到另一个Servlet或JSP的方式，它们有一些关键的区别。</p>
<p>重定向（Redirect）是指当一个Servlet收到一个请求时，它会发送一个HTTP响应告诉浏览器发送一个新的请求到指定的URL。这个URL可以是一个Servlet、JSP、HTML页面或其他任何类型的资源。因此，重定向会导致浏览器向指定的URL发起一个全新的请求，而这个新请求的路径是由浏览器在重定向时自动发送的，不再是原始请求的路径。在重定向中，所有请求参数都会丢失，因此需要通过查询字符串或Session等方式传递参数。重定向可以用于将用户重定向到一个新的页面，或者将用户从一个应用程序重定向到另一个应用程序。</p>
<p>转发（Forward）是指当一个Servlet收到一个请求时，它会将请求转发到另一个Servlet或JSP来处理。在转发中，请求和响应对象是同一个，只是Servlet容器将请求转发给了另一个资源来生成响应。因此，在转发中，所有请求参数都会保留，并且可以在目标Servlet或JSP中访问。转发通常用于将请求从一个Servlet传递到另一个Servlet或JSP来生成响应，以便可以在请求和响应之间共享数据。</p>
<p>因此，重定向和转发都可以将请求从一个Servlet转发到另一个Servlet或JSP来生成响应，但它们的区别在于重定向会发送一个新的请求到指定的URL，而转发则将请求转发到另一个Servlet或JSP来处理，响应由目标Servlet或JSP生成。重定向导致的性能开销比转发更高，因为它需要向浏览器发送一个新的请求，而转发则在服务器内部进行，无需向浏览器发送任何内容。</p>
<pre><code class="language-java">public class RedirectServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        resp.sendRedirect(&quot;/response/img&quot;);    // 重定向
    &#125;

</code></pre>
<h4 id="5-简单实现登录重定向">5.简单实现登录重定向</h4>
<pre><code class="language-java">public class Log extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
 this.getServletContext().getRequestDispatcher(&quot;/hello&quot;).forward(req, resp);
    &#125;
</code></pre>
<p>这段代码用于Java Servlet编程中，将一个请求从一个Servlet转发到同一Web应用程序中的另一个Servlet或JSP（Java服务器页面）。</p>
<p><code>getRequestDispatcher()</code>方法的参数是请求转发到的资源的相对或绝对路径。在本例中，路径为“/hello”，这是另一个Servlet.</p>
<p>然后调用<code>RequestDispatcher</code>对象的<code>forward()</code>方法，传递<code>req</code>和<code>resp</code>参数。这些是传递到原始Servlet的<code>doGet()</code>或<code>doPost()</code>方法中的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象。<code>forward()</code>方法将这些对象发送到指定的资源，并允许该资源生成要发送回客户端的响应。</p>
<p>总之，这段代码将一个请求从当前Servlet转发到同一Web应用程序中的另一个Servlet或JSP，同时传递<code>HttpServletRequest</code>和<code>HttpServletResponse</code>对象。目标资源将生成要发送回客户端的响应。</p>
<h3 id="HttpServletRequest">HttpServletRequest</h3>
<ul>
<li>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</li>
</ul>
<pre><code class="language-java">//        HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，
//        HTTP请求中的所有信息会被封装到HttpServletRequest，
//        通过这个HttpServletRequest的方法，获得客户端的所有信息；
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        String host = req.getHeader(&quot;Host&quot;);
        resp.getWriter().println(&quot;username:&quot;+username+&quot; password:&quot;+password+&quot; host:&quot;+host);
//        `req.getContextPath()` 是一个 Java Servlet API 中的方法，它返回当前 Servlet 的上下文路径。
//        上下文路径是指 Web 应用程序的 URL 中，主机名和端口号后的第一个路径。
//例如，如果 Web 应用程序的 URL 是 `http://example.com:8080/myapp/index.jsp`，
// 那么上下文路径就是 `/myapp`。
        resp.getWriter().println(&quot;Context path&quot;+req.getContextPath());
       
</code></pre>
<h3 id="保存会话的两种技术">保存会话的两种技术</h3>
<h4 id="Cookies">Cookies</h4>
<img src="https://cdn4.iconfinder.com/data/icons/web-hosting-pack-vol-1/512/HTTP_Cookie-512.png" alt="Cookie, http, cookies, internet cookies, web cookies icon - Download on  Iconfinder" style="zoom:25%;" / loading="lazy">
<p><strong>HTTP cookie</strong>，简称<strong>cookie</strong>，又称“<strong>网站／浏览＋魔饼／魔片</strong>”等，是浏览<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99">网站</a>时由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E5%99%A8">网络服务器</a>创建并由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>存放在用户计算机或其他设备的小文本文件。</p>
<p>Cookie使Web服务器能在用户的设备存储状态信息（如添加到在线商店购物车中的商品）或跟踪用户的浏览活动（如点击特定按钮、登录或记录历史.</p>
<p>cookie 是服务器在 HTTP 响应中发送的一段数据。客户端（可选）存储 cookie 并在后续请求中返回它。这允许客户端和服务器共享状态。要设置 cookie，服务器会在响应中包含一个 Set-Cookie 标头。cookie 的格式是名称-值对，带有可选属性。例如：</p>
<pre><code class="language-powershell">Set-Cookie: session-id=1234567
</code></pre>
<p>这是一个带有属性的示例：</p>
<pre><code class="language-powershell">Set-Cookie: session-id=1234567; max-age=86400; domain=example.com; path=/;
</code></pre>
<p>为了向服务器返回 cookie，客户端在以后的请求中包含一个 Cookie 标头。</p>
<pre><code class="language-shell">Cookie: session-id=1234567
</code></pre>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image1.png" alt="HTTP Cookies in ASP.NET Web API - ASP.NET 4.x | Microsoft Learn" loading="lazy"></p>
<h4 id="利用Cookies记录用户上一次登录时间">利用Cookies记录用户上一次登录时间</h4>
<pre><code class="language-java">public class Cookie extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
				//get all cookies
        javax.servlet.http.Cookie[] cookies = req.getCookies();
        for (javax.servlet.http.Cookie cookie : cookies) &#123;
            String name = cookie.getName();
            if(name.equals(&quot;lastLoginTime&quot;))&#123;
                String value = cookie.getValue();
                long parseLong = Long.parseLong(cookie.getValue());
                Date date = new Date(parseLong);
                resp.getWriter().println(&quot;lastLoginTime: &quot;+date.toLocaleString());
            &#125;
        &#125;
        javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis() + &quot;&quot;);
        resp.addCookie(cookie);
    &#125;
</code></pre>
<h4 id="session"><strong>session</strong></h4>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>领域来说，尤其是在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">网络</a>领域，<strong>会话</strong>（英语：session，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</a>译作<strong>工作阶段</strong>、<strong>连线阶段</strong>）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>（例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Telnet">telnet</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FTP">FTP</a>）中是非常重要的部分。</p>
<p>在不包含<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82">会话层</a>（例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>）或者是无法长时间驻留会话层（例如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。</p>
<ul>
<li>
<p>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</p>
</li>
<li>
<p>服务器会给每一个用户（浏览器）创建一个Seesion对象；</p>
</li>
<li>
<p>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；</p>
</li>
<li>
<p>用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息……</p>
</li>
</ul>
<h4 id="Session和cookie的区别：">Session和cookie的区别：</h4>
<p>Cookie和Session是Web应用程序中常用的两种用于保存用户状态信息的机制。</p>
<p>相同点：</p>
<ol>
<li>
<p>都是用于在Web应用程序中保存用户状态信息的机制。</p>
</li>
<li>
<p>都可以在多个请求之间保持用户的状态信息，使用户在浏览网站时能够保持状态的连续性。</p>
</li>
<li>
<p>都可以在一定程度上提高Web应用程序的性能，减少对服务器的负载。</p>
</li>
</ol>
<p>不同点：</p>
<ol>
<li>
<p>存储位置不同：Cookie保存在客户端的浏览器中，而Session保存在服务器端的内存或者硬盘中。</p>
</li>
<li>
<p>存储容量不同：Cookie的存储容量比Session小。</p>
</li>
<li>
<p>安全性不同：由于Session数据存储在服务器端，因此相对于Cookie更加安全，Cookie数据容易被篡改或盗用。</p>
</li>
<li>
<p>过期时间不同：Session的过期时间可以由开发人员在代码中设置，而Cookie的过期时间可以在创建Cookie时设置，也可以在浏览器中手动删除。</p>
</li>
<li>
<p>使用场景不同：Cookie适用于需要长期保存用户状态信息的场景，例如保存用户的登录状态、偏好设置等；而Session适用于需要在短时间内保存用户状态信息的场景，例如购物车、会话信息等。</p>
</li>
</ol>
<h4 id="利用Session返回客户端一个Person对象-并在浏览器上打印">利用Session返回客户端一个Person对象, 并在浏览器上打印</h4>
<pre><code class="language-java">public class Session extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        HttpSession session = req.getSession();
        session.setAttribute(&quot;person&quot;,new Person(&quot;Alice&quot;, &quot;Alice@gmail.com&quot;));
        resp.getWriter().write(&quot;Session id&quot;+session.getId());
        Person person = (Person) session.getAttribute(&quot;person&quot;);
        resp.getWriter().write(&quot;name&quot;+person.toString());
    &#125;
          //client 每次访问服务器都会在服务器端维护一个Session, 并向用户以Cookie的方式，发送Session id,
//        但是对于client而言， 这个Session id 是以Cookie的形式存储在浏览器上的， 所以更换浏览器访问后Cookie改变了
//        所以，服务器会认为这是一个新的Session.
//        下一次用户再次访问的时候就会拿着这个Session id 访问Serve， Server就知道这个客户的信息
//        1. 拿到Session， 这个Cookie是由客户端发送给服务器的

//        Session 可以使用setAttribute方法来保存信息
//        不同于Cookie，Session 可以保存一个对象(Object)， 而不是仅仅是一个String
</code></pre>
<p><strong>会话自动过期：web.xml配置</strong>！</p>
<pre><code class="language-xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<h3 id="JSP-Java-Server-Pages">JSP (Java Server Pages)</h3>
<p><strong>JSP</strong>（全称<strong>J</strong>akarta <strong>S</strong>erver <strong>P</strong>ages，曾称为<strong>J</strong>ava<strong>S</strong>erver <strong>P</strong>ages）是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a>公司主导创建的一种动态网页技术标准。</p>
<p><strong>Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！</strong></p>
<ul>
<li>最大的特点：
<ul>
<li>写JSP就像在写HTML；</li>
<li>区别：
<ul>
<li>HTML只给用户提供静态的数据；</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="JSP原理">JSP原理</h4>
<p>思路：JSP到底怎么执行的！</p>
<ul>
<li>
<p>服务器内部工作：</p>
<ul>
<li>tomcat中有一个work目录；</li>
</ul>
</li>
<li>
<p>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录；</p>
<p>IDEA会为每个Tomcat Webapps创建一个文件夹,用来存放这个APP的配置文件, 工作路径, 在我的MAC路径<code>/Users/trevorwu/Library/Caches/JetBrains/IntelliJIdea2022.3/tomcat/47ad80c0-0fbd-41b1-a4ae-e036ca41705b</code></p>
<p>我们进入这个路径的最深处</p>
<p>`cd Catalina/localhost/ROOT/org/apache/jsp</p>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512202849320.png" alt="image-20230512202849320" loading="lazy"></p>
<p>可以看到这里面有两个文件, 一个是<code>index_jsp.class</code> 另一个是<code>index_jsp.java` 很明显, `index_jsp.class`就是</code>index_jsp.java` 编译生成的class文件.</p>
<p>这是只有一个这样的class, 也就是我们的主页index.jsp</p>
<img src="Java-Web-快速入门/image-20230512203239731.png" alt="image-20230512203239731" style="zoom:33%;" / loading="lazy">
</li>
</ul>
<p>也就是说, 如果我们访问index.jsp, 相当于访问根目录<code>localhost:8080/</code> 服务器就会生成对应的.java文件, 以及.class文件用来处理请求. 这个.java文件本质上就是Servlet. 如果这时候我们访问别的页面, 就会生成新的Servlet.</p>
<ul>
<li><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></li>
<li>JSP最终也会被转换成为一个Java类！</li>
<li><strong>JSP 本质上就是一个Servlet</strong>！</li>
</ul>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-java">// 初始化
  public void _jspInit() &#123;
  &#125;
// 销毁
  public void _jspDestroy() &#123;
  &#125;
// JSPService
  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException &#123;   
</code></pre>
<ol>
<li>
<p>内置一些对象；</p>
<pre><code class="language-java">final javax.servlet.jsp.PageContext pageContext;  // 页面上下文
javax.servlet.http.HttpSession session = null;    // session
final javax.servlet.ServletContext application;   // applicationContext
final javax.servlet.ServletConfig config;         // config
javax.servlet.jsp.JspWriter out = null;           // out
final java.lang.Object page = this;               // page：当前
HttpServletRequest request                        // 请求
HttpServletResponse response                      // 响应
</code></pre>
</li>
<li>
<p>输出页面前增加的代码；</p>
<pre><code class="language-java">response.setContentType(&quot;text/html&quot;);       // 设置响应的页面类型
pageContext = _jspxFactory.getPageContext(this, request, response,
                                          null, true, 8192, true);
_jspx_page_context = pageContext;
application = pageContext.getServletContext();
config = pageContext.getServletConfig();
session = pageContext.getSession();
out = pageContext.getOut();
_jspx_out = out;
</code></pre>
</li>
<li>
<p>以上的这些个对象我们可以在JSP页面中直接使用！</p>
</li>
</ol>
<ul>
<li>在JSP页面中：
<ul>
<li>只要是 JAVA代码就会原封不动的输出；</li>
<li>如果是HTML代码，就会被转换为：</li>
</ul>
</li>
</ul>
<pre><code class="language-java">      out.write(&quot;&lt;html&gt;\n&quot;);
      out.write(&quot;  &lt;head&gt;\n&quot;);
      out.write(&quot;    &lt;title&gt;$Title$&lt;/title&gt;\n&quot;);
      out.write(&quot;  &lt;/head&gt;\n&quot;);
      out.write(&quot;  &lt;body&gt;\n&quot;);
      out.write(&quot;  $END$\n&quot;);
      out.write(&quot;  &lt;/body&gt;\n&quot;);
      out.write(&quot;&lt;/html&gt;\n&quot;);
</code></pre>
<ul>
<li>这样的格式，输出到前端！</li>
</ul>
<h4 id="JSP语法">JSP语法</h4>
<ul>
<li>任何语言都有自己的语法，JAVA中有，JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！</li>
<li>配置必需的maven环境：</li>
</ul>
<pre><code class="language-xml">&lt;!--        JSP 依赖   --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        JSTL表达式的依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
&lt;!--        standard标签库--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;taglibs&lt;/groupId&gt;
            &lt;artifactId&gt;standard&lt;/artifactId&gt;
            &lt;version&gt;1.1.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h5 id="JSP表达式">JSP表达式</h5>
<pre><code class="language-jsp">  &lt;body&gt;
  &lt;%--JSP表达式
              作用：用来将程序的输出，输出到客户端
              &lt;%= 变量或者表达式%&gt;
  --%&gt;
  &lt;%= new java.util.Date()%&gt;
  &lt;/body&gt;
</code></pre>
<h5 id="jsp脚本片段">jsp脚本片段</h5>
<pre><code class="language-jsp">  &lt;body&gt;
  &lt;%--jsp脚本片段--%&gt;
  &lt;%
    int sum = 0;
    for (int i = 1; i &lt;=100 ; i++) &#123;
      sum+=i;
    &#125;
    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);
  %&gt;
  &lt;/body&gt;
</code></pre>
<ul>
<li>JSP声明</li>
<li>&lt;%! code %&gt;</li>
</ul>
<pre><code class="language-jsp">  &lt;body&gt;
  &lt;%!
    static &#123;
      System.out.println(&quot;Loading Servlet!&quot;);
    &#125;
    private int globalVar = 0;
    public void guo()&#123;
      System.out.println(&quot;进入了方法guo！&quot;);
    &#125;
  %&gt;
  &lt;/body&gt;
</code></pre>
<ul>
<li>JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！</li>
</ul>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70-20230512204121432.png" alt="在这里插入图片描述" loading="lazy"></p>
<h5 id="JSP指令-404与500页面实现">JSP指令: 404与500页面实现</h5>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20230512204634669.png" alt="image-20230512204634669" loading="lazy"></p>
<pre><code class="language-xml">&lt;!--    自定义错误页面--&gt;
&lt;!--    配置之后记得重启Tomcat服务， 修改tomcat配置文件web.xml热部署不生效--&gt;
&lt;!--    自由修改jsp文件才能热部署--&gt;
    &lt;error-page&gt;
        &lt;error-code&gt;404&lt;/error-code&gt;
        &lt;location&gt;/error/404.jsp&lt;/location&gt;
    &lt;/error-page&gt;
    &lt;error-page&gt;
        &lt;error-code&gt;500&lt;/error-code&gt;
        &lt;location&gt;/error/500.jsp&lt;/location&gt;
    &lt;/error-page&gt;
</code></pre>
<h6 id="头部和尾部页面拼接">头部和尾部页面拼接</h6>
<pre><code class="language-jsp">&lt;body&gt;
    &lt;%-- @include会将两个页面合二为一 --%&gt;

    &lt;%@include file=&quot;common/header.jsp&quot;%&gt;
    &lt;h1&gt;网页主体&lt;/h1&gt;
    &lt;%@include file=&quot;common/footer.jsp&quot;%&gt;

    &lt;hr&gt;

    &lt;%--
        jsp标签
        jsp:include：拼接页面，本质还是三个
    --%&gt;
    &lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;
    &lt;h1&gt;网页主体&lt;/h1&gt;
    &lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;

&lt;/body&gt;
</code></pre>
<h4 id="内置对象">内置对象</h4>
<ul>
<li>PageContext 存东西</li>
<li>Request 存东西</li>
<li>Response</li>
<li>Session 存东西</li>
<li>Application 【SerlvetContext】 存东西</li>
<li>config 【SerlvetConfig】</li>
<li>out</li>
<li>page ，不用了解</li>
<li>exception</li>
</ul>
<pre><code class="language-java">&lt;body&gt;
&lt;%--内置对象--%&gt;
&lt;%
    pageContext.setAttribute(&quot;name1&quot;,&quot;天启1号&quot;); // 保存的数据只在一个页面中有效
    request.setAttribute(&quot;name2&quot;,&quot;天启2号&quot;); // 保存的数据只在一次请求中有效，请求转发会携带这个数据
    session.setAttribute(&quot;name3&quot;,&quot;天启3号&quot;); // 保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器
    application.setAttribute(&quot;name4&quot;,&quot;天启4号&quot;);  // 保存的数据只在服务器中有效，从打开服务器到关闭服务器
%&gt;

&lt;%--
    脚本片段中的代码，会被原封不动生成到.jsp.java
    要求：这里面的代码，必须保证Java语法的正确性
--%&gt;

&lt;%
    // 从pageContent取出，我们通过寻找的方式来
    // 从底层到高层（作用域）:
    String name1 = (String) pageContext.findAttribute(&quot;name1&quot;);
    String name2 = (String) pageContext.findAttribute(&quot;name2&quot;);
    String name3 = (String) pageContext.findAttribute(&quot;name3&quot;);
    String name4 = (String) pageContext.findAttribute(&quot;name4&quot;);
    String name5 = (String) pageContext.findAttribute(&quot;name5&quot;); // 作用域

%&gt;

&lt;%--使用EL表达式输出 $&#123;&#125; --%&gt;
&lt;h1&gt;取出的值:&lt;/h1&gt;
&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;
&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;
&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;
&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;
&lt;h3&gt; &lt;%=name5%&gt; &lt;/h3&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</li>
<li>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</li>
<li>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</li>
</ul>
<h4 id="JSP标签-JSTL标签-EL表达式">JSP标签.JSTL标签.EL表达式</h4>
<ul>
<li>EL表达式： ${ }
<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li><strong>获取web开发的常用对象</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-jsp">&lt;!-- JSTL表达式的依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- standard标签库 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>
<p><strong>JSP标签</strong></p>
</li>
<li>
<p>利用JSP标签实现请求转发, 并设置参数</p>
<p>&lt;jsp:forward page=“url”&gt;</p>
</li>
</ul>
<pre><code class="language-jsp">&lt;body&gt;
&lt;%--jsp:include--%&gt;
&lt;jsp:forward page=&quot;/jspTag2.jsp&quot;&gt;
    &lt;jsp:param name=&quot;name&quot; value=&quot;subeiLY&quot;/&gt;
    &lt;jsp:param name=&quot;age&quot; value=&quot;18&quot;/&gt;
&lt;/jsp:forward&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>再转发的目标Servlet取参数</li>
</ul>
<pre><code class="language-jsp">&lt;body&gt;
&lt;%--取出参数--%&gt;
名字:&lt;%=request.getParameter(&quot;name&quot;)%&gt;
年龄:&lt;%=request.getParameter(&quot;age&quot;)%&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>
<p><strong>JSTL表达式</strong></p>
<ul>
<li>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！</li>
</ul>
</li>
<li>
<p><strong>格式化标签</strong></p>
</li>
<li>
<p><strong>SQL标签</strong></p>
</li>
<li>
<p><strong>XML 标签</strong></p>
</li>
<li>
<p><em><strong>核心标签</strong> （掌握部分）</em></p>
</li>
<li>
<p><strong>JSTL标签库使用步骤</strong>：</p>
<ul>
<li>引入对应的 taglib；</li>
<li>使用其中的方法；</li>
<li><strong>在Tomcat 的lib目录下也需要引入 jstl-api-1.2.jar、standard-1.1.2.jar的包，否则会报错：JSTL解析错误</strong>；</li>
</ul>
</li>
<li>
<p>c：if标签 EL表达式获取表单中的数据</p>
<pre><code class="language-jsp">&lt;body&gt;
&lt;form action=&quot;core-if.jsp&quot; method=&quot;get&quot;&gt;
    &lt;%--
        EL表达式获取表单中的数据
        $&#123;param.参数名&#125;
    --%&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
&lt;/form&gt;

&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;
&lt;c:if test=&quot;$&#123;param.username=='admin'&#125;&quot; var=&quot;isAdmin&quot;&gt;
    &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;
&lt;/c:if&gt;
  
&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>c:choose c:when 实现成绩判断(Switch case)</li>
</ul>
<pre><code class="language-jsp">&lt;body&gt;

&lt;%--定义一个变量score，值为85--%&gt;
&lt;c:set var=&quot;score&quot; value=&quot;65&quot;/&gt;

&lt;c:choose&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt;
        你的成绩为优秀
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt;
        你的成绩为一般
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt;
        你的成绩为良好
    &lt;/c:when&gt;
    &lt;c:when test=&quot;$&#123;score&lt;=60&#125;&quot;&gt;
        你的成绩为不及格
    &lt;/c:when&gt;
&lt;/c:choose&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>c:forEach</li>
</ul>
<pre><code class="language-jsp">&lt;body&gt;
&lt;%

    ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;();
    people.add(0,&quot;Alice&quot;);
    people.add(1,&quot;Bob&quot;);
    people.add(2,&quot;楼兰&quot;);
    people.add(3,&quot;Goobus&quot;);
    people.add(4,&quot;Kris&quot;);
    request.setAttribute(&quot;list&quot;,people);
%&gt;

&lt;%--
var , 每一次遍历出来的变量
items, 要遍历的对象
begin,   哪里开始
end,     到哪里
step,   步长 (i++)
--%&gt;
&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot;&gt;
    &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

&lt;hr&gt;

&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; &gt;
    &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt; &lt;br&gt;
&lt;/c:forEach&gt;

&lt;/body&gt;
</code></pre>
</li>
</ul>
<h2 id="JavaBean">JavaBean</h2>
<p>实体类，JavaBean有特定的写法：</p>
<ul>
<li>必须要有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法；</li>
</ul>
<p>一般用来和数据库的字段做映射 ORM；</p>
<p>ORM ：对象关系映射</p>
<ul>
<li>表—&gt;类</li>
<li>字段–&gt;属性</li>
<li>行记录----&gt;对象</li>
</ul>
<pre><code class="language-jsp">&lt;jsp:useBean id=&quot;people&quot; class=&quot;cn.loulan.Bean.People&quot; /&gt;

&lt;jsp:setProperty name=&quot;people&quot; property=&quot;address&quot; value=&quot;成都&quot;/&gt;
&lt;jsp:setProperty name=&quot;people&quot; property=&quot;id&quot; value=&quot;1&quot;/&gt;
&lt;jsp:setProperty name=&quot;people&quot; property=&quot;age&quot; value=&quot;2&quot;/&gt;
&lt;jsp:setProperty name=&quot;people&quot; property=&quot;name&quot; value=&quot;哇哈哈AD钙&quot;/&gt;

姓名:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;name&quot;/&gt;
 ID:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;id&quot;/&gt;
年龄:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;age&quot;/&gt;
地址:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;address&quot;/&gt;
</code></pre>
<h2 id="MVC三层架构">MVC三层架构</h2>
<ul>
<li>什么是MVC： Model view Controller 模型.视图.控制器</li>
</ul>
<h3 id="1-早些年">1.早些年</h3>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70-20230512210458691.png" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li>用户直接访问控制层，控制层就可以直接操作数据库；</li>
</ul>
<pre><code class="language-java">servlet--CRUD--&gt;数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求.响应.视图跳转.处理JDBC.处理业务代码.处理逻辑代码

架构：没有什么是加一层解决不了的！
程序猿调用
|
JDBC
|
Mysql Oracle SqlServer ....
</code></pre>
<h3 id="2-MVC三层架构">2.MVC三层架构</h3>
<p><img src="Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MTUzOTQ5,size_16,color_FFFFFF,t_70-20230512210458822.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>Model</p>
<ul>
<li>业务处理 ：业务逻辑（Service）</li>
<li>数据持久层：CRUD （Dao）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求 （a，form，img…）</li>
</ul>
<p>Controller （Servlet）</p>
<ul>
<li>
<p>接收用户的请求 ：（req：请求参数.Session信息….）</p>
</li>
<li>
<p>交给业务层处理对应的代码</p>
</li>
<li>
<p>控制视图的跳转</p>
<pre><code class="language-java">登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库
</code></pre>
</li>
</ul>
<h2 id="Filter-重点">Filter(重点)</h2>
<p>Filter：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证….</li>
</ul>
<p>Filter开发步骤：</p>
<ol>
<li>导包</li>
<li>编写过滤器</li>
</ol>
<pre><code class="language-xml">        &lt;!--   Servlet 依赖   --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        JSP 依赖   --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        JSTL表达式的依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        standard标签库--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;taglibs&lt;/groupId&gt;
            &lt;artifactId&gt;standard&lt;/artifactId&gt;
            &lt;version&gt;1.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--    连接数据库--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>实现Filter接口，重写对应的方法即可；</li>
</ol>
<p>使用Filter设置编码, 防止乱码</p>
<pre><code class="language-java">public class Filter implements javax.servlet.Filter &#123;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        //项目启动的时候被调用
        System.out.println(&quot;init filter&quot;);
    &#125;
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        servletRequest.setCharacterEncoding(&quot;UTF-8&quot;);
        servletResponse.setCharacterEncoding(&quot;UTF-8&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;
</code></pre>
<p>这段代码是Java Servlet中用于实现Filter的接口方法<code>doFilter()</code>的签名。</p>
<p>Filter是一种用于在Servlet容器中对请求和响应进行预处理和后处理的组件。Filter可以截取请求和响应，修改请求参数或响应内容，或者根据某些条件决定是否允许请求继续处理。</p>
<p><code>doFilter()</code>方法接受三个参数：</p>
<p><code>ServletRequest servletRequest</code>、<br>
<code>ServletResponse servletResponse</code><br>
<code>FilterChain filterChain</code></p>
<p><code>ServletRequest</code>表示接收到的HTTP请求，<code>ServletResponse</code>表示将要发送的HTTP响应，<code>FilterChain</code>表示Filter链。</p>
<p>在<code>doFilter()</code>方法中，Filter可以对请求和响应进行任何必要的操作。</p>
<p>例如，可以检查请求参数、修改请求头、记录请求日志等。</p>
<p>然后，Filter必须调用<code>filterChain.doFilter()</code>方法，将请求传递给下一个Filter或目标Servlet来进行处理。</p>
<p>如果不调用<code>filterChain.doFilter()</code>方法，请求将不会传递到下一个组件，也不会生成响应。在最后一个Filter或目标Servlet中，必须生成响应并将其发送回客户端。</p>
<p>在Filter链中的每个Filter都必须调用<code>filterChain.doFilter()</code>方法，否则请求将停止在当前Filter，不会传递到后续的Filter或目标Servlet。</p>
<p>如果在Filter链中的某个Filter中调用了<code>filterChain.doFilter()</code>方法之前或之后生成了响应，或者没有调用<code>filterChain.doFilter()</code>方法，都会导致请求失败或无法正常响应。</p>
<ol start="4">
<li>在web.xml中配置 Filter；</li>
</ol>
<pre><code class="language-xml">&lt;!--mapping filter--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encode&lt;/filter-name&gt;
        &lt;filter-class&gt;cn.loulan.servlet.Filter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encode&lt;/filter-name&gt;
       &lt;!--只要是 /filter的任何请求，会经过这个过滤器--&gt;
        &lt;url-pattern&gt;/filter&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</code></pre>
<h2 id="监听器-Listener">监听器(Listener)</h2>
<p>实现一个监听器的接口；（有N种）</p>
<ol>
<li>
<p>编写一个监听器；</p>
<p>实现监听器的接口…</p>
<pre><code class="language-java">public class OnlineCountListener implements HttpSessionListener &#123;
//    我们使用一个Integer对象来表示当前在线用户数，
//    并且在每次Session创建时，都将在线用户数加1。
//    然后，我们将在线用户数存储在ServletContext中，
//    以便在整个Web应用程序中共享和使用。
    @Override
    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;
        ServletContext servletContext = httpSessionEvent.getSession().getServletContext();
        Integer onlineCounter = (Integer) servletContext.getAttribute(&quot;onlineCounter&quot;);
        if(onlineCounter == null)&#123;
            onlineCounter = Integer.valueOf(1);
        &#125; else &#123;
            onlineCounter = Integer.valueOf(onlineCounter.intValue() + 1);
        &#125;
        servletContext.setAttribute(&quot;onlineCounter&quot;, onlineCounter);
    &#125;

    @Override
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;
        Integer onlineCounter = (Integer) httpSessionEvent.getSession().getServletContext().getAttribute(&quot;onlineCounter&quot;);
        if(onlineCounter == null)&#123;
            onlineCounter = Integer.valueOf(0);
        &#125;else &#123;
            onlineCounter = Integer.valueOf(onlineCounter.intValue()- 1);
        &#125;
        httpSessionEvent.getSession().setAttribute(&quot;onlineCounter&quot;, onlineCounter);
    &#125;
&#125;

</code></pre>
<ol start="2">
<li>
<p>注册监听器</p>
<pre><code class="language-xml">&lt;!--    Listener--&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;cn.loulan.servlet.OnlineCountListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="过滤器-监听器常见应用">过滤器.监听器常见应用</h3>
<ul>
<li>
<h4 id="监听器：GUI编程中经常使用；"><strong>监听器：GUI编程中经常使用；</strong></h4>
<pre><code class="language-java">public class TestPanel &#123;
    public static void main(String[] args) &#123;
        // 新建一个窗体
        Frame frame = new Frame(&quot;Happy Day&quot;);
        // 面板
        Panel panel = new Panel(null);
        // 设置窗体的布局
        frame.setLayout(null);
        frame.setBounds(300,300,500,500);
        // 设置背景颜色1
        frame.setBackground(Color.lightGray);
        // 设置背景颜色2
        panel.setBackground(Color.orange);
        panel.setBounds(frame.getX()/2, frame.getY()/2, frame.getWidth()/2, frame.getHeight()/2);
        frame.add(panel);
        frame.setVisible(true);
        // 监听事件，监听关闭事件
        frame.addWindowListener(new WindowAdapter() &#123;
            @Override
            public void windowClosing(WindowEvent e) &#123;
                    frame.dispose();
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>
<h4 id="过滤器：用户登录之后才能进入主页！用户注销后就不能进入主页了">过滤器：用户登录之后才能进入主页！用户注销后就不能进入主页了</h4>
<ol>
<li>用户登录之后，向Sesison中放入用户的数据</li>
<li>进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！</li>
</ol>
<pre><code class="language-java">public class Log extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String username = req.getParameter(&quot;username&quot;);
        String password = req.getParameter(&quot;password&quot;);
        HttpSession session = req.getSession();
        if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;root&quot;.equals(password)) &#123;
            session.setAttribute(Constants.USER_SESSION,new Person(username,password));
            resp.sendRedirect(&quot;/pages/success.jsp&quot;);
        &#125; else &#123;
            resp.sendRedirect(&quot;/&quot;);
        &#125;
    &#125;
</code></pre>
<p>LoginFilter</p>
<pre><code class="language-java">public class LoginFilter extends Filter&#123;
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
// ServletRequest 转化为 HttpServletRequest 
// 目的是拿到Session, 以便获取Attribute
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        Object o = request.getSession().getAttribute(Constants.USER_SESSION);
        if(o == null) &#123;
            response.sendRedirect(&quot;/&quot;);
        &#125;
        filterChain.doFilter(servletRequest, servletResponse);
    &#125;
&#125;

</code></pre>
<p>LogoutServlet</p>
<pre><code class="language-java">,public class Logout extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
     req.getSession().setAttribute(Constants.USER_SESSION,null);
        resp.sendRedirect(&quot;/&quot;);
    &#125;,
&#125;
</code></pre>
<p>通过设置Session的Attribute(Constants.USER_SESSION)值为空来实现用户的登录, 这种方式不需要服务器重复创建和销毁Session就可以实现用户的注销, 减轻了服务器负担.</p>
<img src="Java-Web-快速入门/Kapture 2023-05-13 at 11.38.21-3950252.gif" alt="Kapture 2023-05-13 at 11.38.21" style="zoom:80%;" / loading="lazy">
</li>
</ul>
<h2 id="JDBC">JDBC</h2>
<ul>
<li>什么是JDBC ： Java连接数据库！</li>
<li>需要jar包的支持：
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-connecter-java… 连接驱动（必须要导入）</li>
</ul>
</li>
</ul>
<ol>
<li><s>加载驱动</s></li>
<li>连接数据库,代表数据库</li>
<li>编写SQL （根据业务，不同的SQL）</li>
<li>预编译</li>
<li>执行SQL</li>
<li>关闭连接</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;
    // 配置信息
    // useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
    String url=&quot;jdbc:mysql://localhost:3307/JDBC?useUnicode=true&amp;characterEncoding=utf-8&quot;;
    String username = &quot;root&quot;;
    String password = &quot;&quot;;
    // 2.连接数据库,代表数据库
    Connection connection = DriverManager.getConnection(url, username, password);
    // 3.编写SQL
    String sql = &quot;select * from user&quot;;
//     4. 预编译
    PreparedStatement preparedStatement = connection.prepareStatement(sql);
    // 5.执行查询SQL，返回一个 ResultSet  ： 结果集
    ResultSet rs = preparedStatement.executeQuery(sql);
    while (rs.next()) &#123;
        System.out.println(rs.getObject(&quot;name&quot;));
        System.out.println(rs.getObject(&quot;email&quot;));
        System.out.println(rs.getObject(&quot;password&quot;));
        System.out.println(rs.getObject(&quot;role&quot;));
    &#125;
    // 6.关闭连接，释放资源（一定要做） 先开后关
    rs.close();
    preparedStatement.close();
    connection.close();
&#125;
</code></pre>
<h4 id="预编译-使用占位符">预编译: 使用占位符</h4>
<p>在 JDBC 中，预编译 SQL 的主要目的是<strong>提高执行 SQL 语句的效率</strong>。当一个 SQL 语句被预编译后，JDBC 驱动程序会将该语句存储在数据库中，并将其与一个预定义的执行计划关联起来。这样，在执行该 SQL 语句时，JDBC 驱动程序可以直接使用预定义的执行计划，而<strong>不必重新解析 SQL 语句和生成执行计划</strong>，从而提高了执行效率。</p>
<p>另外，预编译 SQL 还可以提高代码的<strong>可维护性</strong>和<strong>安全性</strong>。通过使用预编译 SQL，我们可以将 SQL 语句与 Java 代码分离开来，使得代码更易于维护。此外，预编译 SQL 可以避免 <strong>SQL 注入</strong>等安全问题。</p>
<p>具体地，预编译 SQL 的过程包括两个步骤：首先，使用 <code>Connection</code> 接口中的 <code>prepareStatement()</code> 方法创建一个 <code>PreparedStatement</code> 对象；然后，使用 <code>PreparedStatement</code> 对象的 <code>setXXX()</code> 方法设置 SQL 语句中的参数，并使用 <code>execute()</code> 或 <code>executeUpdate()</code> 方法执行 SQL 语句。</p>
<p>以下是一个使用预编译 SQL 的示例代码：</p>
<pre><code>String sql = &quot;SELECT * FROM users WHERE name = ?&quot;;
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, &quot;John&quot;);
ResultSet rs = pstmt.executeQuery();
while (rs.next()) &#123;
    // process the result set
&#125;
</code></pre>
<p>在上述示例代码中，我们首先使用 <code>prepareStatement()</code> 方法创建了一个 <code>PreparedStatement</code> 对象，然后使用 <code>setString()</code> 方法设置了 SQL 语句中的参数，并最终使用 <code>executeQuery()</code> 方法执行 SQL 语句。这样，在执行 SQL 语句时，JDBC 驱动程序会使用预定义的执行计划，从而提高了执行效率。</p>
<h4 id="SQL注入">SQL注入</h4>
<p>SQL 注入（SQL Injection）是一种常见的网络安全漏洞，它允许攻击者在执行 SQL 查询时向查询中插入恶意代码，从而获得对数据库的非授权访问。攻击者可以通过构造特定的 SQL 查询语句，从而绕过身份验证、窃取数据或破坏数据库。</p>
<p>例如，考虑下面的 SQL 查询语句：</p>
<pre><code>SELECT * FROM users WHERE username = '&lt;input&gt;';
</code></pre>
<p>如果用户输入 <code>&lt;input&gt;</code> 的值为 <code>' or '1'='1</code>，那么最终的 SQL 查询语句就会变成：</p>
<pre><code>SELECT * FROM users WHERE username = '' or '1'='1';
</code></pre>
<p>这样就会返回所有用户的记录，而不仅仅是指定的用户名。攻击者可以通过这种方式获取到数据库中的敏感数据或者执行其他恶意操作。</p>
<h2 id="实战-超市订单管理系统">实战: 超市订单管理系统</h2>
<p>为了方便表述和理解, 在编写MVC三层对应的代码时, 使用自顶向下, 但在实际的项目中, 编写代码工作往往是自底向上的.</p>
<h3 id="搭建项目框架">搭建项目框架</h3>
<h4 id="编写数据库操作的基础公共类DB">编写数据库操作的基础公共类DB</h4>
<ul>
<li>
<p>数据库配置文件，这是一个资源文件，应该创建在maven项目的resources文件中</p>
<pre><code class="language-properties">DRIVER=com.mysql.jdbc.Driver
URL=jdbc:mysql://localhost:3307/smbms?useUnicode=true&amp;characterEncoding=utf-8
USERNAME=root
PASSWORD=
</code></pre>
</li>
<li>
<p>使用静态代码块实现初始化参数</p>
<p>该类为数据库访问工具类，提供了获取数据库连接、执行查询和更新等常用操作的方法。</p>
<ol>
<li>
<p>类名：DB</p>
</li>
<li>
<p>属性：</p>
</li>
</ol>
<ul>
<li>DRIVER：String类型，表示数据库驱动名。</li>
<li>URL：String类型，表示数据库连接地址。</li>
<li>USERNAME：String类型，表示连接数据库的用户名。</li>
<li>PASSWORD：String类型，表示连接数据库的密码。</li>
</ul>
<ol start="3">
<li>方法：</li>
</ol>
<ul>
<li>close：用于释放数据库连接、预处理语句和结果集资源。</li>
<li>getConnection：用于获取数据库连接。</li>
<li>executeQuery：用于执行查询操作，返回一个结果集。</li>
<li>executeUpdate：用于执行更新操作，返回受影响的行数。</li>
</ul>
<ol start="4">
<li>方法的参数：</li>
</ol>
<ul>
<li>conn：Connection类型，表示数据库连接。</li>
<li>pstmt：PreparedStatement类型，表示预处理语句。</li>
<li>resSet：ResultSet类型，表示结果集。</li>
<li>query：String类型，表示要执行的SQL语句。</li>
<li>params：Object[]类型，表示SQL语句中的参数值。</li>
</ul>
<p>在类中还定义了一个静态代码块，该代码块在类加载时会被执行。静态代码块中的主要作用是读取配置文件中的数据库连接参数，并将其赋值给类的静态属性。具体实现如下：</p>
<ul>
<li>创建Properties对象。</li>
<li>通过类加载器加载配置文件为字节输入流。</li>
<li>使用Properties对象的load()方法加载字节输入流中的内容。</li>
<li>从Properties对象中获取数据库连接参数，并将其赋值给类的静态属性。</li>
</ul>
<p>通过这种方式，可以在不修改Java代码的情况下，更改数据库连接参数，提高了代码的灵活性和可维护性。</p>
<pre><code class="language-java">public class DB &#123;
    private static String DRIVER;
    private static String URL;
    private static String USERNAME;
    private static String PASSWORD;
    //静态代码块， 类加载的时候执行
    static &#123;
        //读取配置文件
        //1、创建properties对象
        Properties properties = new Properties();
        //2、通过类加载器加载资源文件为字节输入流
        InputStream in = DB.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);
        try &#123;
            properties.load(in);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        DRIVER = properties.getProperty(&quot;DRIVER&quot;);
        URL = properties.getProperty(&quot;URL&quot;);
        USERNAME = properties.getProperty(&quot;USERNAME&quot;);
        PASSWORD = properties.getProperty(&quot;PASSWORD&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>编写数据库操作的公共方法</p>
<p>该类为数据库访问工具类，提供了获取数据库连接、执行查询和更新等常用操作的方法。</p>
<ol>
<li>
<p>类名：DB</p>
</li>
<li>
<p>属性：</p>
</li>
</ol>
<ul>
<li>DRIVER：String类型，表示数据库驱动名。</li>
<li>URL：String类型，表示数据库连接地址。</li>
<li>USERNAME：String类型，表示连接数据库的用户名。</li>
<li>PASSWORD：String类型，表示连接数据库的密码。</li>
</ul>
<ol start="3">
<li>方法：</li>
</ol>
<ul>
<li>close：用于释放数据库连接、预处理语句和结果集资源。</li>
<li>getConnection：用于获取数据库连接。</li>
<li>executeQuery：用于执行查询操作，返回一个结果集。</li>
<li>executeUpdate：用于执行更新操作，返回受影响的行数。</li>
</ul>
<ol start="4">
<li>方法的参数：</li>
</ol>
<ul>
<li>conn：Connection类型，表示数据库连接。</li>
<li>pstmt：PreparedStatement类型，表示预处理语句。</li>
<li>resSet：ResultSet类型，表示结果集。</li>
<li>query：String类型，表示要执行的SQL语句。</li>
<li>params：Object[]类型，表示SQL语句中的参数值。</li>
</ul>
<p>该类还包含一个静态代码块，用于初始化数据库连接参数，但代码块的内容未给出，需要进行补充。</p>
<p><em>同时需要注意，该类并没有实现单例模式，每次获取数据库连接都会重新创建一个新的连接，这可能会导致性能问题。</em></p>
</li>
</ul>
<pre><code class="language-java">public class DB &#123;
    private static String DRIVER;
    private static String URL;
    private static String USERNAME;
    private static String PASSWORD;
  
   //插入静态代码块(need to fininsh)
  
    //释放链接资源
    public static void close(Connection conn, PreparedStatement pstmt, ResultSet resSet) throws SQLException &#123;
        if(resSet != null)&#123;
            resSet.close();
        &#125;
        if(pstmt != null)&#123;
            pstmt.close();
        &#125;
        if(conn != null) &#123;
            conn.close();
        &#125;
    &#125;
    //获取数据库链接
    public static Connection getConnection() throws SQLException, ClassNotFoundException &#123;
        Class.forName(DRIVER);
        String url = URL;
        String username = USERNAME;
        String password = PASSWORD;
        // 2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);
        return  connection;
    &#125;
    //执行查询, 返回结果集
    public static ResultSet executeQuery(Connection conn,String query,Object[] params) throws SQLException, ClassNotFoundException&#123;
        ResultSet resultSet = null;
        if(conn != null &amp;&amp; !query.isEmpty() &amp;&amp; params != null)&#123;
            //预处理
            PreparedStatement statement = conn.prepareStatement(query);
            for (int i = 0; i &lt; params.length;i++)&#123;
                //设置SQL 语句中的参数
                statement.setString(i+1,params[i].toString());
            &#125;
            //执行
            resultSet = statement.executeQuery();
        &#125;
        return resultSet;
    &#125;
    //执行更新， 返回影响行数
    public static int executeUpdate(Connection conn,String query,Object[] params) throws SQLException &#123;
        int affectedRows = 0;
        if(conn != null &amp;&amp; !query.isEmpty() &amp;&amp; params != null)&#123;
            //预处理
            PreparedStatement statement = conn.prepareStatement(query);
            for (int i = 0; i &lt; params.length;i++)&#123;
                //设置SQL 语句中的参数
                statement.setString(i+1,params[i].toString());
            &#125;
            //执行
             affectedRows = statement.executeUpdate();
        &#125;
        return affectedRows;
    &#125;
&#125;
</code></pre>
<h3 id="登录功能实现">登录功能实现</h3>
<h4 id="前端页面编写">前端页面编写</h4>
<p>前端页面由kuang提供</p>
<pre><code class="language-jsp">&lt;%-- header--%&gt;
&lt;form class=&quot;loginForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot; name=&quot;actionForm&quot; id=&quot;actionForm&quot; method=&quot;post&quot;&gt;
  &lt;div class=&quot;info&quot;&gt;$&#123;error&#125;&lt;/div&gt;
  &lt;div class=&quot;inputbox&quot;&gt;
      &lt;label&gt;用户名：&lt;/label&gt;
      &lt;input type=&quot;text&quot; class=&quot;input-text&quot; id=&quot;userCode&quot; name=&quot;userCode&quot; placeholder=&quot;请输入用户名&quot; required/&gt;
  &lt;/div&gt;
  &lt;div class=&quot;inputbox&quot;&gt;
      &lt;label&gt;密码：&lt;/label&gt;
      &lt;input type=&quot;password&quot; id=&quot;userPassword&quot; name=&quot;userPassword&quot; placeholder=&quot;请输入密码&quot; required/&gt;
  &lt;/div&gt;
  &lt;div class=&quot;subBtn&quot;&gt;
      &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
      &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt;
  &lt;/div&gt;
&lt;/form&gt;
&lt;%-- footer--%&gt;
</code></pre>
<h4 id="登录处理Servlet实现">登录处理Servlet实现</h4>
<p>在前端form表单的action属性值我们可以看到提交的URL, 所以, 我们需要编写对应的Servlet来处理这个请求</p>
<pre><code class="language-jsp">action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot;
</code></pre>
<ul>
<li>
<p>创建登录处理Servlet</p>
<p>以下是一个名为“Login”的Java servlet类，用于处理HTTP GET请求。该类包括对“UserService”实例的引用，该实例用于从数据库中检索用户信息。</p>
<p>在“doGet”方法中，servlet从HTTP请求中检索userCode和password参数。然后它创建一个“UserServiceImpl”类的新实例（该类实现了“UserService”接口），并调用其“findByUserCode”方法，以根据给定的用户代码从数据库中检索用户对象。</p>
<p>如果用户对象不为null，则servlet检查用户密码是否与给定密码匹配。如果匹配，则servlet使用用户对象设置名为“USER_SESSION”的会话属性，并将用户重定向到“/jsp/frame.jsp”。如果密码不匹配，则servlet使用错误消息设置名为“error”的会话属性，并将用户重定向回“/login.jsp”。</p>
<p><em>请注意，此代码片段不完整，因为它缺少有关导入，它所依赖的接口和类，以及servlet配置的信息。</em></p>
<pre><code class="language-java">public class Login extends HttpServlet &#123;
    private UserService service;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String userCode = req.getParameter(&quot;userCode&quot;);
        String password = req.getParameter(&quot;userPassword&quot;);
        service = new UserServiceImpl();
        User user = null;
        user = service.findByUserCode(userCode);
        if(user != null) &#123;
            if(user.getUserPassword().equals(password)) &#123;
                req.getSession().setAttribute(Constant.USER_SESSION,user);
                resp.sendRedirect(&quot;/jsp/frame.jsp&quot;);
            &#125; else &#123;
                req.getSession().setAttribute(&quot;error&quot;,&quot;username or password incorrect&quot;);
                resp.sendRedirect(&quot;/login.jsp&quot;);
            &#125;
        &#125;
    &#125;
</code></pre>
</li>
<li>
<p>映射 servlet</p>
<p>这段代码是一个 servlet 配置的 XML 部分，它用于将请求的 URL 映射到特定的 servlet 上。这段配置指定了一个名为 “Login” 的 servlet，使用了完整的类名 <code>servlet.Login</code>，并将它映射到 URL “/login.do” 上。</p>
<p>这意味着，当用户在浏览器中访问 “/login.do” 时，容器将调用 <code>servlet.Login</code> 的 service() 方法来处理该请求。映射 servlet 的操作是 web 应用的一部分，它在 web.xml 文件中进行配置。</p>
<pre><code class="language-xml">&lt;servlet&gt;
  &lt;servlet-name&gt;Login&lt;/servlet-name&gt;
  &lt;servlet-class&gt;servlet.Login&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;Login&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>编写Service层代码</p>
<p>该代码是一个 Java 类 <code>UserServiceImpl</code>，实现了一个接口 <code>UserService</code>。该类包含了两个方法：</p>
<ol>
<li><code>findByUserCode(String userCode)</code>：查找数据库中对应用户的信息，该方法返回一个 <code>User</code> 对象。</li>
<li><code>updateUser(Integer id, String key, String value)</code>：更新数据库中用户的信息，该方法返回一个 <code>boolean</code> 类型的值，表示更新是否成功。</li>
</ol>
<p>在这个类中，私有成员变量 <code>dao</code> 是一个 <code>UserDao</code> 类型的变量，通过该变量调用 <code>UserDaoImpl</code> 类中的方法来访问数据库。在 <code>findByUserCode</code> 和 <code>updateUser</code> 方法中，都需要先通过 <code>dao</code> 实例化一个 <code>UserDaoImpl</code> 对象来调用相应的方法。</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService &#123;
    private UserDao dao;
    @Override
    public User findByUserCode(String userCode)&#123;
        dao = new UserDaoImpl();
        User user = dao.findByUserCode(userCode);
        return  user;
    &#125;
    @Override
    public boolean updateUser(Integer id, String key, String value)  &#123;
        dao = new UserDaoImpl();
        int i = 0;
        i = dao.updateUser(id, key, value);
       return i &gt; 0 ? true : false;
    &#125;
&#125;

</code></pre>
</li>
<li>
<p>DAO层代码</p>
<p>这段代码是一个Dao层的实现类，用于和数据库交互，提供了对User表的查询和更新方法。下面是代码的分析：</p>
<ul>
<li><code>findByUserCode(String userCode)</code> 方法：根据传入的用户名参数 <code>userCode</code> 查询对应的用户记录，并返回一个User对象。该方法使用了数据库连接池技术，在执行完查询后会关闭连接。方法中首先初始化参数，然后执行SQL语句查询结果集，遍历结果集将数据封装到User对象中，最后关闭连接和结果集，返回User对象。</li>
<li><code>updateUser(Integer id, String key,String value)</code> 方法：根据传入的参数更新User表中的数据。该方法也使用了数据库连接池技术，在执行完更新后会关闭连接。方法中首先判断传入的参数是否为空，然后执行SQL语句更新数据，最后关闭连接，返回更新结果的影响行数。</li>
</ul>
<pre><code class="language-java">public class UserDaoImpl implements UserDao&#123;
    private User user;
    private Connection conn;
    private String sql;
    @Override
    public User findByUserCode(String userCode)&#123;
        //2. 初始化参数
        Object[] params = &#123;userCode&#125;;
        ResultSet set;
        sql = &quot;SELECT * FROM smbms_user Where userCode = ?&quot;;
        try &#123;
            conn = DB.getConnection();
            set = DB.executeQuery(conn, sql,params);
            if(set != null)&#123;
                user = new User();
                while (set.next()) &#123;
                    user.setUserPassword(set.getString(&quot;userPassword&quot;));
                    //一大串赋值代码...
                    user.setWorkPicPath(&quot;workPicPath&quot;);
                &#125;
            &#125; else &#123;
                return null;
            &#125;
            //关闭链接和结果集
            DB.close(conn,null,set);
        &#125; catch (SQLException e) &#123;
            throw new RuntimeException(e);
        &#125; catch (ClassNotFoundException e) &#123;
            throw new RuntimeException(e);
        &#125;
        return user;
    &#125;
    @Override
    public int updateUser(Integer id, String key,String value) &#123;
        int affectedRow = 0;
        if(id != null&amp;&amp; value != null &amp;&amp; key != null)&#123;
            Connection conn = null;
            sql = &quot;UPDATE smbms_user SET &quot;+key+&quot; = ? WHERE id = ? &quot;;
            Object[] params = &#123;value,id&#125;;
            try &#123;
                conn = DB.getConnection();
                affectedRow = DB.executeUpdate(conn, sql, params);
                DB.close(conn,null,null);
            &#125; catch (SQLException e) &#123;
                throw new RuntimeException(e);
            &#125; catch (ClassNotFoundException e) &#123;
                throw new RuntimeException(e);
            &#125;
        &#125;
        return affectedRow;
    &#125;
</code></pre>
</li>
</ul>
<h3 id="密码修改实现">密码修改实现</h3>
<h4 id="前端页面">前端页面</h4>
<p><strong>JSP部分: 页面显示</strong></p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@include file=&quot;/jsp/common/head.jsp&quot; %&gt;
&lt;div class=&quot;right&quot;&gt;
    &lt;div class=&quot;location&quot;&gt;
        &lt;strong&gt;你现在所在的位置是:&lt;/strong&gt;
        &lt;span&gt;密码修改页面&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;providerAdd&quot;&gt;
        &lt;form id=&quot;userForm&quot; name=&quot;userForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do&quot;&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;savepwd&quot;/&gt;
            &lt;!--div的class 为error是验证错误，ok是验证成功--&gt;
            &lt;div class=&quot;info&quot;&gt;$&#123;message&#125;&lt;/div&gt;
            &lt;div class=&quot;&quot;&gt;
                &lt;label for=&quot;oldPassword&quot;&gt;旧密码：&lt;/label&gt;
                &lt;input type=&quot;password&quot; name=&quot;oldpassword&quot; id=&quot;oldpassword&quot; value=&quot;&quot;&gt;
                &lt;font color=&quot;red&quot;&gt;&lt;/font&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;label for=&quot;newPassword&quot;&gt;新密码：&lt;/label&gt;
                &lt;input type=&quot;password&quot; name=&quot;newpassword&quot; id=&quot;newpassword&quot; value=&quot;&quot;&gt;
                &lt;font color=&quot;red&quot;&gt;&lt;/font&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;label for=&quot;newPassword&quot;&gt;确认新密码：&lt;/label&gt;
                &lt;input type=&quot;password&quot; name=&quot;rnewpassword&quot; id=&quot;rnewpassword&quot; value=&quot;&quot;&gt;
                &lt;font color=&quot;red&quot;&gt;&lt;/font&gt;
            &lt;/div&gt;
            &lt;div class=&quot;providerAddBtn&quot;&gt;
                &lt;!--&lt;a href=&quot;#&quot;&gt;保存&lt;/a&gt;--&gt;
                &lt;input type=&quot;button&quot; name=&quot;save&quot; id=&quot;save&quot; value=&quot;保存&quot; class=&quot;input-button&quot;&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;%@include file=&quot;/jsp/common/foot.jsp&quot; %&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/js/pwdmodify.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>这是一个用 JSP（JavaServer Pages）编写的网页代码，用于修改密码。页面包括一个表单，用户可以在其中输入旧密码、新密码和确认新密码。表单使用POST方法提交到服务器，并使用“/jsp/user.do” URL。</p>
<p>页面包括一个消息区域，用于显示任何错误消息。页面还包括指向名为“pwdmodify.js”的 JavaScript 文件的链接。这个文件应该包含表单的客户端验证逻辑。</p>
<p>页面使用 JSP 表达式语言（EL）将动态内容插入到 HTML 中。例如，页面使用表达式 “${pageContext.request.contextPath}/statics/js/pwdmodify.js” 插入一个链接到 CSS 文件。“${pageContext.request.contextPath}” 表达式计算为 web 应用程序的上下文路径，用于构造 CSS 文件的完整 URL。</p>
<p><strong>JavaScript 表单的客户端验证逻辑</strong></p>
<pre><code class="language-js">var oldpassword = null;
var newpassword = null;
var rnewpassword = null;
var saveBtn = null;

$(function()&#123;
   oldpassword = $(&quot;#oldpassword&quot;);
   newpassword = $(&quot;#newpassword&quot;);
   rnewpassword = $(&quot;#rnewpassword&quot;);
   saveBtn = $(&quot;#save&quot;);

   oldpassword.next().html(&quot;*&quot;);
   newpassword.next().html(&quot;*&quot;);
   rnewpassword.next().html(&quot;*&quot;);

   oldpassword.on(&quot;blur&quot;,function()&#123;
      $.ajax(&#123;
         type:&quot;GET&quot;,
         url:path+&quot;/jsp/user.do&quot;,
         data:&#123;method:&quot;pwdmodify&quot;,oldpassword:oldpassword.val()&#125;,
         dataType:&quot;json&quot;,
         success:function(data)&#123;
            if(data.result == &quot;true&quot;)&#123;//旧密码正确
               validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true);
            &#125;else if(data.result == &quot;false&quot;)&#123;//旧密码输入不正确
               validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 原密码输入不正确&quot;,false);
            &#125;else if(data.result == &quot;sessionerror&quot;)&#123;//当前用户session过期，请重新登录
               validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 当前用户session过期，请重新登录&quot;,false);
            &#125;else if(data.result == &quot;error&quot;)&#123;//旧密码输入为空
               validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 请输入旧密码&quot;,false);
            &#125;
         &#125;,
         error:function(data)&#123;
            //请求出错
            validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 请求错误&quot;,false);
         &#125;
      &#125;);


   &#125;).on(&quot;focus&quot;,function()&#123;
      validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入原密码&quot;,false);
   &#125;);

   newpassword.on(&quot;focus&quot;,function()&#123;
      validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 密码长度必须是大于6小于20&quot;,false);
   &#125;).on(&quot;blur&quot;,function()&#123;
      if(newpassword.val() != null &amp;&amp; newpassword.val().length &gt; 5
         &amp;&amp; newpassword.val().length &lt; 20 )&#123;
         validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true);
      &#125;else&#123;
         validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 密码输入不符合规范，请重新输入&quot;,false);
      &#125;
   &#125;);


   rnewpassword.on(&quot;focus&quot;,function()&#123;
      validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入与上面一致的密码&quot;,false);
   &#125;).on(&quot;blur&quot;,function()&#123;
      if(rnewpassword.val() != null &amp;&amp; rnewpassword.val().length &gt; 5
         &amp;&amp; rnewpassword.val().length &lt; 20 &amp;&amp; newpassword.val() == rnewpassword.val())&#123;
         validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true);
      &#125;else&#123;
         validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 两次密码输入不一致，请重新输入&quot;,false);
      &#125;
   &#125;);


   saveBtn.on(&quot;click&quot;,function()&#123;
      oldpassword.blur();
      newpassword.blur();
      rnewpassword.blur();
      if(
         oldpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp;
          newpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot;
         &amp;&amp; rnewpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot;)&#123;
         if(confirm(&quot;确定要修改密码？&quot;))&#123;
            $(&quot;#userForm&quot;).submit();
         &#125;
      &#125;

   &#125;);
&#125;);
</code></pre>
<p>这是一个 JavaScript 代码段，它使用 jQuery 库为一个包含密码修改表单的网页添加了客户端验证逻辑。代码使用 AJAX 技术从服务器获取 JSON 格式的响应数据，以验证用户输入的旧密码是否正确，并在页面上显示相关提示信息。</p>
<p>代码中首先定义了四个变量，分别是旧密码、新密码、确认新密码和提交按钮的 jQuery 对象。然后使用 $() 函数将代码包装在一个回调函数中，确保代码在文档加载完成后才执行。回调函数内部做了以下工作：</p>
<ol>
<li>
<p>通过选择器获取页面上的旧密码输入框、新密码输入框、确认新密码输入框和提交按钮，并将它们的 jQuery 对象赋值给前面定义的四个变量。</p>
</li>
<li>
<p>为旧密码输入框绑定 blur 事件处理函数，当输入框失去焦点时，使用 $.ajax() 函数向服务器发送 GET 请求，验证用户输入的旧密码是否正确，并根据服务器返回的响应数据显示相应的提示信息。在成功回调函数中，根据 data.result 的值判断旧密码是否正确，并通过 validateTip() 函数显示相应的提示信息。在失败回调函数中，显示请求出错的提示信息。</p>
</li>
<li>
<p>为旧密码输入框绑定 focus 事件处理函数，当输入框获得焦点时，显示输入提示信息。</p>
</li>
<li>
<p>为新密码输入框绑定 focus 和 blur 事件处理函数，当输入框获得焦点时，显示输入提示信息；当输入框失去焦点时，判断用户输入的新密码是否符合规范，如果符合则显示正确提示，否则显示错误提示。</p>
</li>
<li>
<p>为确认新密码输入框绑定 focus 和 blur 事件处理函数，当输入框获得焦点时，显示输入提示信息；当输入框失去焦点时，判断用户输入的确认新密码是否与新密码一致，如果一致则显示正确提示，否则显示错误提示。</p>
</li>
<li>
<p>为提交按钮绑定 click 事件处理函数，当按钮被点击时，先让旧密码、新密码和确认新密码输入框失去焦点，然后判断它们的验证状态是否都为 true，如果是，则显示确认修改密码的提示框，如果用户点击确定，则提交表单，将新密码保存到服务器上。</p>
</li>
</ol>
<h4 id="编写处理Servlet">编写处理Servlet</h4>
<pre><code class="language-java">public class UserDo extends HttpServlet &#123;
    private UserService service;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        String method = req.getParameter(&quot;method&quot;);
        if(&quot;savepwd&quot;.equals(method))&#123;
            savePwd(req, resp);
        &#125; else if(&quot;pwdmodify&quot;.equals(method))&#123;
            pwdModify(req, resp);
        &#125;
    &#125;
    protected void savePwd(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //拿到USer Session , 用于得到用户id
        HttpSession session = req.getSession();
        User user = (User) session.getAttribute(Constant.USER_SESSION);
        String newPwd = req.getParameter(&quot;newpassword&quot;);
        System.out.println(&quot;用户输入的：new password: &quot;+newPwd);
        System.out.println(&quot;Session password: &quot;+user.getUserPassword()+&quot;, id: &quot;+ user.getId());
        Integer id = user.getId();
        boolean flag;
        //method 值为  savepwd, 表示用户执行修改密码操作
        if(newPwd != null)&#123;
            service = new UserServiceImpl();
            flag = service.updateUser(id, &quot;userPassword&quot;, newPwd);
            //修改成功
            if(flag)&#123;
                System.out.println(&quot;修改成功&quot;);
                req.setAttribute(&quot;message&quot;,&quot;密码修改成功， 请重新登录&quot;);
                //  移除Session
                session.removeAttribute(Constant.USER_SESSION);
            &#125; else &#123;
                System.out.println(&quot;密码修改失败&quot;);
                req.setAttribute(&quot;message&quot;,&quot;密码修改失败&quot;);
            &#125;
        &#125; else &#123;
            req.setAttribute(&quot;message&quot;,&quot;新密码格式错误&quot;);
        &#125;
        //转发到当前页面, 不用重定向而使用转发是为了传统参数（attribute) 通知前端密码修改结果（by attribute message）
        req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req,resp);
    &#125;
    /*
    由ajax发起的密码查询请求， 用户进行密码修改时触发
    放回前端json， ajax用于比对旧密码正确性,
     */
    protected void pwdModify(HttpServletRequest req, HttpServletResponse resp)&#123;
        HttpSession session = req.getSession();
        Object user = session.getAttribute(Constant.USER_SESSION);
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
        if(user != null)&#123;
            String password = ((User) user).getUserPassword();
            String inputPwd = req.getParameter(&quot;oldpassword&quot;);
            if(inputPwd != null &amp;&amp; inputPwd.length() &gt; 0)&#123;
                //旧密码正确
                if(inputPwd.equals(password))&#123;
                    map.put(&quot;result&quot;,&quot;true&quot;);
                &#125; else &#123;
                    //旧密码不正确
                    map.put(&quot;result&quot;,&quot;false&quot;);
                &#125;
            &#125; else &#123;
                //密码输入为空
                map.put(&quot;result&quot;,&quot;error&quot;);
            &#125;
        &#125; else &#123;
            //session timeout
            map.put(&quot;result&quot;,&quot;sessionerror&quot;);
        &#125;
        //返回前端json数据
        resp.setContentType(&quot;application/json&quot;);
        try &#123;
            PrintWriter writer = resp.getWriter();
            writer.write(JSONArray.toJSONString(map));
            writer.flush();
            writer.close();
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;
</code></pre>
<p>这段代码是一个Java Web应用程序中的Servlet，用于处理用户密码修改操作。</p>
<p>在doGet()方法中，根据请求参数&quot;method&quot;的值进行不同的操作。如果&quot;method&quot;的值是&quot;savepwd&quot;，则调用savePwd()方法，保存新密码；如果&quot;method&quot;的值是&quot;pwdmodify&quot;，则调用pwdModify()方法，用于检查旧密码是否正确。</p>
<p>在savePwd()方法中，首先从Session中获取当前用户的信息，然后获取新密码，并使用UserService接口的实现类UserServiceImpl来更新用户密码。如果更新成功，将信息存储在请求属性中，并移除Session中的用户信息，最后将请求转发到密码修改页面。</p>
<p>在pwdModify()方法中，首先获取当前用户的信息，然后获取旧密码。如果旧密码不为空，则将输入的旧密码与Session中存储的旧密码进行比较。如果输入的旧密码与Session中的旧密码相同，则返回前端JSON数据，表示旧密码正确；否则返回JSON数据，表示旧密码不正确。</p>
<p><strong>需要注意的是，在返回JSON数据之前，需要设置响应的Content-Type为&quot;application/json&quot;。</strong></p>
<h5 id="映射Servlet">映射Servlet</h5>
<pre><code class="language-xml">  &lt;servlet&gt;
    &lt;servlet-name&gt;userDo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;servlet.UserDo&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;userDo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/jsp/user.do&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>楼兰</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Java Web 快速入门">https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2023/05/15/%E8%B6%85%E5%B8%82%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" rel="prev" title="超市管理系统"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">超市管理系统</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2023/05/11/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/" rel="next" title="大学生就业指导课程心得体会"><span class="post-nav-text">大学生就业指导课程心得体会</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 楼兰</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.3.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.9</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>