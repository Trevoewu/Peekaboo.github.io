<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楼兰</title>
  
  
  <link href="https://trevoewu.github.io/atom.xml" rel="self"/>
  
  <link href="https://trevoewu.github.io/"/>
  <updated>2023-04-21T12:37:22.477Z</updated>
  <id>https://trevoewu.github.io/</id>
  
  <author>
    <name>楼兰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MAC M1 安装Oracle数据库教程</title>
    <link href="https://trevoewu.github.io/2023/04/21/MAC-M1-%E5%AE%89%E8%A3%85Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/"/>
    <id>https://trevoewu.github.io/2023/04/21/MAC-M1-%E5%AE%89%E8%A3%85Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/</id>
    <published>2023-04-21T12:35:34.000Z</published>
    <updated>2023-04-21T12:37:22.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC-M1-安装Oracle数据库教程"><a href="#MAC-M1-安装Oracle数据库教程" class="headerlink" title="MAC M1 安装Oracle数据库教程"></a>MAC M1 安装Oracle数据库教程</h1><p><strong>oracle目前还没有支持M1的版本, 本教程使用SSH来远程登录oracle服务器</strong></p><ol><li>在开始之前, 请确保你的mac安装了parallels Desktop, 并安装windows系统</li><li>如果你身边有windows环境, 比如你的室友的电脑, 你可以跳过1.</li><li>在windows电脑中安装Oracle Database Software.</li></ol><h2 id="安装OpenSSH服务"><a href="#安装OpenSSH服务" class="headerlink" title="安装OpenSSH服务"></a>安装OpenSSH服务</h2><p>在window设置中</p><p><em>适用于 Windows Server 2019、Windows 10,11、Windows Server 2022</em></p><p>OpenSSH 是一款用于远程登录的连接工具，它使用 SSH 协议。 它会加密客户端与服务器之间的所有流量，从而遏止窃听、连接劫持和其他攻击。</p><p>OpenSSH 可用于将安装了 OpenSSH 客户端的 Window 10（版本 1809 及更高版本）或 Windows Server 2019 设备连接到那些安装了 OpenSSH 服务器的设备。</p><h3 id="使用windous设置安装OpenSSSH"><a href="#使用windous设置安装OpenSSSH" class="headerlink" title="使用windous设置安装OpenSSSH"></a>使用windous设置安装OpenSSSH</h3><p>可以使用 Windows Server 2019 和 Windows 10 设备上的 Windows 设置安装这两个 OpenSSH 组件。</p><p>若要安装 OpenSSH 组件：</p><ol><li>打开“设置”，选择“应用”&gt;“应用和功能”，然后选择“可选功能” 。</li><li>扫描列表，查看是否已安装 OpenSSH。 如果未安装，请在页面顶部选择“添加功能”，然后：<ul><li>查找“OpenSSH 客户端”，再单击“安装”</li><li>查找“OpenSSH 服务器”，再单击“安装”</li></ul></li></ol><p>设置完成后，回到“应用”&gt;“应用和功能”和“可选功能”，你应会看到已列出 OpenSSH 。</p><p><em>安装 OpenSSH 服务器将创建并启用一个名为 <code>OpenSSH-Server-In-TCP</code> 的防火墙规则。 这允许端口 22 上的入站 SSH 流量。 如果未启用此规则且未打开此端口，那么连接将被拒绝或重置。</em></p><h3 id="使用PowerShell安装OpenSSH"><a href="#使用PowerShell安装OpenSSH" class="headerlink" title="使用PowerShell安装OpenSSH"></a>使用PowerShell安装OpenSSH</h3><p>若要使用 PowerShell 安装 OpenSSH，请先以管理员身份运行 PowerShell。 为了确保 OpenSSH 可用，请运行以下 cmdlet：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Get-WindowsCapability -Online | Where-Object Name -like &#39;OpenSSH*&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果两者均尚未安装，则此操作应返回以下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Name  : OpenSSH.Client~~~~0.0.1.0State : NotPresentName  : OpenSSH.Server~~~~0.0.1.0State : NotPresent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，根据需要安装服务器或客户端组件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Install the OpenSSH ClientAdd-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# Install the OpenSSH ServerAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两者应该都会返回以下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Path          :Online        : TrueRestartNeeded : False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="启动并配置-OpenSSH-服务器"><a href="#启动并配置-OpenSSH-服务器" class="headerlink" title="启动并配置 OpenSSH 服务器"></a>启动并配置 OpenSSH 服务器</h2><p>若要启动并配置 OpenSSH 服务器来开启使用，请以管理员身份打开 PowerShell，然后运行以下命令来启动 <code>sshd service</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Start the sshd serviceStart-Service sshd# OPTIONAL but recommended:Set-Service -Name sshd -StartupType &#39;Automatic&#39;# Confirm the Firewall rule is configured. It should be created automatically by setup. Run the following to verifyif (!(Get-NetFirewallRule -Name &quot;OpenSSH-Server-In-TCP&quot; -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) &#123;    Write-Output &quot;Firewall Rule &#39;OpenSSH-Server-In-TCP&#39; does not exist, creating it...&quot;    New-NetFirewallRule -Name &#39;OpenSSH-Server-In-TCP&#39; -DisplayName &#39;OpenSSH Server (sshd)&#39; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22&#125; else &#123;    Write-Output &quot;Firewall rule &#39;OpenSSH-Server-In-TCP&#39; has been created and exists.&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接到-OpenSSH-服务器"><a href="#连接到-OpenSSH-服务器" class="headerlink" title="连接到 OpenSSH 服务器"></a>连接到 OpenSSH 服务器</h2><p>mac自带SSH服务, 所以安装后，可以使用MAC连接到 OpenSSH 服务器, 在终端中运行一下命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh username@ipadress #username是安装了Oracle的windows电脑的用户名#ipaddress是该电脑的ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以通过在windows的PowerShell中运行以下命令来查看ip地址:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装要求输入密码, 注意是微软用户的密码, 不是电脑的开机密码</p><p>连接后，你将看到 Windows 命令行界面提示符：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">domain\username@SERVERNAME C:\Users\username&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="用户登录Oracle数据库"><a href="#用户登录Oracle数据库" class="headerlink" title="用户登录Oracle数据库"></a>用户登录Oracle数据库</h2><p>c成功链接后, 在终端输入:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlplus &#x2F; as sysdba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照提示输入用户名:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sys as sysdba <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并按照提示输入口令, 这个口令是在你安装Orecle软件的过程中设置的.</p><p>产生一下输出则链接成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">连接到: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>ctrl</code>+<code>c</code>退出sql服务, 输入<code>exit</code>退出ssh链接</p><h2 id="用Navicat远程登陆Oracle数据库"><a href="#用Navicat远程登陆Oracle数据库" class="headerlink" title="用Navicat远程登陆Oracle数据库"></a>用Navicat远程登陆Oracle数据库</h2><p>打开Navicat, 左上角选择, 之后选择Oracle.</p><p>链接名请随意填写, 主机位置填入localhost, 端口默认为1521</p><p>服务名默认为ORCL, 如果你在安装Oracle中没有更改, 则保持不变, 我的改为了ORACLE</p><p>角色选择SYSDBA,用户名为sys, 密码就是之前提到的口令.</p><img src="/Users/trevorwu/Library/Application Support/typora-user-images/image-20220929221736551.png" alt="image-20220929221736551" style="zoom:50%;" /><p>点击SSH选项</p><img src="/Users/trevorwu/Library/Application Support/typora-user-images/image-20220929221807569.png" alt="image-20220929221807569" style="zoom:50%;" /><p>主机填入windows主机的IP地址, 端口默认22, 用户名是windows账户的用户名, 密码是该账户的密码</p><p>点击链接测试, 成功链接后点击保存即可.</p>]]></content>
    
    
    <summary type="html">oracle目前还没有支持M1的版本, 本教程使用SSH来远程登录oracle服务器</summary>
    
    
    
    <category term="mac使用指南" scheme="https://trevoewu.github.io/categories/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac使用指南" scheme="https://trevoewu.github.io/tags/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    <category term="oracle" scheme="https://trevoewu.github.io/tags/oracle/"/>
    
    <category term="教程" scheme="https://trevoewu.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统漫游</title>
    <link href="https://trevoewu.github.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://trevoewu.github.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2023-04-21T12:31:56.000Z</published>
    <updated>2023-04-21T12:33:26.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息就是位-bit-加上下文-context"><a href="#信息就是位-bit-加上下文-context" class="headerlink" title="信息就是位(bit)加上下文(context)"></a>信息就是位(bit)加上下文(context)</h2><p>我们学习一门新的语言, 往往是从Hello world开始的, 我想没有一个程序员不喜欢这句话, 就像一个刚出生的婴儿, 对着这个陌生的世界微笑一样. </p><p>这次对计算机系统的学习就从一个hello world程序的生命周期开始. 从他被我们键入编辑器, 到在系统运行, 打印hello world最后interminates.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main()&#123;  printf(&quot;hello world\n&quot;);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的hello world程序生命的开始是源程序(source progam)或者源文件(source file), 以后缀 <code>.c</code> 结尾, 它是由一系列的0,1代码构成, 我们把每一位叫做bit. 每八个bit组成一个块, 我们称之为一个字节byte. 它是计算机处理信息的最小单位. 每一个byte对应着一个字符. </p><p>大多数计算机系统都采用ASCII标准来表示字符, 每一个ASCII码的值都对应着一个唯一的字符. 我们可以在linux或者like-unix系统的终端中键入<code>man ascii</code>来查看对应关系</p><img src="/Users/trevorwu/Library/Application Support/typora-user-images/image-20220928022041369.png" alt="image-20220928022041369" style="zoom:50%;" /><p>我们把像<code>hello.c</code>这样用ASCII码表示的文件叫做文本文件(text files), 而其他形式的文件叫做二进制文件(binary files)</p><p>在计算机中, 所以的信息都是都是一连串的由0和1组成, 而唯一区分这些信息就是上下文. 在不同上下文中, 相同的一段比特序列可能表示一个整数, 浮点数, 或者一条指令. </p><h2 id="程序被编译器翻译成不同的格式"><a href="#程序被编译器翻译成不同的格式" class="headerlink" title="程序被编译器翻译成不同的格式"></a>程序被编译器翻译成不同的格式</h2><p>计算机只认识二进制序列, helloworld这样的程序是不能被计算机理解的. 为了让计算机正确的执行我们的指令, 我们必须把它翻译成以二进制表示的形式, 我们把这样由二进制表示的语言叫做机器语言. 这些指令最后被打包成名叫可执行程序的形式, 存储为磁盘中的二进制文件. </p><p>在unix系统中, 这个由源文件翻译为可执行文件的过程是由一个叫编译器的程序完成.</p><p>整个边缘过程分为4个阶段, 分别是预编译处理, 编译, 汇编, 链接. </p><ul><li>预编译阶段修改由<code>#</code>为开始的语句, 比如这段hello.c程序中的<code>#include&lt;stdio.h&gt;</code>, 预编译阶段会在目标路径中找到对应的<code>stdio.h</code>文件, 并直接插入到程序中, 有点内容复制粘贴到过程.</li></ul><p>​这个<code>stdio.h</code>文件中主要包括函数声明, 宏定义, 以及结构体定义, 这个阶段会生成以<code>.i</code>为后缀的文本文件.</p><p>​默认情况下，预处理器的输出会被导入到标准输出流（也就是显示器），可以利用<code>-o</code>选项把它导入到某个输出文件, 在shell中键入<code>gcc -E hello.c -o hello.i</code>来输出到hello.i文件中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,       const char * restrict, va_list);# 400 &quot;&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h&quot; 2 3 4# 2 &quot;hello.c&quot; 2int main()&#123;  printf(&quot;hello world\n&quot;);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>产生的代码很长很长, 大概有500行,这里只截取最后一部分. 可以发现, 即使是想helloworld这样极端简单的程序, 编译之后也会比源文件大很多.</p><ul><li>编译阶段把预编译产生的以<code>.i</code>结尾的文件翻译成以汇编语言表示的文本文件, 汇编是一种很有用的低一级的语言, 在不同的编译器编译不同的高级语言中, 它往往作为编译阶段的输出语言.</li></ul><p>我们可以在shell中键入<code>gcc -S hello.c</code>生产汇编程序<code>hello.s</code> :</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_main:                                  ; @main.cfi_startproc; %bb.0:subsp, sp, #32                     ; &#x3D;32stpx29, x30, [sp, #16]             ; 16-byte Folded Spilladdx29, sp, #16                    ; &#x3D;16.cfi_def_cfa w29, 16.cfi_offset w30, -8.cfi_offset w29, -16movw8, #0strw8, [sp, #8]                    ; 4-byte Folded Spillsturwzr, [x29, #-4]adrpx0, l_.str@PAGEaddx0, x0, l_.str@PAGEOFFbl_printfldrw0, [sp, #8]                    ; 4-byte Folded Reloadldpx29, x30, [sp, #16]             ; 16-byte Folded Reloadaddsp, sp, #32                     ; &#x3D;32ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>汇编阶段</p><p>在汇编阶段编译器会把上一阶段用ASCII表示的文本文件<code>hello.s</code>转化为机器语言表示的指令, 并打包生成叫做可重定位的二进制文件文件, 存储在<code>hello.o</code>的文件中, 如果我们打开这个文件,  文本编辑器会按照ASCII表示成对应的字符, 所以我们将会看到一堆乱码. </p></li><li><p>链接阶段</p></li></ul><p>注意到我们的helloworld程序调用了一个名为printf的函数, 这个函数是C标准库函数的一部分,由编译起提供. 这个函数保持在一个单独的预编译的目标文件中, 叫做<code>printf.o</code>它必须和我们的<code>hello.o</code>合并, 这个工作由链接器完成, 生成和以直接运行可执行文件<code>hello</code>. </p><p>现在, 我们的源程序以及被翻译成了可执行文件, 并存储来磁盘中. 我们可以在shell中键入<code>./hello</code>来运行我们的程序. </p>]]></content>
    
    
    <summary type="html">我们学习一门新的语言, 往往是从Hello world开始的, 我想没有一个程序员不喜欢这句话, 就像一个刚出生的婴儿, 对着这个陌生的世界微笑一样.</summary>
    
    
    
    <category term="学习笔记" scheme="https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="computer system" scheme="https://trevoewu.github.io/tags/computer-system/"/>
    
  </entry>
  
  <entry>
    <title>纪念拥有了自己的博客</title>
    <link href="https://trevoewu.github.io/2023/04/21/%E7%BA%AA%E5%BF%B5%E6%8B%A5%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://trevoewu.github.io/2023/04/21/%E7%BA%AA%E5%BF%B5%E6%8B%A5%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-04-21T12:28:51.000Z</published>
    <updated>2023-04-21T12:30:45.584Z</updated>
    
    <content type="html"><![CDATA[<p>当一个由你亲手塑造的东西第一次呈现在你面前的时候, 那种兴奋感以及成就感是难以比拟的. </p><span id="more"></span><p>比如当我第一次用自己的废旧的电脑组装成一台显示器, 当看到显示器作为switch副屏被点亮的时候. 比如自己照着教程给路由器刷插件来破解校园网, 看见Wi-Fi信号出现, 设备连接后, 绕过认证连接上互联网的时候. </p><p>那时候, 我好高兴好高兴, 我很想分享我的成果, 告诉宿舍的每一个人让他们连我的Wi-Fi, 从此实现Wi-Fi自由. 平时沉默不语的我在这时候犹豫了. 我只能强迫自己去做一些别的事来抑制这份心情. </p><p>而用于自己的博客带来的悸动是更胜过这两件事的. </p><p>我很开心当我告诉我的两位异性朋友时, 虽然她们对此并不了解, 仅仅是看见她们好奇和称赞我就好开心. </p><p>第一次听到博客这个词是在初二的时候, 老师给我们发了一份调查问卷, 其中一个问题便是有没有自己的博客, 那时候我还不知道博客是什么, 便以为是微博, 于是填上了是. 想必那时候拿到数据的人会不会惊讶于一个初二学生会拥有自己的博客呢. </p><p>上大学后, 靠搜索学习也让我遇见了很多优秀的博客, 有着精致的页面, 充满个人特色的UI, 以及那些学习和生活的记录, 每次翻阅, 我都觉得他们好优秀. </p><p>好像成为他们那样优秀的人. </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当一个由你亲手塑造的东西第一次呈现在你面前的时候, 那种兴奋感以及成就感是难以比拟的. &lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://trevoewu.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="日常" scheme="https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="talk" scheme="https://trevoewu.github.io/tags/talk/"/>
    
  </entry>
  
  <entry>
    <title>hexo插入图片问题</title>
    <link href="https://trevoewu.github.io/2023/04/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>https://trevoewu.github.io/2023/04/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-21T03:46:44.000Z</published>
    <updated>2023-04-21T04:47:56.326Z</updated>
    
    <content type="html"><![CDATA[<p>昨天刚搭建完博客, 发现直接写markdown, hexo 生成后图片全部都没法显示了, 毕竟图片都在本地, 以绝对路径的方式存储的, markdown的路径的hexo的路径不匹配. </p><span id="more"></span><p>以前搭博客的时候这个图片问题就老是困扰着我, 我用typora编写的文章转到html之后, 我还得把图片也引到项目目录来, 然后在一个个的该路径. 体验可以说是很差了, 这也导致哪怕写完文章, 我也懒得发布了, 太麻烦. </p><p>这次用hexo搭建也遇到了同样的问题, 按照老方法, 我能想到的就只有把图片全部拉过来了, 我直接把全部图片<code>mv</code>到了public目录的imag目录下, 部署到github上的时候, 由于图片太多了, 进度条老是卡住, 我只好放弃了. 我直接<code>ctl+c</code>, <code>hexo clean</code>,<code>hexo s</code>.这时候我还不知道<code>hexo clean</code>意味这什么, 只是看教程大家都是这样做的, 结果, 结果hexo把我pubilc目录下的文件全部删了…, 我的图片, 也全没了. </p><p>今天发现一个绝好的解决方案, 将Typora和hexo完美结合起来. </p><h3 id="第一步-修改hexo的站点配置文件-config-yml"><a href="#第一步-修改hexo的站点配置文件-config-yml" class="headerlink" title="第一步 修改hexo的站点配置文件_config.yml"></a>第一步 修改hexo的站点配置文件_config.yml</h3><p>首先安装插件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-renderer-marked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在_config.yml搜索<code>post_asset_folder</code>改为true 如下:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">post_asset_folder: truemarked:  prependRoot: true  postAsset: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 <code>hexo new &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹，并在执行<code>hexo g</code>的时候连同图片以前复制到public目录下(网站的根目录).于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 <code>example.jpg</code> 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 <code>![](example/example.jpg)</code>即可访问 。</p><p>  也就是这样</p><p><img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421120557507.png" alt="image-20230421120557507"></p><p>但是呢, 执行<code>hexo g</code>生成的时候, hexo会把sourec目录下的_posts文件的转化为成html, 并保存在pubilc对应日期的路径中,<img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421121112744.png" alt="image-20230421121112744"></p><p>可以看到, 此时index中的图片路径和markdown的图片路径是冲突的. </p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">typora的路径使用: ![](.&#x2F;example&#x2F;example.jpg)这样页面上的img路径就会是:&#x2F;你的文章标题&#x2F;example&#x2F;example.jpg正确的图片地址: &#x2F;example&#x2F;example.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为<code>hexo g</code>把文件夹里面图片复制过来了, 但并没有复制整个图片的文件夹. </p><p>所以我只需要拿到当前博客的路径，直接加上图片名字就行.</p><h3 id="第二步-编写路径替换脚本"><a href="#第二步-编写路径替换脚本" class="headerlink" title="第二步, 编写路径替换脚本"></a>第二步, 编写路径替换脚本</h3><p>在全局js文件 themes\next\source\js\next-boot.js中，编写img 路径替换脚本</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 脚本提供者</span><span class="token comment">//http://songpengpeng.com</span><span class="token keyword">var</span> images <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> loHref <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token keyword">let</span> baseHref <span class="token operator">=</span> loHref<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>loHref<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>images<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> executeNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> src <span class="token operator">=</span> images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'src'</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> src    img<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    img<span class="token punctuation">.</span><span class="token function-variable function">onerror</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>        executeNum <span class="token operator">++</span> <span class="token punctuation">;</span>        <span class="token function">handAMark</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>executeNum<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">let</span> fileName <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>src<span class="token operator">=</span> baseHref<span class="token operator">+</span>fileName    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span>  <span class="token function">handAMark</span><span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> <span class="token keyword">as</span> <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"fancybox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span><span class="token keyword">as</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> executeNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> href <span class="token operator">=</span> <span class="token keyword">as</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>href<span class="token operator">==</span>src<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            img<span class="token punctuation">.</span>src <span class="token operator">=</span> src            img<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            img<span class="token punctuation">.</span><span class="token function-variable function">onerror</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>                executeNum <span class="token operator">++</span> <span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>executeNum<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">let</span> fileName <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">as</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>href<span class="token operator">=</span> baseHref<span class="token operator">+</span>fileName            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样, 使用<code>hexo g</code>生成的时候, 就会自动将图片的路径替换. </p><h3 id="第三步-搭配typora才是最佳"><a href="#第三步-搭配typora才是最佳" class="headerlink" title="第三步, 搭配typora才是最佳"></a>第三步, 搭配typora才是最佳</h3><p>但是还是不够方便啊, 我们得先把图片放到文章的资源文件夹中. Typora对插图片的支持非常好, 可以在复制图片的同时, 把物品保存在对应的文件夹中</p><p>打开Typora, <code>⌘+,</code>进入系统偏好设置, 点击image选项卡, 修改为以下格式: </p><p>这样当插入图片的时候, 会自动把图片放到当前目录的markdown相名的文件夹中, 恰好, Hexo 在我们每一次通过 <code>hexo new &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹. </p><p>完美!</p><p><img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421124001298.png" alt="image-20230421124001298"></p><p>这样, 我们在Typora上写文章, 完全不用担心插入图片问题, 而且文章的图片也会有序的存放, 方面日后的管理. </p><p>现在我们只需要<code>hexo n &#39;title&#39;</code>然后在Typora上写文章, 就可以直接推到博客了, 照片也可以正常显示. </p><p>你看, 我写完这篇文章的时候, hexo已经完美的生成网页了. </p><p>这太棒了, 不是吗? </p><p><img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421124655253.png" alt="image-20230421124655253"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天刚搭建完博客, 发现直接写markdown, hexo 生成后图片全部都没法显示了, 毕竟图片都在本地, 以绝对路径的方式存储的, markdown的路径的hexo的路径不匹配. &lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo重新搭建博客</title>
    <link href="https://trevoewu.github.io/2023/04/21/%E4%BD%BF%E7%94%A8hexo%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://trevoewu.github.io/2023/04/21/%E4%BD%BF%E7%94%A8hexo%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-04-20T16:52:00.000Z</published>
    <updated>2023-04-20T16:58:45.077Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客是学web的时候手搓的, 导致后期管理困难, 每次发布文章我甚至得手写HTML. 后来发现大家都是用hexo搭建博客, 我也尝试了一下. </p><p>我真的好喜欢自己之前博客的风格<a href="https://trevoewu.github.io/Peekaboo/">Peekaboo的部落格</a></p><p>现在就先用next主题吧, 这个主题虽然不怎么好看, 但是帮助文档太友好了, 感谢感谢. </p>]]></content>
    
    
    <summary type="html">之前的博客是学web的时候手搓的, 导致后期管理困难, 每次发布文章我甚至得手写HTML. 后来发现大家都是用hexo搭建博客, 我也尝试了一下.</summary>
    
    
    
    
    <category term="Talk" scheme="https://trevoewu.github.io/tags/Talk/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark lab HTTP</title>
    <link href="https://trevoewu.github.io/2023/04/20/Wireshark-lab-HTTP/"/>
    <id>https://trevoewu.github.io/2023/04/20/Wireshark-lab-HTTP/</id>
    <published>2023-04-20T15:01:49.000Z</published>
    <updated>2023-04-20T15:50:51.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wireshark实验-HTTP"><a href="#Wireshark实验-HTTP" class="headerlink" title="Wireshark实验 - HTTP"></a>Wireshark实验 - HTTP</h1><p><strong>官方英文文档：<a href="Wireshark_HTTP_v7.0"><a href="http://www-net.cs.umass.edu/wireshark-labs/Wireshark_HTTP_v7.0.pdf">Wireshark_HTTP_v7.0</a></a></strong></p><p><strong>以下内容为笔者翻译：</strong></p><hr><p><strong>《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross</strong></p><p>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 </p><p>© 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved</p><hr><p>在介Wireshark实验-入门里，我们已经初步使用了Wireshark包嗅探器，我们现在可以操作Wireshark来查看网络协议。在这个实验中，我们会探索HTTP协议的几个方面：基本的GET&#x2F;response交互，HTTP消息格式，检索大型HTML文件，检索具有嵌入对象的HTML文件，HTTP认证和安全性。在开始这些实验之前，您可能想查看书中第2.2节。</p><h3 id="1-基本HTTP-GET-x2F-response交互"><a href="#1-基本HTTP-GET-x2F-response交互" class="headerlink" title="1.基本HTTP GET&#x2F;response交互"></a>1.基本HTTP GET&#x2F;response交互</h3><p>我们开始探索HTTP，方法是下载一个非常简单的HTML文件<br>非常短，并且不包含嵌入的对象。执行以下操作：</p><ol><li>启动您的浏览器。</li><li>启动Wireshark数据包嗅探器，如Wireshark实验-入门所述（还没开始数据包捕获）。在display-filter-specification窗口中输入“http”（只是字母，不含引号标记），这样就在稍后的分组列表窗口中只捕获HTTP消息。（我们只对HTTP协议感兴趣，不想看到其他所有的混乱的数据包）。</li><li>稍等一会儿（我们将会明白为什么不久），然后开始Wireshark数据包捕获。</li><li>在浏览器中输入以下内容 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html</a> 您的浏览器应显示非常简单的单行HTML文件。</li><li>停止Wireshark数据包捕获。</li></ol><p>你的Wireshark窗口应该类似于图1所示的窗口。如果你无法连接网络并运行Wireshark，您可以根据后面的步骤下载已捕获的数据包：</p><p>下载zip文件 <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a> </p><p>解压缩文件 http-ethereal-trace-1。这个zip文件中的数据是由本书作者之一使用Wireshark在作者电脑上收集的，并且是按照Wireshark实验中的步骤做的。 如果你下载了数据文件，你可以将其加载到Wireshark中，并使用文件菜单选择打开并查看数据，然后选择http-ethereal-trace-1文件。 结果显示应与图1类似。（在不同的操作系统上，或不同的Wireshark版本上，Wireshark的界面会不同）。</p><p><strong>图1：Wireshark显示 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTPwireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTPwireshark-file1.html</a> 已被您的浏览器打开</strong></p><p>图1中的示例在分组列表窗口中显示了两个被捕获的HTTP消息：GET消息（从您的浏览器发送到gaia.cs.umass.edu 的web服务器）和从服务器到浏览器的响应消息。分组内容窗口显示所选消息的详细信息（在这种情况下为HTTP OK消息，其在分组列表窗口中高亮显示）。回想一下，因为HTTP消息被装载在TCP报文段内，该报文段是在IP分组封装吗，进而在以太网帧，和帧中封装，所以界面中显示了帧，以太网，IP，TCP分组信息以及HTTP报文信息。我们想最小化非HTTP数据的显示（我们这里只对HTTP感兴趣，这些其他协议将在以后的实验中研究），所以确保帧，以太网，IP和TCP行的信息被隐藏，注意左边有一个加号或一个向右的三角形（这意味着有信息被隐藏），而HTTP行具有减号或向下三角形（表示显示有关HTTP消息的所有信息）。</p><p>（注意：您应该忽略与favicon.ico相关的任何HTTP GET和response。 如果你看到一个关于这个文件的引用，这是你的浏览器自动询问服务器是否有一个图标文件应显示在浏览器的URL旁边。 我们会忽略这个引起麻烦的引用。）</p><p>通过查看HTTP GET和响应消息中的信息，回答以下问题。 在回答以下问题时，您应该打印出GET和响应消息（请参阅Wireshark-入门实验以获取信息），并指出您在消息中的哪个具体位置找到了回答以下问题的信息。 当您上交作业时，请注明输出，显示您在哪些地方表示了您的答案（例如，对于我们的课程，我们要求学生用笔标记纸质副本，或用彩色字体在电子副本的中注释文本）。</p><ol><li><p>您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？</p><p>HTTP&#x2F;1.1</p><p>![image-20230416143533797](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416143533797.png)</p></li><li><p>您的浏览器会从接服务器接受哪种语言（如果有的话）？</p><p>![image-20230416144437584](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144437584.png)</p></li><li><p>您的计算机的IP地址是什么？ gaia.cs.umass.edu服务器地址呢？</p><p>![image-20230416143642203](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416143642203.png)</p></li><li><p>服务器返回到浏览器的状态代码是什么？</p><p>![image-20230416144507009](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144507009.png)</p></li><li><p>服务器上HTML文件的最近一次修改是什么时候？</p><p>![image-20230416144603595](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144603595.png)</p></li><li><p>服务器返回多少字节的内容到您的浏览器？</p><p>![image-20230416144632313](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144632313.png)</p></li><li><p>通过检查数据包内容窗口中的原始数据，你是否看到有协议头在数据包列表窗口中未显示？ 如果是，请举一个例子。</p><p>没有</p></li></ol><p>在您对上述问题5的回答中，您可能会惊讶地发现您刚才检索的文档在下载文档之前最近一次修改是一分钟前。 那是因为（对于这个特定文件），gaia.cs.umass.edu服务器将文件的最后修改时间设置为当前时间，并且每分钟执行一次。 因此，如果您在两次访问之间等待一分钟，则该文件看起来已被修改，因此您的浏览器将下载文档的“新”副本。</p><h3 id="2-HTTP条件Get-x2F-response交互"><a href="#2-HTTP条件Get-x2F-response交互" class="headerlink" title="2.HTTP条件Get&#x2F;response交互"></a>2.HTTP条件Get&#x2F;response交互</h3><p>回顾书的第2.2.5节，大多数Web浏览器使用对象缓存，从而在检索HTTP对象时执行条件GET。执行以下步骤之前，请确保浏览器的缓存为空。（要在Firefox下执行此操作，请选择“工具” - &gt; “清除最近历史记录”，然后检查缓存框，对于Internet Explorer，选择“工具” - &gt;“Internet选项” - &gt;“删除文件”；这些操作将从浏览器缓存中删除缓存文件。 现在按下列步骤操作：</p><ul><li>启动您的浏览器，并确保您的浏览器的缓存被清除，如上所述。</li><li>启动Wireshark数据包嗅探器。</li><li>在浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html</a> 您的浏览器应显示一个非常简单的五行HTML文件。</li><li>再次快速地将相同的URL输入到浏览器中（或者只需在浏览器中点击刷新按钮）。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只捕获HTTP消息，并在数据包列表窗口中显示。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-2数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>回答下列问题：</p><ol start="8"><li><p>检查第一个从您浏览器到服务器的HTTP GET请求的内容。您在HTTP GET中看到了“IF-MODIFIED-SINCE”行吗？</p><p>没有</p></li><li><p>检查服务器响应的内容。服务器是否显式返回文件的内容？ 你是怎么知道的？</p><p>是的,![image-20230416150206500](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416150206500.png)</p></li><li><p>现在，检查第二个HTTP GET请求的内容。 您在HTTP GET中看到了“IF-MODIFIED-SINCE:”行吗？ 如果是，“IF-MODIFIED-SINCE:”头后面包含哪些信息？</p><p>看见了. 日期</p><p>![image-20230416151334645](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151334645.png)</p></li><li><p>针对第二个HTTP GET，从服务器响应的HTTP状态码和短语是什么？服务器是否明确地返回文件的内容？请解释。</p><p>![image-20230416150249214](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416150249214.png)</p></li></ol><h3 id="3-检索长文件"><a href="#3-检索长文件" class="headerlink" title="3.检索长文件"></a>3.检索长文件</h3><p>在我们到目前为止的例子中，检索的文档是简短的HTML文件。 接下来我们来看看当我们下载一个长的HTML文件时会发生什么。 按以下步骤操作：</p><ul><li>启动您的浏览器，并确保您的浏览器缓存被清除，如上所述。</li><li>启动Wireshark数据包嗅探器</li><li>在您的浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html</a> 您的浏览器应显示相当冗长的美国权利法案。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-3数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>在分组列表窗口中，您应该看到您的HTTP GET消息，然后是对您的HTTP GET请求的多个分组的TCP响应。这个多分组响应值得进行一点解释。回顾第2.2节（见文中的图2.9），HTTP响应消息由状态行组成，后跟标题行，后跟一个空行，后跟实体主体。在我们的HTTP GET这种情况下，响应中的实体主体是整个请求的HTML文件。在我们的例子中，HTML文件相当长，4500字节太大，一个TCP数据包不能容纳。因此，单个HTTP响应消息由TCP分成几个部分，每个部分包含在单独的TCP报文段中（参见书中的图1.24）。在Wireshark的最新版本中，Wireshark将每个TCP报文段指定为独立的数据包，并且单个HTTP响应在多个TCP数据包之间分段的事实由Wireshark显示的Info列中的“重组PDU的TCP段”指示。 Wireshark的早期版本使用“继续”短语表示HTTP消息的整个内容被多个TCP段打断。我们在这里强调，HTTP中没有“继续”消息！</p><p>回答下列问题：</p><ol start="12"><li><p>您的浏览器发送多少HTTP GET请求消息？哪个数据包包含了美国权利法案的消息？</p><p>![image-20230416151626850](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151626850.png)</p><p>两个, 第一个</p></li><li><p>哪个数据包包含响应HTTP GET请求的状态码和短语？</p><p>![image-20230416151652019](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151652019.png)</p><p>第二个</p></li><li><p>响应中的状态码和短语是什么？</p><p>200 OK</p></li><li><p>需要多少包含数据的TCP段来执行单个HTTP响应和权利法案文本？</p><p>4个TCP段</p><p>![image-20230416151853132](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151853132.png)</p></li></ol><h3 id="4-具有嵌入对象的HTML文档"><a href="#4-具有嵌入对象的HTML文档" class="headerlink" title="4.具有嵌入对象的HTML文档"></a>4.具有嵌入对象的HTML文档</h3><p>现在我们已经看到Wireshark如何显示捕获的大型HTML文件的数据包流量，我们可以看看当浏览器使用嵌入的对象下载文件时，会发生什么，即包含其他对象的文件（在下面的例子中是图像文件） 的服务器。<br>执行以下操作：</p><ul><li>启动您的浏览器。</li><li>启动Wireshark数据包嗅探器。</li><li>在浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html</a> 您的浏览器应显示包含两个图像的短HTML文件。这两个图像在基本HTML文件中被引用。也就是说，图像本身不包含在HTML文件中；相反，图像的URL包含在已下载的HTML文件中。如书中所述，您的浏览器将不得不从指定的网站中检索这些图标。我们的出版社的图标是从 <a href="http://www.aw-bc.com/">www.aw-bc.com</a> 网站检索的。而我们第5版（我们最喜欢的封面之一）的封面图像存储在manic.cs.umass.edu服务器。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-4数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>回答下列问题：</p><ol start="16"><li><p>您的浏览器发送了几个HTTP GET请求消息？ 这些GET请求发送到哪个IP地址？</p><p>三个</p><p>![image-20230416152201783](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152201783.png)</p></li><li><p>浏览器从两个网站串行还是并行下载了两张图片？请说明。</p><p>猜测为串行, 因为这两个GET请求发送有时间差</p><p>![image-20230416152416694](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152416694.png)</p></li></ol><h3 id="5-HTTP认证"><a href="#5-HTTP认证" class="headerlink" title="5.HTTP认证"></a>5.HTTP认证</h3><p>最后，我们尝试访问受密码保护的网站，并检查网站的HTTP消息交换的序列。URL <a href="http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html">http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html</a> 是受密码保护的。用户名是“wireshark-students”（不包含引号），密码是“network”（再次不包含引号）。所以让我们访问这个“安全的”受密码保护的网站。执行以下操作：</p><ul><li>请确保浏览器的缓存被清除，如上所述，然后关闭你的浏览器，再然后启动浏览器</li><li>启动Wireshark数据包嗅探器。</li><li>在浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html">http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html</a> 在弹出框中键入所请求的用户名和密码。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-5数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>现在来看看Wireshark输出。 您可能需要首先阅读HTTP身份验证相关信息，方法是在 <a href="http://frontier.userland.com/stories/storyReader$2159">http://frontier.userland.com/stories/storyReader$2159</a> 上查看“HTTP Access Authentication Framework ”上的易读材料。</p><p>回答下列问题：</p><ol start="18"><li><p>对于您的浏览器的初始HTTP GET消息，服务器响应（状态码和短语）是什么响应？</p><p>![image-20230416152712931](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152712931.png)</p><p>未授权</p></li><li><p>当您的浏览器第二次发送HTTP GET消息时，HTTP GET消息中包含哪些新字段？</p><p>![image-20230416152814670](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152814670.png)</p><p>一个Credentials: 的字段</p></li></ol><p>您输入的用户名（wireshark-students）和密码（network）按照客户端HTTP GET消息中请求头的“Authorization: Basic ”的字符串（d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms&#x3D;）编码。虽然您的用户名和密码可能加密，但它们只是以一种称为Base64格式的格式进行编码。用户名和密码并没有加密！要确认这些，请访问 <a href="http://www.motobit.com/util/base64-decoder-encoder.asp">http://www.motobit.com/util/base64-decoder-encoder.asp</a> 并输入base64编码的字符串d2lyZXNoYXJrLXN0dWRlbnRz 并进行解码。瞧！您已从Base64编码转换为ASCII编码，因此应该看到您的用户名！要查看密码，请输入字符串Om5ldHdvcms&#x3D;的剩余部分，然后按解码。因为任何人都可以下载像Wireshark这样的工具，而且可以通过网络适配器嗅探数据包（不仅仅是自己的），任何人都可以从Base64转换为ASCII（你刚刚就这么做了！），所以你应该很清楚，WWW网站上的简单密码并不安全，除非采取其他措施。</p><p>wireshark自带解码….</p><p>不要害怕！ 正如我们将在第8章中看到的，有一些方法可以使WWW访问更加安全。然而，我们显然需要一些超出基本HTTP认证框架的知识！</p>]]></content>
    
    
    <summary type="html">在这个实验中，我们会探索HTTP协议的几个方面：基本的GET/response交互，HTTP消息格式，检索大型HTML文件，检索具有嵌入对象的HTML文件，HTTP认证和安全性</summary>
    
    
    
    
    <category term="computer network" scheme="https://trevoewu.github.io/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark Lab: IP v7.0</title>
    <link href="https://trevoewu.github.io/2023/04/20/Wireshark-Lab-IP-v7-0/"/>
    <id>https://trevoewu.github.io/2023/04/20/Wireshark-Lab-IP-v7-0/</id>
    <published>2023-04-20T10:22:06.000Z</published>
    <updated>2023-04-21T03:44:49.965Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Select the first ICMP Echo Request message sent by your computer, and expand the Internet Protocol part of the packet in the packet details window.(选择您的计算机发送的第一个 ICMP Echo Request 消息，并在数据包详细信息窗口中展开数据包的 Internet 协议部分)<br>不知道为什么, 我的电脑只能收到Time to live exceeded报文段.<span id="more"></span>结果是因为我在过滤了ICMP, 而<strong>traceroute默认使用UDP而不是ICMP</strong>, 所以只能收到路由器发给我的ICMP time to live exceeded 报文,告诉我的数据包被干掉了.</li></ul><p>tracert 默认使用 ICMP 包探测，traceroute 使用 UDP 包，也可以使用 ICMP 和 TCP 包探测, 带上参数-T即可.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-I      Use ICMP ECHO instead of UDP datagrams.  (A synonym for &quot;-P icmp&quot;).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">traceroute baidu.com 2000  # 使用baidu测试, 默认使用UDP, 数据报大小为2000byte<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>What is the IP address of your computer?</p></li><li><p>在 IP header 中，上层协议字段的值是多少?</p><p>我的IP地址: 10.51.172.226 </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421113757555.png" alt="image-20230421113757555"></p><p>这是traceroute发送的第一个数据报, 可以得到以下信息: </p><ul><li>该数据报是IP数据报, 上层协议为UDP</li><li>数据报被分片了, More Fragment字段被设为1</li><li>源IP是10.51.172.226, 这是host IP</li><li>目标IP是110,242,68,66, 这是Baidu.com的IP地址, 我用百度来测试.</li></ul></li><li><p>IP datagram 的有效负载中有多少 bytes? 说明如何 确定 payload bytes 的数。</p></li></ul><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421113848009.png" alt="image-20230421113848009"></p><p>payload &#x3D; Total Len - header Len &#x3D; 1500 - 20 &#x3D; 1480, 是的, 我直接发送了2000byte的报文</p><ul><li><p>此 IP 数据报是否已被分段(fragmented)?解释您如何确定数据报是否已被分段(fragmented)</p><p>是的, 前文有提到, 这里不再赘述.</p></li></ul><blockquote><p>接下来，通过单击 Source 列标题，根据 IP 源地址对跟踪的数据包进行排序，一个小的向下箭头应出现在 Source 旁边，如果箭头指向上方请再次单击“Source column header”。选择计算机发送的第一个 ICMP Echo Request 消息，然后展开“details of selected packet header”窗口中的 Internet 协议部分。在“listing of captured packets”窗 口中，您应该在第一个 ICMP 下面看到所有后续 ICMP 消息(可能还有计算器上运行的其他协议发送的其他散布数据包)，使用向下箭头浏览计算器发送的 ICMP 消息。</p></blockquote><ul><li><p>在您的计算器发送的这一系列 ICMP 消息中，IP 数据报中的哪些字段总有改变</p><p>使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">traceroute -I gaia.cs.umass.edu -80# 用作者给的网站测试, -I表示使用ICMP# The default probe datagram length is 40 bytes[traceroute manual]# 但是我使用作者提议用56作为数据报(ip datagrame)大小时, 收到以下警告: # traceroute: packet length must be &gt; 71# 所以这里数据报大小设为80, 实际上, 我使用不带数据报大小参数的命令时, 默认数据报大小为1380<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次抓包, 由于traceroute实际上会发送三个ICMP的数据报, 所以三个为一组.  所以可发现每一组的ID值差3, 当然是因为一组发了三个ICMP数据报啊..</p></li></ul><p>第一个:</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421113947335.png" alt="image-20230421113947335"></p><p>第二个: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114009587.png" alt="image-20230421114009587"></p><p>第三个: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114026434.png" alt="image-20230421114026434"></p><p>可以发现, Id, TTL, Header checksum改变了.</p><ul><li><p>哪些字段保持不变? 哪个字段必须保持不变? 哪些字段必须更改? 为什么?</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114245968.png" alt="image-20230421114245968"></p><ul><li>Version, Header Length , TOS(Differentiate Services Field差异化服务领域), Flag, TTL, Protocol, SIP,DIP保持不变</li><li>Version, Protocol, TOS, Header Len必须保持不变.</li><li>Identification, checksum,TTL必须更改</li></ul></li><li><p>描述您在 IP 数据报的标识字段的值中看到的模式</p></li></ul><p>每发一个ICMP的数据报, ID字段加一(不分片的情况下, 分片时一个IP数据报的不同片具有相同的ID)</p><ul><li>下一步(数据包仍按来源地址排序)查找最近的(第一跳)路由器发送到您的计算器的一系列 ICMP TTL 超出的回复讯息。</li><li>ID 字段和 TTL 字段的值是多少?</li></ul><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114303180.png" alt="image-20230421114303180"></p><ul><li><p>对于最近(第一跳)路由器发送到您的计算器的所有 ICMP TTL 超出的回复，这些值是否保持不变?为什么?</p><p>TTL保持不变, 但ID改变了. TTL都为64(可以改变, 理论上可以为1, 因为第一台路由器到我的主机一跳可达)</p><p>在不管是发回给我的time to live exceeded还是ICMP reply TTL的值都为64, 可能是默认的值.</p></li></ul><blockquote><p>单击“时间”列，再次按时间对数据包列表进行排序。</p></blockquote><ul><li>在将 pingplotter 中的数据包大小更改为 2000 后，查找计算机发送的第一个 ICMP Echo Request 消息。该消息是否已分片为多个 IP 数据报?</li><li>打印出碎片 IP 数据报的第一个片段。 IP 头中的哪些信息表明数据报已碎片 化? IP 头中的哪些信息表明这是第一个片段还是后一个片段? 这个 IP 数据报有多长?</li><li>打印出碎片 IP 数据报的第二个片段。 IP 标头中的哪些信息表明这不是第一 个数据报片段? 是否还有更多的片段? 你是如何知道的?</li></ul><p>是的, 该消息被分片了, 可以通过flag字段看出, Fragmen Offset 为1480, 而More Fragment为0 ,告诉这是第二个message, 那第一个到哪里去了呢?</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114317964.png" alt="image-20230421114317964"></p><p>Wireshark告诉我在frame 73, 于是我去寻找frame73</p><p><em>73frame和74frame的payload 和 为 1980, 因为规定了ICMP的IP数据报大小为2000, 但由于IP头部的20byte, 实际的payload恰好为1980byte</em></p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114327978.png" alt="image-20230421114327978"></p><p>注意到发到第一个message竟然不是ICMPmessage, 而是一个IPdatagram</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114340203.png" alt="image-20230421114340203"></p><p>打开IP头部, 我们发现, 这仍然是一个ICMP的数据报, 但是在IP的数据部分并没有ICMP头部.</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114350725.png" alt="image-20230421114350725"></p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114403647.png" alt="image-20230421114403647"></p><ul><li><p>在第一个和第二个片段中，IP 标头中哪些字段发生了变化?</p><p>第一个fregment: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114415389.png" alt="image-20230421114415389"></p><p>第二片: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114431692.png" alt="image-20230421114431692"></p><p>注意到红色部分发送了改变, 而蓝色部分没有改变, IP数据报用ID来标识多个片是否属于同一个IP数据报.</p></li></ul><blockquote><p>现在，在将 pingplotter 中的数据包大小更改为 3500 后，找到计算机发送的第一个 ICMP Echo Request 消息。</p></blockquote><ul><li><p>从原始数据报创建了多少个片?</p><p>三个片</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114440735.png" alt="image-20230421114440735"></p></li><li><p>片段中 IP 标头中的哪些字段发生了变化?</p><p>和上一个结论相同, 红色部分发送了改变, 而蓝色部分没有改变, IP数据报用ID来标识多个片是否属于同一个IP数据报.</p></li></ul><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114449611.png" alt="image-20230421114449611"></p>]]></content>
    
    
    <summary type="html">在本实验中, 我们将研究 IP 协议,重点关注IP datagram. 我们将通过分析在执行 traceroute 程序发送和接收的一系列 IP 数据报的过程来完成这个实验,我们将研究IP datagram 中的各个字段(fields)，并详细研究 IP fragmentation 的方法</summary>
    
    
    
    
    <category term="computer network" scheme="https://trevoewu.github.io/tags/computer-network/"/>
    
    <category term="lab" scheme="https://trevoewu.github.io/tags/lab/"/>
    
  </entry>
  
</feed>
