<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楼兰</title>
  
  
  <link href="https://trevoewu.github.io/atom.xml" rel="self"/>
  
  <link href="https://trevoewu.github.io/"/>
  <updated>2023-05-05T07:21:30.475Z</updated>
  <id>https://trevoewu.github.io/</id>
  
  <author>
    <name>楼兰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Wireshark Lab: ICMP</title>
    <link href="https://trevoewu.github.io/2023/05/05/Wireshark-Lab-ICMP/"/>
    <id>https://trevoewu.github.io/2023/05/05/Wireshark-Lab-ICMP/</id>
    <published>2023-05-05T02:48:32.000Z</published>
    <updated>2023-05-05T07:21:30.475Z</updated>
    
    <content type="html"><![CDATA[<p>In this lab, we’ll explore several aspects of the ICMP protocol:<br>在本实验中，我们将探讨 ICMP 协议的几个方面:</p><span id="more"></span><ul><li><p>ICMP messages generating by the Ping program; Ping 程序生成的 ICMP 消息;</p></li><li><p>ICMP messages generated by the Traceroute program; Traceroute 程序生成的 ICMP 消息;</p></li><li><p>the format and contents of an ICMP message. ICMP 消息的格式和内容。</p></li></ul><p>  Before attacking this lab, you’re encouraged to review the ICMP material in section 5.6<br>   of the text1. We present this lab in the context of the Microsoft Windows operating system. However, it is straightforward to translate the lab to a Unix or Linux environment. 在开始本实验之前，我们建议您查看课本的 5.6 节中的 ICMP 章节。此实验是在Windows 下完成的，如果您使用其他系统也不用担心，因为大体都相同。</p><h2 id="ICMP-and-Ping-ICMP-协议和-Ping-程序"><a href="#ICMP-and-Ping-ICMP-协议和-Ping-程序" class="headerlink" title="ICMP and Ping ICMP 协议和 Ping 程序"></a>ICMP and Ping ICMP 协议和 Ping 程序</h2><p>Let’s begin our ICMP adventure by capturing the packets generated by the Ping program. You may recall that the Ping program is simple tool that allows anyone (for example, a network administrator) to verify if a host is live or not. The Ping program in the source host sends a packet to the target IP address; if the target is live, the Ping program in the target host responds by sending a packet back to the source host. As you might have guessed (given that this lab is about ICMP), both of these Ping packets are ICMP packets. 让我们通过捕获 Ping 程序生成的数据包开始我们的 ICMP 实验。 您可能还记得Ping 程序是一个简单的工具，允许任何人(例如:网络管理员)验证主机是否存在。 源主机中的 Ping 程序将数据包发送到目标 IP 地址; 如果目标是在线的，则目标主机中的 Ping 程序将会发送响应 Ping 数据包证明他在线，这两个 Ping 数据包都是 ICMP 数据包。 因此您可能猜出我们这个实验都是关于 ICMP 的实验了。</p><p>Do the following: 请按照以下动作做:</p><ul><li><p>Let’s begin this adventure by opening the Windows Command Prompt application (which can be found in your Accessories folder).<br> 打开 windows 的命令提示符。</p></li><li><p>Start up the Wireshark packet sniffer, and begin Wireshark packet capture. 启动 Wireshark 数据包嗅探器，并开始 Wireshark 数据包捕获。</p></li><li><p>The ping command is in c:\windows\system32, so type either “ping –n 10 hostname” or “c:\windows\system32\ping –n 10 hostname” in the MS-DOS command line (without quotation marks), where hostname is a host on another continent. If you’re outside of Asia, you may want to enter <a href="http://www.ust.hk/">www.ust.hk</a> for the Web server at Hong Kong University of Science and Technology. The argument “-n 10” indicates that 10 ping messages should be sent. Then run the Ping program by typing return.</p></li></ul><p>  Ping 程序在 c:\windows\system32 目录中，所以您在命令提示符中输入“ping –n 10 hostname” 或 “c:\windows\system32\ping –n 10 hostname”都是正确的 (注意命令是引号里的内容)。其中 hostname 是另一个大陆的主机名。如 您如果在非亚洲地区，建议您访问香港科技大学 <a href="http://www.ust.hk/">www.ust.hk</a> ， 参数-n 10 代表发送 10 个 Ping 消息，然后按下回车执行命令。</p><ul><li>When the Ping program terminates, stop the packet capture in Wireshark. 当 Ping 程序终止时，停止在 Wireshark 中捕获数据包。</li></ul><p>At the end of the experiment, your Command Prompt Window should look something like Figure 1. In this example, the source ping program is in Massachusetts and the destination Ping program is in Hong Kong. From this window we see that the source ping program sent 10 query packets and received 10 responses. Note also that for each response, the source calculates the round-trip time (RTT), which for the 10 packets is on average 375 msec.</p><p>在实验结束时，您的命令提示符窗口应如图 1 所示。在此示例中，源 ping 程序位 于马萨诸塞州，目标 Ping 程序位于香港。 从这个窗口我们看到源 ping 程序发送了10 个查询包并收到了 10 个响应。 另请注意，对于每个响应，源计算往返时间 (RTT)，对于 10 个数据包平均为 375 毫秒。</p><p><img src="/Wireshark-Lab-ICMP/image-20230505125410545.png" alt="image-20230505125410545"></p><p>Figure 2 provides a screenshot of the Wireshark output, after “icmp” has been entered into the filter display window. Note that the packet listing shows 20 packets: the 10 Ping queries sent by the source and the 10 Ping responses received by the source. Also note that the source’s IP address is a private address (behind a NAT) of the form 192.168&#x2F;12; the destination’s IP address is that of the Web server at HKUST. Now let’s zoom in on the first packet (sent by the client); in the figure below, the packet contents area provides information about this packet. We see that the IP datagram within this packet has protocol number 01, which is the protocol number for ICMP. This means that the payload of the IP datagram is an ICMP packet.<br> 如图 2，在将“icmp”输入过滤器显示窗口后 Wireshark 输出的屏幕截图。 请注意，</p><p>数据包列表显示 20 个数据包:源发送的 10 个 Ping 查询和源接收的 10 个 Ping 响 应。 另请注意，源的 IP 地址是 192.168 &#x2F; 12 格式的私有地址(通过 NAT 协议连接 互联网); 目的地的 IP 地址是香港科技大学网络服务器的 IP 地址。 现在让我们点 击显示第一个由客户端发送的数据包; 在图中的下方，数据包内容区域提供有关此 数据包的信息。 我们看到该数据包中的 IP 数据报具有协议号 01，这是 ICMP 的协 议号。 这意味着 IP 数据报的有效载荷是 ICMP 数据包</p><p><img src="/Wireshark-Lab-ICMP/image-20230505110353038.png" alt="image-20230505110353038"></p><center>图 2 在 Wireshark 中过滤 ICMP 协议并且选中某个 ICMP 消息<center/><p>Figure 3 focuses on the same ICMP but has expanded the ICMP protocol information in the packet contents window. Observe that this ICMP packet is of Type 8 and Code 0 - a so-called ICMP “echo request” packet. (See Figure 5.19 of text.) Also note that this ICMP packet contains a checksum, an identifier, and a sequence number.</p><p>图 3 同样使用相同的 ICMP 过滤器，展开可以看到该 ICMP 包的详情信息。 观察到 该 ICMP 数据包是类型 8 和代码 0 ——所谓的 ICMP“回应请求”数据包。 (请参见 书本的图 5.19。)此外，此 ICMP 数据包包含校验和，标识符和序列号</p><p><img src="/Wireshark-Lab-ICMP/image-20230505110809611.png" alt="image-20230505110809611"></p><h2 id="What-to-Hand-In-回答问题"><a href="#What-to-Hand-In-回答问题" class="headerlink" title="What to Hand In: 回答问题"></a>What to Hand In: 回答问题</h2><p>You should hand in a screen shot of the Command Prompt window similar to Figure 1 above. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question.</p><p>请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该<br>简单可读。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ping -c 10 bing.com &#x2F;&#x2F; [-c count] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>You should answer the following questions: 请回答以下问题:</p><ol><li>What is the IP address of your host? What is the IP address of the destination host? 您的主机的 IP 地址是多少? 目标主机的 IP 地址是多少?</li></ol><p><img src="/Wireshark-Lab-ICMP/image-20230505125749494.png" alt="image-20230505125749494"></p><ol><li>Why is it that an ICMP packet does not have source and destination port numbers? 为什么 ICMP 数据包没有源端口号和目的端口号?</li></ol><p><strong>大多数TCP&#x2F;IP实现直接在操作系统中支持ping服务器, 即该服务器不是一个进程.</strong></p><p>ICMP（Internet Control Message Protocol）数据包没有源端口号和目的端口号，因为ICMP不像TCP（传输控制协议）或UDP（用户数据报协议）那样是传输层协议。相反，ICMP是一种直接在IP（Internet Protocol）层之上运行的网络层协议。</p><p>TCP和UDP使用源和目的地端口号来在同一设备上运行的不同应用程序之间进行多路复用和解复用数据。然而，ICMP不用于传输应用程序数据，而是用于在网络设备之间传递错误消息和网络状态信息。因此，ICMP消息并不是针对设备上的特定端口而言的，而是针对设备本身的。</p><p>ICMP消息包含类型、代码和校验和等字段，这些字段用于指示消息的目的和内容。这些字段允许网络设备适当地解释和响应ICMP消息。例如，当从一个设备发送ping命令到另一个设备时，ping数据包包含一个ICMP回显请求消息，这促使接收设备向发送方发送一个ICMP回显回复消息。ICMP数据包中缺少源和目的端口号是由于这些信息对协议的运行不必要。</p><ol><li>Examine one of the ping request packets sent by your host. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields? 查看任意的请求 ICMP 数据包， ICMP 类型和代码是什么? 该 ICMP 数据包还有哪些其他字段? 校验和，序列号和标识符字段有多少字节?</li></ol><p><strong>Type: 8 code: 0 回显请求</strong>。还包括<strong>检验和(2 Byte)</strong>, <strong>id(2 Byte)</strong>, <strong>sequence number(2 Byte)</strong></p><p><img src="/Wireshark-Lab-ICMP/image-20230505131005238.png" alt="image-20230505131005238"></p><p><img src="/Wireshark-Lab-ICMP/image-20230505140604234.png" alt="image-20230505140604234"></p><ol><li>Examine the corresponding ping reply packet. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields?<br> 查看任意的响应 ICMP 数据包， ICMP 类型和代码是什么? 该 ICMP 数据包<br> 还有哪些其他字段? 校验和，序列号和标识符字段有多少字节?</li></ol><p>Type: 0(Echo reply)   </p><p>Code : 0 </p><p>还包括<strong>检验和(2 Byte)</strong>, <strong>id(2 Byte)</strong>, <strong>sequence number</strong><strong>(2 Byte</strong>)</p><p><img src="/Wireshark-Lab-ICMP/image-20230505140719354.png" alt="image-20230505140719354"></p><h2 id="ICMP-and-Traceroute-ICMP-协议和-Traceroute-命令"><a href="#ICMP-and-Traceroute-ICMP-协议和-Traceroute-命令" class="headerlink" title="ICMP and Traceroute ICMP 协议和 Traceroute 命令"></a>ICMP and Traceroute ICMP 协议和 Traceroute 命令</h2><p>Let’s now continue our ICMP adventure by capturing the packets generated by the Traceroute program. You may recall that the Traceroute program can be used to figure out the path a packet takes from source to destination. Traceroute is discussed in Section 1.4 and in Section 5.6 of the text.<br>现在让我们通过捕获 Traceroute 程序生成的数据包继续我们的 ICMP 实验。 您可能<br>还记得 Traceroute 程序可用于确定数据包从源到目的地的路径。 Traceroute 命令可 以在课本中的 1.4 节和 5.6 节中找到  </p><p>Traceroute is implemented in different ways in Unix&#x2F;Linux&#x2F;MacOS and in Windows. In Unix&#x2F;Linux, the source sends a series of UDP packets to the target destination using an unlikely destination port number; in Windows, the source sends a series of ICMP packets to the target destination. For both operating systems, the program sends the first packet with TTL&#x3D;1, the second packet with TTL&#x3D;2, and so on. Recall that a router will decrement a packet’s TTL value as the packet passes through the router. When a packet arrives at a router with TTL&#x3D;1, the router sends an ICMP error packet back to the source. In the following, we’ll use the native Windows tracert program. A shareware version of a much nice Windows Traceroute program is pingplotter (<a href="http://www.pingplotter.com/">www.pingplotter.com</a>). We’ll use pingplotter in our Wireshark IP lab since it provides additional functionality that we’ll need there.<br>每个系统有不同路由跟踪实现办法，在 Unix &#x2F; Linux 中，路由跟踪 traceroute 使用 发送不可到达(无使用的)端口的 <strong>UDP</strong> 包来实现，在 Windows 中，路由跟踪 tracert 仅使用 <strong>ICMP</strong> 数据包来实现，但是对于他们来说，都是发送 TTL 增加的数据 包，例如 TTL&#x3D;1,TTL&#x3D;2，回想下，每经过一个路由器，TTL 就会减一，<strong>当 TTL&#x3D;1 的包达到路由器，该路由器会将该包丢弃，并且发送 ICMP 错误给请求的机器</strong>，在 本次实验，我们使用 window 自带的 tracert。有一个跨平台 Windows Traceroute 程序的是 pingplotter(<a href="http://www.pingplotter.com)(收费但可以试用)./">www.pingplotter.com)(收费但可以试用)。</a> 我们将在 Wireshark IP 实验室中使用 pingplotter，因为它提供了我们在那里需要的其他功能。</p><p>Do the following4: 请执行以下步骤</p><ul><li><p>Let’s begin by opening the Windows Command Prompt application (which can be found in your Accessories folder).<br> 打开 windows 的命令提示符。</p></li><li><p>Start up the Wireshark packet sniffer, and begin Wireshark packet capture. 启动 Wireshark 数据包嗅探器，并开始 Wireshark 数据包捕获。</p></li><li><p>The tracert command is in c:\windows\system32, so type either “tracert hostname” or “c:\windows\system32\tracert hostname” in the MS-DOS command line (without quotation marks), where hostname is a host on another continent. (Note that on a Windows machine, the command is “tracert” and not “traceroute”.) If you’re outside of Europe, you may want to enter <a href="http://www.inria.fr/">www.inria.fr</a> for the Web server at INRIA, a computer science research institute in France. Then run the Traceroute program by typing return.<br>tracert 程序在 c:\windows\system32 目录中，所以您在命令提示符中输入</p><p>“tracert hostname” 或 “c:\windows\system32\ tracert hostname”都是正确的(注 意命令是引号里的内容)。其中 hostname 是另一个大陆的主机名。如您如 果在非欧洲地区，建议您访问法国 INRIA(计算机科学研究所) <a href="http://www.inria.fr/">www.inria.fr</a> 然后按下回车执行命令。</p></li><li><p>When the Traceroute program terminates, stop packet capture in Wireshark. 当 Traceroute 程序终止时，停止在 Wireshark 中捕获数据包。</p><p>At the end of the experiment, your Command Prompt Window should look something like Figure 4. In this figure, the client Traceroute program is in Massachusetts and the target destination is in France. From this figure we see that for each TTL value, the</p></li></ul><p>source program sends three probe packets. Traceroute displays the RTTs for each of the probe packets, as well as the IP address (and possibly the name) of the router that returned the ICMP TTL-exceeded message. 在实验结束时，您的命令提示符窗口应如图 4 所示。在此图中，客户端 Traceroute程序主机位于马萨诸塞州，目标主机位于法国。 从该图中我们看到，对于每个 TTL 值，源程序发送三个探测包。 Traceroute 显示每个探测包的 RTT，以及返回 ICMP TTL 超出消息的路由器的 IP 地址(可能还有名称)。</p><p><img src="/Wireshark-Lab-ICMP/image-20230505111220401.png" alt="image-20230505111220401"></p><p>Figure 5 displays the Wireshark window for an ICMP packet returned by a router. Note that this ICMP error packet contains many more fields than the Ping ICMP messages.<br> 图 5 显示了路由器返回的 ICMP 数据包的 Wireshark 窗口。 请注意，此 ICMP 错误数据包包含的字段比 Ping ICMP 消息多得多。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/Wireshark-Lab-ICMP/image-20230505111244920.png" alt="image-20230505111244920"></h2><p> If you are unable to run Wireshark live on a computer, you can download the zip file <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a> and extract the file ICMP-ethereal-trace-2. The traces in this zip file were collected by Wireshark running on one of the author’s computers, while performing the steps indicated in the Wireshark lab. Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the ICMP-ethereal-trace-2 trace file. You can then use this trace file to answer the questions below. 同样如果您无法抓包，建议您下载作者的抓包结果 <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a> 解压并且使用 Wireshark 打开 ICMP-ethereal-trace-2 进行分析。</p><hr><h2 id="What-to-Hand-In-回答问题-1"><a href="#What-to-Hand-In-回答问题-1" class="headerlink" title="What to Hand In: 回答问题"></a>What to Hand In: 回答问题</h2><p>For this part of the lab, you should hand in a screen shot of the Command Prompt window. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读</p><p>Answer the following questions: 请回答以下问题:</p><ol><li><p>What is the IP address of your host? What is the IP address of the target destination host?<br> 您的主机的 IP 地址是多少? 目标目标主机的 IP 地址是多少?</p></li><li><p>If ICMP sent UDP packets instead (as in Unix&#x2F;Linux), would the IP protocol number still be 01 for the probe packets? If not, what would it be?<br> 如果 ICMP 发送了 UDP 数据包(如在 Unix &#x2F; Linux 中)，那么探测数据包的 IP 协议号仍然是 01 吗? 如果没有，它会是什么?</p></li></ol><p><img src="/Wireshark-Lab-ICMP/image-20230505141720372.png" alt="image-20230505141720372"></p><ol><li>Examine the ICMP echo packet in your screenshot. Is this different from the ICMP ping query packets in the first half of this lab? If yes, how so? 检查屏幕截图中的 ICMP 响应数据包。 这与本实验的前半部分中的 ICMP ping 查询数据包不同吗? 如果不同，请解释为什么?</li></ol><p><img src="/Wireshark-Lab-ICMP/image-20230505141845947.png" alt="image-20230505141845947"></p><p>该ICMP Message Type:11 Code: 0 , 路由器告诉源主机你的分组由于TTL减为0被我丢掉了(Time-to-live exceeded), 这是Ping和treaceroute程序的工作原理不同导致的, Ping程序发送请求回显报文, 目标主机收到后回复(回显回答), 而traceroute程序通过发送TTL从1递增的UPD数据报来获得路由信息. </p><ol><li>Examine the ICMP error packet in your screenshot. It has more fields than the ICMP echo packet. What is included in those fields?<br>检查屏幕截图中的 ICMP 错误数据包。 它具有比 ICMP 响应数据包更多的字段。 这个数据包含哪些内容?</li></ol><p><img src="/Wireshark-Lab-ICMP/image-20230505142419713.png" alt="image-20230505142419713"></p><p>多了IP头部, IP头部包含了被丢弃的IP数据报的头部字段</p><ol><li>Examine the last three ICMP packets received by the source host. How are these packets different from the ICMP error packets? Why are they different? 检查源主机收到的最后三个 ICMP 数据包。 这些数据包与 ICMP 错误数据包有何不同? 他们为什么不同?</li></ol><p>找不到…最后都没有收到, 但我还是说几句. 这些同为ICMP数据包, 但TYPE和Code字段的字不同, Type:3 Code:3 目标主机告诉源主机目标端口不可达, 这是因为treaceroute程序发送了不可达的端口</p><p><img src="/Wireshark-Lab-ICMP/image-20230505143521010.png" alt="image-20230505143521010"></p><ol><li><p>Within the tracert measurements, is there a link whose delay is significantly longer than others? Refer to the screenshot in Figure 4, is there a link whose delay is significantly longer than others? On the basis of the router names, can you guess the location of the two routers on the end of this link?</p><p>在 tracert 跟踪测量中，是否有一个连接的延迟比其他连接长得多? 请参阅 图 4 中的屏幕截图，是否有连接的延迟明显长于其他连接? 根据路由器名 称，您能猜出这个连接末端的两个路由器的位置吗?</p></li></ol><p>可以发现TTL为6和为10时, 延迟变化很大, 通过best trace程序发现, 这两个路由器的位置分别是中国北京和德国，黑森州，法兰克福，</p><img src="Wireshark-Lab-ICMP/image-20230505144758780.png" alt="image-20230505144758780" style="zoom:50%;" /><p><img src="/Wireshark-Lab-ICMP/image-20230505145146382.png" alt="image-20230505145146382"></p><h2 id="Extra-Credit-额外问题"><a href="#Extra-Credit-额外问题" class="headerlink" title="Extra Credit 额外问题"></a>Extra Credit 额外问题</h2><p>For one of the programming assignments you created a UDP client ping program. This ping program, unlike the standard ping program, sends UDP probe packets rather than ICMP probe packets. Use the client program to send a UDP packet with an unusual destination port number to some live host. At the same time, use Wireshark to capture any response from the target host. Provide a Wireshark screenshot for the response as well as an analysis of the response.</p><p>对于一个编程任务，您可能创建了一个 UDP 客户端 ping 程序。 与标准 ping 程序 不同，此 ping 程序发送 UDP 探测包而不是 ICMP 探测包。 使用客户端程序将具有 异常目标端口号的 UDP 数据包发送到某个活动主机。 同时，使用 Wireshark 捕获 目标主机的任何响应。 提供响应的 Wireshark 屏幕截图以及响应分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;In this lab, we’ll explore several aspects of the ICMP protocol:&lt;br&gt;在本实验中，我们将探讨 ICMP 协议的几个方面:&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="computer network" scheme="https://trevoewu.github.io/tags/computer-network/"/>
    
    <category term="lab" scheme="https://trevoewu.github.io/tags/lab/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark Lab: DNS</title>
    <link href="https://trevoewu.github.io/2023/04/21/Wireshark-Lab-DNS/"/>
    <id>https://trevoewu.github.io/2023/04/21/Wireshark-Lab-DNS/</id>
    <published>2023-04-21T13:05:21.000Z</published>
    <updated>2023-04-21T13:18:17.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong>官方英文文档：<a href="Wireshark_Intro_v6.01.pdf">Wireshark_Intro_v6.01.pdf</a></strong>  </p><p><strong>以下内容为笔者翻译：</strong></p><hr><h2 id="Wireshark-实验-DNS-v6-01"><a href="#Wireshark-实验-DNS-v6-01" class="headerlink" title="Wireshark 实验:  DNS v6.01"></a>Wireshark 实验:  DNS v6.01</h2><p><strong>《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross</strong></p><p>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 </p><p>© 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved</p><hr><p>如书中第2.5节所述，域名系统(DNS)将主机名转换为IP地址，在互联网基础架构中发挥关键作用。在本实验中，我们将仔细查看DNS在客户端的细节。回想一下，客户端在DNS中的角色相对简单——客户端向其本地DNS服务器发送<em>请求</em>，并接收一个<em>响应</em>。如书中的图2.21和2.22所示，由于DNS分层服务器之间相互通信，可以递归地或迭代地解析客户端的DNS查询请求，而大多数操作是不可见的。然而，从DNS客户端的角度来看，协议非常简 ——将查询指向为本地DNS服务器，并从该服务器接收到响应。</p><p>在开始本实验之前，您可能需要阅读书中的第2.5节来了解DNS。另外，您可能需要查看关于<strong>本地DNS服务器，DNS缓存，DNS记录和消息，以及DNS记录中的TYPE字段</strong>的资料。</p><h3 id="1-nslookup"><a href="#1-nslookup" class="headerlink" title="1. nslookup"></a>1. nslookup</h3><p>在本实验中，我们将大量使用<em>nslookup</em>工具，这个工具在现在的大多数Linux&#x2F;Unix和Microsoft平台中都有。要在Linux&#x2F;Unix中运行<em>nslookup</em>，您只需在命令行中键入<em>nslookup</em>命令即可。要在Windows中运行，请打开命令提示符并在命令行上运行<em>nslookup</em>。</p><p>在这是最基本的操作，<em>nslookup</em>工具允许主机查询任何指定的DNS服务器的DNS记录。DNS服务器可以是根DNS服务器，顶级域DNS服务器，权威DNS服务器或中间DNS服务器（有关这些术语的定义，请参阅书本）。要完成此任务，<em>nslookup</em>将DNS查询发送到指定的DNS服务器，然后接收DNS回复，并显示结果。</p><p>上面的屏幕截图显示了三个不同<em>nslookup</em>命令的结果（显示在Windows命令提示符中）。在此示例中，客户端主机位于布鲁克林理工大学校园，默认本地DNS服务器为dns-prime.poly.edu。运行nslookup时，如果没有指定DNS服务器，则<em>nslookup</em>会将查询发送到默认的DNS服务器（在这种情况下为dnsprime.poly.edu）。来看第一个命令：</p><p><code>nslookup www.mit.edu</code></p><p>说这个命令是说，请告诉我主机 <a href="http://www.mit.edu/">www.mit.edu</a> 的IP地址。如屏幕截图所示，此命令的响应提供两条信息：（1）提供响应的DNS服务器的名称和IP地址；（2）响应本身，即 <a href="http://www.mit.edu/">www.mit.edu</a> 的主机名和IP地址。虽然响应来自理工大学的本地DNS服务器，但本地DNS服务器很可能会迭代地联系其他几个DNS服务器来获得结果，如书中第2.4节所述。</p><p>现在来看第二个命令：</p><p><code>nslookup -type=NS mit.edu</code></p><p>在这个例子中，我们添加了选项”-type&#x3D;NS”和域名”mit.edu”。这将使得<em>nslookup</em>将NS记录发送到默认的本地DNS服务器。换句话说，“请给我发送mit.edu的权威DNS的主机名” （当不使用-type选项时，<em>nslookup</em>使用默认值，即查询A类记录。）上述屏幕截图中，首先显示了提供响应的DNS服务器（这是默认本地DNS服务器）以及三个MIT域名服务器。这些服务器中的每一个确实都是麻省理工学院校园主机的权威DNS服务器。然而，<em>nslookup</em>也表明该响应是非权威的，这意味着这个响应来自某个服务器的缓存，而不是来自权威MIT DNS服务器。最后，响应结果还显示了麻省理工学院权威DNS服务器的IP地址。 （即使<em>nslookup</em>生成的NS类型查询没有明确要求IP地址，本地DNS服务器依然”免费“返回了这些信息，然后被<em>nslookup</em>显示出来。）</p><p>最后来看第三个命令：</p><p><code>nslookup www.aiit.or.kr bitsy.mit.edu</code></p><p>在这个例子中，我们希望将查询请求发送到DNS服务器 bitsy.mit.edu ，而不是默认的DNS服务器（dns-prime.poly.edu）。因此，查询和响应事务直接发生在我们的主机和 bitsy.mit.edu 之间。在这个例子中，DNS服务器 bitsy.mit.edu 提供主机 <a href="http://www.aiit.or.kr/">www.aiit.or.kr</a> 的IP地址，它是高级信息技术研究所（韩国）的Web服务器。</p><p>现在我们了解了一些示例，您现在可能想知道<em>nslookup</em>命令的一般语法。语法是：</p><p><code>nslookup -option1 -option2 host-to-find dns-server</code></p><p>一般来说，<em>nslookup</em>可以不添加选项，或者添加一两个甚至更多选项。正如我们在上面的示例中看到的，dns-server也是可选的；如果这项没有提供，查询将发送到默认的本地DNS服务器。</p><p>现在我们提供了总览了<em>nslookup</em>，现在是你自己驾驭它的时候了。执行以下操作（并记下结果）：</p><ol><li><p>运行<em>nslookup</em>以获取一个亚洲的Web服务器的IP地址。该服务器的IP地址是什么？</p><p><img src="/Wireshark-Lab-DNS/image-20230421210837297.png" alt="image-20230421210837297"></p><p>查询了哈尔滨理工大学的ip地址, 通过得到的信息可以知道, 该服务器的IP地址为202.118.201.1</p><p>可以发现这是一个来自DNS服务器182.254.116.116的应答, 搜索发现, 这是腾讯的备用域名服务器. </p><p><img src="/Wireshark-Lab-DNS/image-20230421210846142.png" alt="image-20230421210846142"></p><p>继续查询权威名字服务器, 得到的是非权威的, 这是因为腾讯的DNS服务器不知道哈尔滨理工大学的权威名字服务器, 只能向根DNS→TLD(顶级域DNS)(.cn)→edu.cnDNS→hrbust.edu.cnDNS, 迭代查询获得</p><p>如果我们之间对这个DNS服务器发起DNS查询:</p><p> <img src="/Wireshark-Lab-DNS/image-20230421210900650.png" alt="image-20230421210900650"></p><p>可以发现, 这样一条来自权威名字服务器的应答. </p></li><li><p>运行<em>nslookup</em>来确定一个欧洲的大学的权威DNS服务器。</p><p>查询了苏黎世联邦理工大学的权威DNS</p></li></ol><p><img src="/Wireshark-Lab-DNS/image-20230421210910755.png" alt="image-20230421210910755"></p><p>可以发现权威名字服务器为: ns1.ethz.ch</p><ol><li>运行<em>nslookup</em>，使用问题2中一个已获得的DNS服务器，来查询Yahoo!邮箱的邮件服务器。它的IP地址是什么？</li></ol><p><img src="/Wireshark-Lab-DNS/image-20230421210921960.png" alt="image-20230421210921960"></p><p>查不到好吧….人家是大学的权威DNS, 没有雅虎的邮件服务器地址, 只维护了大学的IP地址查询, 不当然公共DNS的指责, 即不去迭代的查询(个人猜测)</p><p>又到了问聪明的chatGPT的时间了: </p><p><img src="/Wireshark-Lab-DNS/image-20230421211212041.png" alt="image-20230421211212041"></p><p><img src="/Wireshark-Lab-DNS/image-20230421210930573.png" alt="image-20230421210930573"></p><p>使用腾讯的公共DNS服务器我们可以得到Yahoo的邮件服务器地址.</p><p>同时为发现查询<code>www.mail.yahoo.com</code>和mail.yahoo.com的结果不同</p><p><img src="/Wireshark-Lab-DNS/image-20230421211245869.png" alt="image-20230421211245869"></p><p>查询chatGPT得到以下回复: </p><p><img src="/Wireshark-Lab-DNS/image-20230421211255078.png" alt="image-20230421211255078"></p><h3 id="2-ipconfig"><a href="#2-ipconfig" class="headerlink" title="2. ipconfig"></a>2. ipconfig</h3><p><em>ipconfig</em>（对于Windows）和<em>ifconfig</em>（对于Linux &#x2F; Unix）是主机中最实用的程序，尤其是用于调试网络问题时。这里我们只讨论<em>ipconfig</em>，尽管Linux &#x2F; Unix的<em>ifconfig</em>与其非常相似。 <em>ipconfig</em>可用于显示您当前的TCP&#x2F;IP信息，包括您的地址，DNS服务器地址，适配器类型等。例如，您只需进入命令提示符，输入</p><p><code>ipconfig /all</code></p><p><em>ipconfig</em>对于管理主机中存储的DNS信息也非常有用。在第2.5节中，我们了解到主机可以缓存最近获得的DNS记录。要查看这些缓存记录，在 C:\&gt; 提示符后输入以下命令：</p><p><code>ipconfig /displaydns</code></p><p>每个条目显示剩余的生存时间（TTL）（秒）。要清除缓存，请输入</p><p><code>ipconfig /flushdns</code></p><p>清除了所有条目并从hosts文件重新加载条目。</p><h3 id="3-使用Wireshark追踪DNS"><a href="#3-使用Wireshark追踪DNS" class="headerlink" title="3. 使用Wireshark追踪DNS"></a>3. 使用Wireshark追踪DNS</h3><p>现在，我们熟悉<code>nslookup</code>和<code>ipconfig</code>，我们准备好了一些正经的事情。首先让我们捕获一些由常规上网活动生成的DNS数据包。</p><ul><li>使用<em>ipconfig</em>清空主机中的DNS缓存。</li><li>打开浏览器并清空浏览器缓存。 （若使用Internet Explorer，转到<strong>工具</strong>菜单并选择<strong>Internet选项</strong>；然后在<strong>常规</strong>选项卡中选择删除文件。）</li><li>打开Wireshark，然后在过滤器中输入“ip.addr&#x3D;&#x3D;your_IP_address”，您可以先使用<em>ipconfig</em>获取你的IP地址。此过滤器将删除既从你主机不发出也不发往你主机的所有数据包。</li><li>在Wireshark中启动数据包捕获。</li><li>使用浏览器访问网页： <a href="http://www.ietf.org/">http://www.ietf.org</a></li><li>停止数据包捕获。</li></ul><p>如果您无法在你的网络连接上运行Wireshark，则可以下载一个捕获了数据包的文件，这个文件是本书作者在自己计算机上 按照上述步骤捕获的（原文注：Download the zip file <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a> and extract the file dnsethereal-trace-1. The traces in this zip file were collected by Wireshark running on one of the author’s computers, while performing the steps indicated in the Wireshark lab. Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the dns-ethereal-trace-1 trace file. ）。回答下列问题。您应该在解答中尽可能展示你使用了哪些你捕获到的数据包，并注释出来（原文注：What do we mean by “annotate”? If you hand in a paper copy, please highlight where in the printout you’ve found the answer and add some text (preferably with a colored pen) noting what you found in what you ‘ve highlight. If you hand in an electronic copy, it would be great if you could also highlight and annotate. ）。若要打印数据包，请使用<em>文件</em>-&gt;<em>打印</em>，只勾选<em>仅选中分组</em>，和<em>概要行</em>，并选中你所需要用于解答问题的数据包。</p><ol start="4"><li><p>找到DNS查询和响应消息。它们是否通过UDP或TCP发送？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211313407.png" alt="image-20230421211313407"></p><p>通过UDP发送</p></li><li><p>DNS查询消息的目标端口是什么？ DNS响应消息的源端口是什么？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211321920.png" alt="image-20230421211321920"></p><p>目标端口通过上一问的图片可以得到为: 53, 响应DNS到源端口也是53</p></li><li><p>DNS查询消息发送到哪个IP地址？使用ipconfig来确定本地DNS服务器的IP地址。这两个IP地址是否相同？</p><p>本地IP 地址: 10.51.172.226</p><p>DNS服务器IP地址: 182.254.116.116</p><p>相同 </p><p><img src="/Wireshark-Lab-DNS/image-20230421211341608.png" alt="image-20230421211341608"></p></li><li><p>检查DNS查询消息。DNS查询是什么”Type”的？查询消息是否包含任何”answers”？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211351099.png" alt="image-20230421211351099"></p><p>TYPE: A</p><p>不包含</p></li><li><p>检查DNS响应消息。提供了多少个”answers”？这些答案具体包含什么？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211359997.png" alt="image-20230421211359997"></p><p>三个answer</p><p>第一个answer: TYPE CNAME, 主机别名到规范主机名的对应关系</p><p><img src="/Wireshark-Lab-DNS/image-20230421211409785.png" alt="image-20230421211409785"></p><p>包含NAME(域名),TYPE, Class, TTL, Data. CNAME(规范主机名)</p><p>第二个answer: TYPE A, 域名和IP地址</p><p><img src="/Wireshark-Lab-DNS/image-20230421211422241.png" alt="image-20230421211422241"></p><p>得到了规范主机名的IP地址</p><p>第三个answer: </p><p><img src="/Wireshark-Lab-DNS/image-20230421211431684.png" alt="image-20230421211431684"></p><p>另一个规范主机名的IP地址</p></li><li><p>考虑从您主机发送的后续TCP SYN数据包。 SYN数据包的目的IP地址是否与DNS响应消息中提供的任何IP地址相对应？</p><p>直接过滤ip.addr&#x3D;&#x3D;104.16.44.99</p><p>结果如下: </p><p><img src="/Wireshark-Lab-DNS/image-20230421211445058.png" alt="image-20230421211445058"></p><p>可以发现我的主机向这个IP地址发起了TCP的链接请求</p></li><li><p>这个网页包含一些图片。在获取每个图片前，您的主机是否都发出了新的DNS查询？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211456062.png" alt="image-20230421211456062"></p><p>有一个对r3.o.lencr.org的DNS查询, 搜索发现这是一个恶意的软件发起的, 目的是给浏览器带来广告(服了….)</p><p><img src="/Wireshark-Lab-DNS/image-20230421211504325.png" alt="image-20230421211504325"></p></li></ol><p>现在让我们玩玩<em>nslookup</em>（原文注：If you are unable to run Wireshark and capture a trace file, use the trace file dns-ethereal-trace-2 in the zip file <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a>  ）。</p><ul><li>启动数据包捕获。</li><li>使用nslookup查询 <a href="http://www.mit.edu/">www.mit.edu</a> </li><li>停止数据包捕获。</li></ul><p>我们从上面的屏幕截图看到，<em>nslookup</em>实际上发送了三个DNS查询，并收到了三个DNS响应。只考虑本次实验相关结果，在回答以下问题时，请忽略前两组查询&#x2F;响应，因为<em>nslookup</em>的一些特殊性，这些查询通常不是由标准网络应用程序生成的。您应该专注于最后一个查询和响应消息。</p><ol start="11"><li><p>DNS查询消息的目标端口是什么？ DNS响应消息的源端口是什么？</p><p>查询:</p><p><img src="/Wireshark-Lab-DNS/image-20230421211516046.png" alt="image-20230421211516046"></p><p>响应: </p><p><img src="/Wireshark-Lab-DNS/image-20230421211522148.png" alt="image-20230421211522148"></p></li><li><p>DNS查询消息的目标IP地址是什么？这是你的默认本地DNS服务器的IP地址吗？</p><p>是的</p><p><img src="/Wireshark-Lab-DNS/image-20230421211532903.png" alt="image-20230421211532903"></p></li><li><p>检查DNS查询消息。DNS查询是什么”Type”的？查询消息是否包含任何”answers”？</p></li><li><p>TYPE A, 不包含</p><p><img src="/Wireshark-Lab-DNS/image-20230421211545749.png" alt="image-20230421211545749"></p></li><li><p>检查DNS响应消息。提供了多少个”answers”？这些答案包含什么？</p><p>三个</p><p><img src="/Wireshark-Lab-DNS/image-20230421211557865.png" alt="image-20230421211557865"></p><p>包含主机别名到规范主机名的转化关系(TYPE:CNAME)</p><p>规范主机名到IP地址到转换关系</p></li></ol><p>现在重复上一个实验，但换成以下命令：</p><p><code>nslookup -type=NS mit.edu</code></p><p>回答下列问题：</p><ol start="16"><li><p>DNS查询消息发送到的IP地址是什么？这是您的默认本地DNS服务器的IP地址吗？</p><p>是的</p><p><img src="/Wireshark-Lab-DNS/image-20230421211610171.png" alt="image-20230421211610171"></p></li><li><p>检查DNS查询消息。DNS查询是什么”Type”的？查询消息是否包含任何”answers”？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211621477.png" alt="image-20230421211621477"></p><p>Type: NS</p><p>不包含</p></li><li><p>检查DNS响应消息。响应消息提供的MIT域名服务器是什么？此响应消息还提供了MIT域名服务器的IP地址吗？</p><p>![image-20230416184356921](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416184356921.png)</p></li></ol><p>现在重复上一个实验，但换成以下命令：</p><p><code>nslookup www.aiit.or.kr bitsy.mit.edu</code></p><p><strong>该DNS服务器已停用</strong>, 使用作者提供的抓包结果dns-ethereal-trace-4</p><p>回答下列问题：</p><ol start="20"><li><p>DNS查询消息发送到的IP地址是什么？这是您的默认本地DNS服务器的IP地址吗？如果不是，这个IP地址是什么？</p><p><img src="/Wireshark-Lab-DNS/image-20230421211639835.png" alt="image-20230421211639835"></p><p>理论上不是, 因为已经指定了对应的DNS服务器,目标IP地址应该是DNS服务器名字<code>bitsy.mit.edu</code> 的IP地址</p></li><li><p>检查DNS查询消息。DNS查询是什么”Type”的？查询消息是否包含任何”answers”？</p><p>第一个查询:</p><p><img src="/Wireshark-Lab-DNS/image-20230421211649155.png" alt="image-20230421211649155"></p><p>TYPE: PTR 通过IP反向查询域名</p><p>第二个查询: TYPE A, 查询<code>www.aiit.or.kr.poly.edu</code>的IP地址, 目标IP地址是18.72.0.3</p><p><img src="/Wireshark-Lab-DNS/image-20230421211656347.png" alt="image-20230421211656347"></p><p>第三个查询: TYPE A, 查询<code>www.aiit.or.kr</code>的IP地址, 目标IP和上一个查询相同.</p><p><img src="/Wireshark-Lab-DNS/image-20230421211702635.png" alt="image-20230421211702635"></p></li><li><p>检查DNS响应消息。提供了多少个”answers”？这些答案包含什么？</p><p>第一个响应: 提供了一个answer</p><p><img src="/Wireshark-Lab-DNS/image-20230421211713117.png" alt="image-20230421211713117"></p><p>TYPE:PTR</p><p>回答里包含IP地址3.0.72.18对应的域名</p><p>第二个响应: </p><p><img src="/Wireshark-Lab-DNS/image-20230421211730365.png" alt="image-20230421211730365"></p><p>TYPE: SOA(Start Of a zone of Authority)</p><p><img src="/Wireshark-Lab-DNS/image-20230421211748643.png" alt="image-20230421211748643"></p><p>响应结果为找不到:</p><p>第三个响应:</p><p><img src="/Wireshark-Lab-DNS/image-20230421211757311.png" alt="image-20230421211757311"></p><p>ansewer为目标域名的IP地址.</p></li></ol>]]></content>
    
    
    <summary type="html">域名系统(DNS)将主机名转换为IP地址，在互联网基础架构中发挥关键作用。在本实验中，我们将仔细查看DNS在客户端的细节。回想一下，客户端在DNS中的角色相对简单——客户端向其本地DNS服务器发送*请求*，并接收一个*响应*。如书中的图2.21和2.22所示，由于DNS分层服务器之间相互通信，可以递归地或迭代地解析客户端的DNS查询请求，而大多数操作是不可见的。然而，从DNS客户端的角度来看，协议非常简 ——将查询指向为本地DNS服务器，并从该服务器接收到响应</summary>
    
    
    
    <category term="学习" scheme="https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="computer cetwork" scheme="https://trevoewu.github.io/tags/computer-cetwork/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark Lab: TCP</title>
    <link href="https://trevoewu.github.io/2023/04/21/Wireshark-Lab-TCP/"/>
    <id>https://trevoewu.github.io/2023/04/21/Wireshark-Lab-TCP/</id>
    <published>2023-04-21T12:48:28.000Z</published>
    <updated>2023-04-21T13:04:35.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在本实验中，我们将详细研究著名的 TCP 协议的行为。 我们将通过从您的电脑向 远程服务器传输一份 150KB 的文件(一份 Lewis Carrol 的“爱丽丝梦游仙境”文本)，并分析 TCP 传输内容的发送和接收过程来实现。 我们将研究 TCP 对序列和 确认号的使用，以提供可靠的数据传输;我们将看到 TCP 的拥塞控制算法 – 慢启 动和拥塞避免 – 在过程中，我们将看看 TCP 的接收器发送流量控制的机制。 我们还将简要地观察 TCP 连线的设置，我们还会研究计算机和服务器之间 TCP 连线的性能(吞吐量和往返时间)。</p></blockquote><h2 id="A-first-look-at-the-captured-trace"><a href="#A-first-look-at-the-captured-trace" class="headerlink" title="A first look at the captured trace"></a>A first look at the captured trace</h2><ul><li><p>将文件传输到 gaia.cs.umass.edu 的客户端计算机使用的 IP 地址和 TCP 端口号是什么? </p></li><li><p>gaia.cs.umass.edu 的 IP 地址是什么? 在哪个端口号上发送和接收此连接的 TCP 段?</p></li></ul><p><img src="/Wireshark-Lab-TCP/image-20230421205628132.png" alt="image-20230421205628132"></p><p>Client IP Addressee: 10.51.172.226 Client Port: 61084<br>gaia.cs.umass.edu IP Address: 128.119.245.12</p><ul><li>客户端计算机将文件传输到 gaia.cs.umass.edu 所使用的 IP 地址和 TCP 端口号是多少?</li></ul><p><img src="/Wireshark-Lab-TCP/image-20230421205643562.png" alt="image-20230421205643562"></p><p>Client IP Addressee: 10.51.172.226 Client Port: 61084</p><ul><li>用于在客户端计算机和 gaia.cs.umass.edu 之间启动 TCP 连接的 TCP SYN 段的序列号是什么? 标识为 SYN 段的段有什么功能?</li></ul><p><img src="/Wireshark-Lab-TCP/image-20230421205702461.png" alt="image-20230421205702461"></p><p>如图, SYN序列号为<code>4095602682</code>, 标识为SYN的segment用于建立TCP链接</p><ul><li>gaia.cs.umass.edu 发送给客户端计算机以回复 SYN 的 SYNACK 段的序列号是多少?</li></ul><p><code>2017202044</code></p><p><img src="/Wireshark-Lab-TCP/image-20230421205716096.png" alt="image-20230421205716096"></p><p>SYNACK 段中的 Acknowledgment 栏位的值是多少? </p><p>为<code>4095602683</code></p><p><img src="/Wireshark-Lab-TCP/image-20230421205729437.png" alt="image-20230421205729437"></p><p><strong>观察到除了 SYN 标志位，ACK(Acknoledment)标志位也设 1，意思服务器接收到我约连按请求并且发 SYN-ACIK 确认，这是三次握手的第二步。</strong></p><p>Gaia.cs.umass.edu 是如何确定此 Acknowledgment 的数值的?</p><p>收到的$$seqence number + Len.$$</p><p> 在将段标识 为 SYNACK 段的段在连线中有什么功能?</p><p><img src="/Wireshark-Lab-TCP/image-20230421205757558.png" alt="image-20230421205757558"></p><p><strong>用于建立链接, 是三次握手的第二次, 表示同样连接请求</strong></p><ul><li>包含 HTTP POST 命令的 TCP 区段的序列号是多少?</li></ul><p><img src="/Wireshark-Lab-TCP/image-20230421205811084.png" alt="image-20230421205811084"></p><p>如图为<code>4095602683</code>,TCP PSH 字段设为1表示要传送数据.  HTTP的POST方法借助于TCP提供的服务实现, 在TCP中表现为TCP的PUSH字段设为1.</p><ul><li>将包含 HTTP POST 的 TCP 区段视为 TCP 连接中的第一个区段。在这个 TCP 连线中前六个 TCP 区段的序列号是什么(包括包含 HTTP POST的段 每区段发送的时间是什么时候? 收到的每个区段的 ACK 是什么时候?</li></ul><p>鉴于发送每个 TCP 区段的时间与收到确认的时间之间的差异，六个区段中每个区段的 RTT 值是多少?</p><p>如图是前6段的信息: </p><p><img src="/Wireshark-Lab-TCP/image-20230421205823688.png" alt="image-20230421205823688"></p><h3 id="第一段Frame1"><a href="#第一段Frame1" class="headerlink" title="第一段Frame1:"></a>第一段Frame1:</h3><p>(发送第一个frame,在 Wireshark中序号为frame69,这是Wireshark捕获到的序号, 由于这是发送数据的第一帧记frame1)</p><p><img src="/Wireshark-Lab-TCP/image-20230421205838620.png" alt="image-20230421205838620"></p><p>RTT: </p><p><em>note: 这里的Timestamps是Wireshark提供的额外的功能, 和TCP段Optionfields 里的Timestamps不同.</em> </p><p>通过Wireshark的分析, 可以知道IRTT(initial RTT 表示握手阶段的RTT)为0.39900200s</p><p><img src="/Wireshark-Lab-TCP/image-20230421205848826.png" alt="image-20230421205848826"></p><p>ACK(对第一个frame)的ACK</p><p><img src="/Wireshark-Lab-TCP/image-20230421205858659.png" alt="image-20230421205858659"></p><p>发现这里的ACK number &#x3D; 4095603435, 而seq1 的Next sequence &#x3D; 4095603298, 而恰好, frame2的Next sequence &#x3D; 4095603435</p><p><img src="/Wireshark-Lab-TCP/image-20230421205911880.png" alt="image-20230415112704099"></p><p><strong>所以这是对frame1和frame2的累计确认, 这是因为TCP 采用了延迟到ACK(delay ACK), 具有所期望的序号报文到达时, 等待一段时间(通常为40ms), 如果下一个按序报文到达, 立即发送单个累计ACK, 以确认两个按序到达的报文段. 如果下一个按序报文段没有在这个时间内到达, 则发送一个ACK.</strong></p><p>我们继续观察第一个报文段段Timestamps字段的值: </p><p><img src="/Wireshark-Lab-TCP/image-20230421205924206.png" alt="image-20230421205924206"></p><p>对比ACK1的Timestamps: </p><p><img src="/Wireshark-Lab-TCP/image-20230421205931912.png" alt="image-20230421205931912"></p><p>可以发现, 第一个报文段的TSval和ACK1的TimestampsTSerc相等, 进一步验证了之前的说法, 当接受到连续两个按序到达的报文时, 用于回复的ACK报文段段TSerc值的最早接受到的报文段的TSval, 这是为了对方更够更好的估算RTT. </p><p><strong>时间戳选项主要的功能有两个</strong>：</p><ul><li><p><strong>用来计算往返时间RTT</strong>。</p><p>发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确计算出RTT。时间戳是一个单调增长的值，接收方只需要回显收到的内容，因此是不需要关注时间戳的单元是什么，也不需要连接双发的时钟同步。</p></li><li><p><strong>PAWS:防止回绕的序号</strong>。</p></li></ul><p>  我们知道序列号只有32位，而每增加2^32个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽用来快速的传输数据。例如1Gb&#x2F;s（<strong>TCP 的窗口经过窗口缩放可以最高到 1GB（2^30)<strong>）的速率发送报文段，则不到35秒钟数据字节的序列号就会重复。这样对TCP传输带来混乱的情况。这种情况之出现在高速链路上。</strong>而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。</strong></p><p>参考文章<a href="https://switch-router.gitee.io/blog/tcp-timestamp/">TCP timestamp 选项那点事</a></p><p>接着我们观察ACK1报文的ACK分析(由wireshark提供), RTT为: 0.40989700s</p><p><img src="/Wireshark-Lab-TCP/image-20230421205941895.png" alt="image-20230421205941895"></p><h3 id="第二段"><a href="#第二段" class="headerlink" title="第二段:"></a><strong>第二段:</strong></h3><p> 我们直接去找, 收到的第二个ACK报文</p><p><img src="/Wireshark-Lab-TCP/image-20230421210002459.png" alt="image-20230421210002459"></p><p>对比sequence的值, 可以发现, 这是对frame75的ACK, 也就是, 收到了对第七个报文段的ACK. 说明服务器已经收到了第七个报文段以及之前的报文. </p><p>我们还发现, 收到了一条[Windows Update]的报文, 这是TCP的流量控制, 用来告诉发送端根据这个值适当的调节发送速率.  </p><p><img src="/Wireshark-Lab-TCP/image-20230421210012633.png" alt="image-20230421210012633"></p><p>根据wireshark的分析, 可以知道, RTT为0.409390000s</p><p><img src="/Wireshark-Lab-TCP/image-20230421210034300.png" alt="image-20230421210034300"></p><h3 id="第三段"><a href="#第三段" class="headerlink" title="第三段:"></a>第三段:</h3><p><img src="/Wireshark-Lab-TCP/image-20230421210044526.png" alt="image-20230415135344532"></p><h3 id="第四段"><a href="#第四段" class="headerlink" title="第四段:"></a>第四段:</h3><p><img src="/Wireshark-Lab-TCP/image-20230421210050923.png" alt="image-20230421210050923"></p><h3 id="第五段"><a href="#第五段" class="headerlink" title="第五段:"></a>第五段:</h3><p><img src="/Wireshark-Lab-TCP/image-20230421210058078.png" alt="image-20230421210058078"></p><h3 id="第六段"><a href="#第六段" class="headerlink" title="第六段"></a>第六段</h3><p><img src="/Wireshark-Lab-TCP/image-20230421210120044.png" alt="image-20230421210120044"></p><p>收到每个 ACK 后，EstimatedRTT 值(参 见本节中的第 3.5.3 节，第 242 页)是什么? </p><p>   假设第一个 EstimatedRTT 的 值等于第一个区段的测量 RTT，然后使用课本第 242 页的 EstimatedRTT 公式计算所有后续区段。</p><p><img src="/Wireshark-Lab-TCP/image-20230421210135957.png" alt="image-20230421210135957"></p><ul><li><p>What is the length of each of the first six TCP segments?4 前六个 TCP 区段的长度是多少?</p><p><img src="/Wireshark-Lab-TCP/image-20230421210144892.png" alt="image-20230421210144892"></p><p>  <img src="/Wireshark-Lab-TCP/image-20230421210152513.png" alt="image-20230421210152513"></p></li><li><p>What is the minimum amount of available buffer space advertised at the received for the entire trace? Does the lack of receiver buffer space ever throttle the sender? 对于整个跟踪包，收到的最小可用缓冲区空间量是多少? 缺少接收缓冲区空间是否会限制发送方传送 TCP 区段?</p><p><img src="/Wireshark-Lab-TCP/image-20230421210204402.png" alt="image-20230421210204402"></p><p>大部分Win都是很大的值, 太多包了, 懒得分析了.通过检查此跟踪，发送器永远不会因为接收器缓冲区空间不足而受到抑制。</p></li><li><p>Are there any retransmitted segments in the trace file? What did you check for (in the trace) in order to answer this question?<br> 在跟踪文件中是否有重传的段? 为了回答这个问题，您检查了什么(在跟踪包中)?</p><p>观察序列号的变化: </p><p>可以发现, 序列号一直在增加, 所以没有重传的段. </p><p><img src="/Wireshark-Lab-TCP/image-20230421210221963.png" alt="image-20230421210221963"></p><p>通常到收到了不同的两个冗余ACK, 但这不一定意味着丢包, 这是因为分组乱序到达接受方导致的.</p><p><img src="/Wireshark-Lab-TCP/image-20230421210234982.png" alt="image-20230421210234982"></p></li><li><p>How much data does the receiver typically acknowledge in an ACK? Can you identify cases where the receiver is ACKing every other received segment (see Table 3.2 on page 250 in the text).<br> 接收方通常在 ACK 中确认多少数据? 您是否可以识别接收方每隔一个接收到的区段才发送确认的情况(参见本文第 250 页的表 3.2)</p><p>按照表3-2的说明, 接受方最多确认两个段, 但是观察了捕获结果, 发现很多事确认了超过两个段段情况, 比如在下图中, 收到的第一个ACK确认了69,70两段. 这是一次典型的delay ACK</p><p><img src="/Wireshark-Lab-TCP/image-20230421210252350.png" alt="image-20230421210252350"></p><p>但是观察收到的第二个ACK, 是对75段及之前段的累积确认, 这同时累积确认了71,72,73,74,75这五个段. 且观察后续的ACK, 除了在上一问题上出现的冗余ACK外, 无其他冗余ACK.</p><p>如果严格按照表3-2的叙述来看, 这只可能是部分ACK丢失导致的, 这就意味着网络拥塞, 但很明显这是不可能的, 因为没有发现任何一个重传的段, 网络很通畅.</p><p>让我们问问万能的chatGPT吧: </p><p> <img src="/Wireshark-Lab-TCP/image-20230421210304585.png" alt="image-20230421210304585"></p><p> <strong>最多可以合并2~5个报文段哦!!! chatGPT yyds!</strong></p><p> <img src="/Wireshark-Lab-TCP/image-20230421210315184.png" alt="image-20230421210315184"></p></li><li><p>What is the throughput (bytes transferred per unit time) for the TCP connection? Explain how you calculated this value.TCP 连接的吞吐量(每单位时间传输的节数)是多少? 解释你如何计算 这个值。</p><p>TCP吞吐量的计算在很大程度上取决于平均时间段的选择。作为一种常见的吞吐量计算，在本问题中，我们选择平均时间周期作为整个连接时间。然后，该TCP连接的平均吞吐量被计算为总数据量与总传输时间之间的比率。可以通过第一个TCP数据段的序列号和最后一个确认确认的序列号之间的差来计算发送的总数据量。</p><p>最后一个由我发给服务器的最后一个ACK的seqence numerber为4095755619, 我发送的报文段第一个序列号为: 4095602682</p><p>所以接受方的接受到的总数据为: 4095755619- 4095602682   &#x3D;  152936Byte</p><p><img src="/Wireshark-Lab-TCP/image-20230421210352640.png" alt="image-20230421210352640"></p><p><img src="/Wireshark-Lab-TCP/image-20230421210406967.png" alt="image-20230421210406967"></p><p>总传输时间为5.455830-0.026477&#x3D;2.50933秒。</p><p>因此，tcp连接的吞吐量计算为152936&#x2F;2.50933&#x3D;60946.945997537191202B&#x2F;s &#x3D; 60KB&#x2F;s。</p><p><img src="/Wireshark-Lab-TCP/image-20230421210418067.png" alt="image-20230421210418067"></p></li></ul><p><em>图由wireshark产生</em></p><blockquote><p>4tcp-ethereal-trace-1 跟踪文件中的 TCP 区段都小于 1460 􏰁节。 这是因为收集跟踪 的计算机具有以太网卡，该最大 IP 数据包的长度限制为 1500 􏰁节(40 􏰁节的 TCP &#x2F; IP 报头数据和 1460 􏰁节的 TCP 有效负载)。此 1500 􏰁节值是以太网允许 的标准最大长度。 如果您的跟踪包内容指示 TCP 区段长度大于 1500 􏰁节，并且 您的计算机使用以太网连接网路，则是 Wireshark 报告了错误的 TCP 区段长度;它 也可能是只显示一个大的 TCP 段而不是多个较小的区段，而您的计算机确实可能 正在发送多个较小的区段，这可以由收到的 ACK 区段来证明。 报告的区段长度的 这种不一致是由于以太网驱动程序和 Wireshark 软件之间的交互作用所导致。 如果 您有这种不一致情形，我们建议您使用本文所提供的跟踪文件来执行本实验的分析 内容。</p></blockquote><h2 id="TCP-congestion-control-in-action-TCP-拥塞控制"><a href="#TCP-congestion-control-in-action-TCP-拥塞控制" class="headerlink" title="TCP congestion control in action (TCP 拥塞控制)"></a>TCP congestion control in action (TCP 拥塞控制)</h2><blockquote><p>现在让我们检查从客户端服务器的每单位时间发送的数据量。 而不是(繁琐 地!)从 Wireshark 窗口中的原始数据计算这些数值，我们将使用 Wireshark 的 TCP 图形工具 – 时序图(Stevens) - 来绘制数据。</p></blockquote><ul><li><p>使用时序图(Stevens)绘图工具查看从客户端发送到 gaia.cs.umass.edu 服务 器的区段的序列号与时间关系图。您能否确定 TCP 的慢启动阶段的开始和 结束位置，以及拥塞避免接管的位置? 评论测量数据与我们在文本中研究 的 TCP 的理想化行为的不同之处。</p><p><img src="/Wireshark-Lab-TCP/image-20230421210435578.png" alt="image-20230421210435578"></p></li></ul><p>计算每轮发送的段数量分别为: 12,17,36,87 呈指数增长, 一只在慢启动阶段. </p>]]></content>
    
    
    <summary type="html">在本实验中，我们将详细研究著名的 TCP 协议的行为。 我们将通过从您的电脑向 远程服务器传输一份 150KB 的文件，并分析 TCP 传输内容的发送和接收过程来实现。 我们将研究 TCP 对序列和 确认号的使用，以提供可靠的数据传输;我们将看到 TCP 的拥塞控制算法 – 慢启 动和拥塞避免 – 在过程中，我们将看看 TCP 的接收器发送流量控制的机制。 我们还将简要地观察 TCP 连线的设置，我们还会研究计算机和服务器之间 TCP 连线的性能。</summary>
    
    
    
    <category term="学习" scheme="https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="computer network" scheme="https://trevoewu.github.io/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>MAC M1 安装Oracle数据库教程</title>
    <link href="https://trevoewu.github.io/2023/04/21/MAC-M1-%E5%AE%89%E8%A3%85Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/"/>
    <id>https://trevoewu.github.io/2023/04/21/MAC-M1-%E5%AE%89%E8%A3%85Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/</id>
    <published>2023-04-21T12:35:34.000Z</published>
    <updated>2023-04-21T12:37:22.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC-M1-安装Oracle数据库教程"><a href="#MAC-M1-安装Oracle数据库教程" class="headerlink" title="MAC M1 安装Oracle数据库教程"></a>MAC M1 安装Oracle数据库教程</h1><p><strong>oracle目前还没有支持M1的版本, 本教程使用SSH来远程登录oracle服务器</strong></p><ol><li>在开始之前, 请确保你的mac安装了parallels Desktop, 并安装windows系统</li><li>如果你身边有windows环境, 比如你的室友的电脑, 你可以跳过1.</li><li>在windows电脑中安装Oracle Database Software.</li></ol><h2 id="安装OpenSSH服务"><a href="#安装OpenSSH服务" class="headerlink" title="安装OpenSSH服务"></a>安装OpenSSH服务</h2><p>在window设置中</p><p><em>适用于 Windows Server 2019、Windows 10,11、Windows Server 2022</em></p><p>OpenSSH 是一款用于远程登录的连接工具，它使用 SSH 协议。 它会加密客户端与服务器之间的所有流量，从而遏止窃听、连接劫持和其他攻击。</p><p>OpenSSH 可用于将安装了 OpenSSH 客户端的 Window 10（版本 1809 及更高版本）或 Windows Server 2019 设备连接到那些安装了 OpenSSH 服务器的设备。</p><h3 id="使用windous设置安装OpenSSSH"><a href="#使用windous设置安装OpenSSSH" class="headerlink" title="使用windous设置安装OpenSSSH"></a>使用windous设置安装OpenSSSH</h3><p>可以使用 Windows Server 2019 和 Windows 10 设备上的 Windows 设置安装这两个 OpenSSH 组件。</p><p>若要安装 OpenSSH 组件：</p><ol><li>打开“设置”，选择“应用”&gt;“应用和功能”，然后选择“可选功能” 。</li><li>扫描列表，查看是否已安装 OpenSSH。 如果未安装，请在页面顶部选择“添加功能”，然后：<ul><li>查找“OpenSSH 客户端”，再单击“安装”</li><li>查找“OpenSSH 服务器”，再单击“安装”</li></ul></li></ol><p>设置完成后，回到“应用”&gt;“应用和功能”和“可选功能”，你应会看到已列出 OpenSSH 。</p><p><em>安装 OpenSSH 服务器将创建并启用一个名为 <code>OpenSSH-Server-In-TCP</code> 的防火墙规则。 这允许端口 22 上的入站 SSH 流量。 如果未启用此规则且未打开此端口，那么连接将被拒绝或重置。</em></p><h3 id="使用PowerShell安装OpenSSH"><a href="#使用PowerShell安装OpenSSH" class="headerlink" title="使用PowerShell安装OpenSSH"></a>使用PowerShell安装OpenSSH</h3><p>若要使用 PowerShell 安装 OpenSSH，请先以管理员身份运行 PowerShell。 为了确保 OpenSSH 可用，请运行以下 cmdlet：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Get-WindowsCapability -Online | Where-Object Name -like &#39;OpenSSH*&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果两者均尚未安装，则此操作应返回以下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Name  : OpenSSH.Client~~~~0.0.1.0State : NotPresentName  : OpenSSH.Server~~~~0.0.1.0State : NotPresent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，根据需要安装服务器或客户端组件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Install the OpenSSH ClientAdd-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# Install the OpenSSH ServerAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两者应该都会返回以下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Path          :Online        : TrueRestartNeeded : False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="启动并配置-OpenSSH-服务器"><a href="#启动并配置-OpenSSH-服务器" class="headerlink" title="启动并配置 OpenSSH 服务器"></a>启动并配置 OpenSSH 服务器</h2><p>若要启动并配置 OpenSSH 服务器来开启使用，请以管理员身份打开 PowerShell，然后运行以下命令来启动 <code>sshd service</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Start the sshd serviceStart-Service sshd# OPTIONAL but recommended:Set-Service -Name sshd -StartupType &#39;Automatic&#39;# Confirm the Firewall rule is configured. It should be created automatically by setup. Run the following to verifyif (!(Get-NetFirewallRule -Name &quot;OpenSSH-Server-In-TCP&quot; -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) &#123;    Write-Output &quot;Firewall Rule &#39;OpenSSH-Server-In-TCP&#39; does not exist, creating it...&quot;    New-NetFirewallRule -Name &#39;OpenSSH-Server-In-TCP&#39; -DisplayName &#39;OpenSSH Server (sshd)&#39; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22&#125; else &#123;    Write-Output &quot;Firewall rule &#39;OpenSSH-Server-In-TCP&#39; has been created and exists.&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接到-OpenSSH-服务器"><a href="#连接到-OpenSSH-服务器" class="headerlink" title="连接到 OpenSSH 服务器"></a>连接到 OpenSSH 服务器</h2><p>mac自带SSH服务, 所以安装后，可以使用MAC连接到 OpenSSH 服务器, 在终端中运行一下命令:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh username@ipadress #username是安装了Oracle的windows电脑的用户名#ipaddress是该电脑的ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以通过在windows的PowerShell中运行以下命令来查看ip地址:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装要求输入密码, 注意是微软用户的密码, 不是电脑的开机密码</p><p>连接后，你将看到 Windows 命令行界面提示符：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">domain\username@SERVERNAME C:\Users\username&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="用户登录Oracle数据库"><a href="#用户登录Oracle数据库" class="headerlink" title="用户登录Oracle数据库"></a>用户登录Oracle数据库</h2><p>c成功链接后, 在终端输入:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlplus &#x2F; as sysdba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照提示输入用户名:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sys as sysdba <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并按照提示输入口令, 这个口令是在你安装Orecle软件的过程中设置的.</p><p>产生一下输出则链接成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">连接到: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>ctrl</code>+<code>c</code>退出sql服务, 输入<code>exit</code>退出ssh链接</p><h2 id="用Navicat远程登陆Oracle数据库"><a href="#用Navicat远程登陆Oracle数据库" class="headerlink" title="用Navicat远程登陆Oracle数据库"></a>用Navicat远程登陆Oracle数据库</h2><p>打开Navicat, 左上角选择, 之后选择Oracle.</p><p>链接名请随意填写, 主机位置填入localhost, 端口默认为1521</p><p>服务名默认为ORCL, 如果你在安装Oracle中没有更改, 则保持不变, 我的改为了ORACLE</p><p>角色选择SYSDBA,用户名为sys, 密码就是之前提到的口令.</p><img src="/Users/trevorwu/Library/Application Support/typora-user-images/image-20220929221736551.png" alt="image-20220929221736551" style="zoom:50%;" /><p>点击SSH选项</p><img src="/Users/trevorwu/Library/Application Support/typora-user-images/image-20220929221807569.png" alt="image-20220929221807569" style="zoom:50%;" /><p>主机填入windows主机的IP地址, 端口默认22, 用户名是windows账户的用户名, 密码是该账户的密码</p><p>点击链接测试, 成功链接后点击保存即可.</p>]]></content>
    
    
    <summary type="html">oracle目前还没有支持M1的版本, 本教程使用SSH来远程登录oracle服务器</summary>
    
    
    
    <category term="mac使用指南" scheme="https://trevoewu.github.io/categories/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="mac使用指南" scheme="https://trevoewu.github.io/tags/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
    <category term="oracle" scheme="https://trevoewu.github.io/tags/oracle/"/>
    
    <category term="教程" scheme="https://trevoewu.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统漫游</title>
    <link href="https://trevoewu.github.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://trevoewu.github.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2023-04-21T12:31:56.000Z</published>
    <updated>2023-04-21T12:33:26.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息就是位-bit-加上下文-context"><a href="#信息就是位-bit-加上下文-context" class="headerlink" title="信息就是位(bit)加上下文(context)"></a>信息就是位(bit)加上下文(context)</h2><p>我们学习一门新的语言, 往往是从Hello world开始的, 我想没有一个程序员不喜欢这句话, 就像一个刚出生的婴儿, 对着这个陌生的世界微笑一样. </p><p>这次对计算机系统的学习就从一个hello world程序的生命周期开始. 从他被我们键入编辑器, 到在系统运行, 打印hello world最后interminates.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main()&#123;  printf(&quot;hello world\n&quot;);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的hello world程序生命的开始是源程序(source progam)或者源文件(source file), 以后缀 <code>.c</code> 结尾, 它是由一系列的0,1代码构成, 我们把每一位叫做bit. 每八个bit组成一个块, 我们称之为一个字节byte. 它是计算机处理信息的最小单位. 每一个byte对应着一个字符. </p><p>大多数计算机系统都采用ASCII标准来表示字符, 每一个ASCII码的值都对应着一个唯一的字符. 我们可以在linux或者like-unix系统的终端中键入<code>man ascii</code>来查看对应关系</p><img src="/Users/trevorwu/Library/Application Support/typora-user-images/image-20220928022041369.png" alt="image-20220928022041369" style="zoom:50%;" /><p>我们把像<code>hello.c</code>这样用ASCII码表示的文件叫做文本文件(text files), 而其他形式的文件叫做二进制文件(binary files)</p><p>在计算机中, 所以的信息都是都是一连串的由0和1组成, 而唯一区分这些信息就是上下文. 在不同上下文中, 相同的一段比特序列可能表示一个整数, 浮点数, 或者一条指令. </p><h2 id="程序被编译器翻译成不同的格式"><a href="#程序被编译器翻译成不同的格式" class="headerlink" title="程序被编译器翻译成不同的格式"></a>程序被编译器翻译成不同的格式</h2><p>计算机只认识二进制序列, helloworld这样的程序是不能被计算机理解的. 为了让计算机正确的执行我们的指令, 我们必须把它翻译成以二进制表示的形式, 我们把这样由二进制表示的语言叫做机器语言. 这些指令最后被打包成名叫可执行程序的形式, 存储为磁盘中的二进制文件. </p><p>在unix系统中, 这个由源文件翻译为可执行文件的过程是由一个叫编译器的程序完成.</p><p>整个边缘过程分为4个阶段, 分别是预编译处理, 编译, 汇编, 链接. </p><ul><li>预编译阶段修改由<code>#</code>为开始的语句, 比如这段hello.c程序中的<code>#include&lt;stdio.h&gt;</code>, 预编译阶段会在目标路径中找到对应的<code>stdio.h</code>文件, 并直接插入到程序中, 有点内容复制粘贴到过程.</li></ul><p>​这个<code>stdio.h</code>文件中主要包括函数声明, 宏定义, 以及结构体定义, 这个阶段会生成以<code>.i</code>为后缀的文本文件.</p><p>​默认情况下，预处理器的输出会被导入到标准输出流（也就是显示器），可以利用<code>-o</code>选项把它导入到某个输出文件, 在shell中键入<code>gcc -E hello.c -o hello.i</code>来输出到hello.i文件中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,       const char * restrict, va_list);# 400 &quot;&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h&quot; 2 3 4# 2 &quot;hello.c&quot; 2int main()&#123;  printf(&quot;hello world\n&quot;);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>产生的代码很长很长, 大概有500行,这里只截取最后一部分. 可以发现, 即使是想helloworld这样极端简单的程序, 编译之后也会比源文件大很多.</p><ul><li>编译阶段把预编译产生的以<code>.i</code>结尾的文件翻译成以汇编语言表示的文本文件, 汇编是一种很有用的低一级的语言, 在不同的编译器编译不同的高级语言中, 它往往作为编译阶段的输出语言.</li></ul><p>我们可以在shell中键入<code>gcc -S hello.c</code>生产汇编程序<code>hello.s</code> :</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">_main:                                  ; @main.cfi_startproc; %bb.0:subsp, sp, #32                     ; &#x3D;32stpx29, x30, [sp, #16]             ; 16-byte Folded Spilladdx29, sp, #16                    ; &#x3D;16.cfi_def_cfa w29, 16.cfi_offset w30, -8.cfi_offset w29, -16movw8, #0strw8, [sp, #8]                    ; 4-byte Folded Spillsturwzr, [x29, #-4]adrpx0, l_.str@PAGEaddx0, x0, l_.str@PAGEOFFbl_printfldrw0, [sp, #8]                    ; 4-byte Folded Reloadldpx29, x30, [sp, #16]             ; 16-byte Folded Reloadaddsp, sp, #32                     ; &#x3D;32ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>汇编阶段</p><p>在汇编阶段编译器会把上一阶段用ASCII表示的文本文件<code>hello.s</code>转化为机器语言表示的指令, 并打包生成叫做可重定位的二进制文件文件, 存储在<code>hello.o</code>的文件中, 如果我们打开这个文件,  文本编辑器会按照ASCII表示成对应的字符, 所以我们将会看到一堆乱码. </p></li><li><p>链接阶段</p></li></ul><p>注意到我们的helloworld程序调用了一个名为printf的函数, 这个函数是C标准库函数的一部分,由编译起提供. 这个函数保持在一个单独的预编译的目标文件中, 叫做<code>printf.o</code>它必须和我们的<code>hello.o</code>合并, 这个工作由链接器完成, 生成和以直接运行可执行文件<code>hello</code>. </p><p>现在, 我们的源程序以及被翻译成了可执行文件, 并存储来磁盘中. 我们可以在shell中键入<code>./hello</code>来运行我们的程序. </p>]]></content>
    
    
    <summary type="html">我们学习一门新的语言, 往往是从Hello world开始的, 我想没有一个程序员不喜欢这句话, 就像一个刚出生的婴儿, 对着这个陌生的世界微笑一样.</summary>
    
    
    
    <category term="学习笔记" scheme="https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="computer system" scheme="https://trevoewu.github.io/tags/computer-system/"/>
    
  </entry>
  
  <entry>
    <title>纪念拥有了自己的博客</title>
    <link href="https://trevoewu.github.io/2023/04/21/%E7%BA%AA%E5%BF%B5%E6%8B%A5%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://trevoewu.github.io/2023/04/21/%E7%BA%AA%E5%BF%B5%E6%8B%A5%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-04-21T12:28:51.000Z</published>
    <updated>2023-04-21T12:30:45.584Z</updated>
    
    <content type="html"><![CDATA[<p>当一个由你亲手塑造的东西第一次呈现在你面前的时候, 那种兴奋感以及成就感是难以比拟的. </p><span id="more"></span><p>比如当我第一次用自己的废旧的电脑组装成一台显示器, 当看到显示器作为switch副屏被点亮的时候. 比如自己照着教程给路由器刷插件来破解校园网, 看见Wi-Fi信号出现, 设备连接后, 绕过认证连接上互联网的时候. </p><p>那时候, 我好高兴好高兴, 我很想分享我的成果, 告诉宿舍的每一个人让他们连我的Wi-Fi, 从此实现Wi-Fi自由. 平时沉默不语的我在这时候犹豫了. 我只能强迫自己去做一些别的事来抑制这份心情. </p><p>而用于自己的博客带来的悸动是更胜过这两件事的. </p><p>我很开心当我告诉我的两位异性朋友时, 虽然她们对此并不了解, 仅仅是看见她们好奇和称赞我就好开心. </p><p>第一次听到博客这个词是在初二的时候, 老师给我们发了一份调查问卷, 其中一个问题便是有没有自己的博客, 那时候我还不知道博客是什么, 便以为是微博, 于是填上了是. 想必那时候拿到数据的人会不会惊讶于一个初二学生会拥有自己的博客呢. </p><p>上大学后, 靠搜索学习也让我遇见了很多优秀的博客, 有着精致的页面, 充满个人特色的UI, 以及那些学习和生活的记录, 每次翻阅, 我都觉得他们好优秀. </p><p>好像成为他们那样优秀的人. </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当一个由你亲手塑造的东西第一次呈现在你面前的时候, 那种兴奋感以及成就感是难以比拟的. &lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://trevoewu.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="日常" scheme="https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="talk" scheme="https://trevoewu.github.io/tags/talk/"/>
    
  </entry>
  
  <entry>
    <title>hexo插入图片问题</title>
    <link href="https://trevoewu.github.io/2023/04/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>https://trevoewu.github.io/2023/04/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-21T03:46:44.000Z</published>
    <updated>2023-04-21T04:47:56.326Z</updated>
    
    <content type="html"><![CDATA[<p>昨天刚搭建完博客, 发现直接写markdown, hexo 生成后图片全部都没法显示了, 毕竟图片都在本地, 以绝对路径的方式存储的, markdown的路径的hexo的路径不匹配. </p><span id="more"></span><p>以前搭博客的时候这个图片问题就老是困扰着我, 我用typora编写的文章转到html之后, 我还得把图片也引到项目目录来, 然后在一个个的该路径. 体验可以说是很差了, 这也导致哪怕写完文章, 我也懒得发布了, 太麻烦. </p><p>这次用hexo搭建也遇到了同样的问题, 按照老方法, 我能想到的就只有把图片全部拉过来了, 我直接把全部图片<code>mv</code>到了public目录的imag目录下, 部署到github上的时候, 由于图片太多了, 进度条老是卡住, 我只好放弃了. 我直接<code>ctl+c</code>, <code>hexo clean</code>,<code>hexo s</code>.这时候我还不知道<code>hexo clean</code>意味这什么, 只是看教程大家都是这样做的, 结果, 结果hexo把我pubilc目录下的文件全部删了…, 我的图片, 也全没了. </p><p>今天发现一个绝好的解决方案, 将Typora和hexo完美结合起来. </p><h3 id="第一步-修改hexo的站点配置文件-config-yml"><a href="#第一步-修改hexo的站点配置文件-config-yml" class="headerlink" title="第一步 修改hexo的站点配置文件_config.yml"></a>第一步 修改hexo的站点配置文件_config.yml</h3><p>首先安装插件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-renderer-marked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在_config.yml搜索<code>post_asset_folder</code>改为true 如下:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">post_asset_folder: truemarked:  prependRoot: true  postAsset: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 <code>hexo new &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹，并在执行<code>hexo g</code>的时候连同图片以前复制到public目录下(网站的根目录).于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 <code>example.jpg</code> 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 <code>![](example/example.jpg)</code>即可访问 。</p><p>  也就是这样</p><p><img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421120557507.png" alt="image-20230421120557507"></p><p>但是呢, 执行<code>hexo g</code>生成的时候, hexo会把sourec目录下的_posts文件的转化为成html, 并保存在pubilc对应日期的路径中,<img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421121112744.png" alt="image-20230421121112744"></p><p>可以看到, 此时index中的图片路径和markdown的图片路径是冲突的. </p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">typora的路径使用: ![](.&#x2F;example&#x2F;example.jpg)这样页面上的img路径就会是:&#x2F;你的文章标题&#x2F;example&#x2F;example.jpg正确的图片地址: &#x2F;example&#x2F;example.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是因为<code>hexo g</code>把文件夹里面图片复制过来了, 但并没有复制整个图片的文件夹. </p><p>所以我只需要拿到当前博客的路径，直接加上图片名字就行.</p><h3 id="第二步-编写路径替换脚本"><a href="#第二步-编写路径替换脚本" class="headerlink" title="第二步, 编写路径替换脚本"></a>第二步, 编写路径替换脚本</h3><p>在全局js文件 themes\next\source\js\next-boot.js中，编写img 路径替换脚本</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 脚本提供者</span><span class="token comment">//http://songpengpeng.com</span><span class="token keyword">var</span> images <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> loHref <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token keyword">let</span> baseHref <span class="token operator">=</span> loHref<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>loHref<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>images<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> executeNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> src <span class="token operator">=</span> images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'src'</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> src    img<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    img<span class="token punctuation">.</span><span class="token function-variable function">onerror</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>        executeNum <span class="token operator">++</span> <span class="token punctuation">;</span>        <span class="token function">handAMark</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>executeNum<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">let</span> fileName <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>src<span class="token operator">=</span> baseHref<span class="token operator">+</span>fileName    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span>  <span class="token function">handAMark</span><span class="token punctuation">(</span><span class="token parameter">src</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> <span class="token keyword">as</span> <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"fancybox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span><span class="token keyword">as</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> executeNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> href <span class="token operator">=</span> <span class="token keyword">as</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>href<span class="token operator">==</span>src<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            img<span class="token punctuation">.</span>src <span class="token operator">=</span> src            img<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>            img<span class="token punctuation">.</span><span class="token function-variable function">onerror</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span> <span class="token punctuation">&#123;</span>                executeNum <span class="token operator">++</span> <span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>executeNum<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">let</span> fileName <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">as</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>href<span class="token operator">=</span> baseHref<span class="token operator">+</span>fileName            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样, 使用<code>hexo g</code>生成的时候, 就会自动将图片的路径替换. </p><h3 id="第三步-搭配typora才是最佳"><a href="#第三步-搭配typora才是最佳" class="headerlink" title="第三步, 搭配typora才是最佳"></a>第三步, 搭配typora才是最佳</h3><p>但是还是不够方便啊, 我们得先把图片放到文章的资源文件夹中. Typora对插图片的支持非常好, 可以在复制图片的同时, 把物品保存在对应的文件夹中</p><p>打开Typora, <code>⌘+,</code>进入系统偏好设置, 点击image选项卡, 修改为以下格式: </p><p>这样当插入图片的时候, 会自动把图片放到当前目录的markdown相名的文件夹中, 恰好, Hexo 在我们每一次通过 <code>hexo new &lt;title&gt;</code> 命令创建新文章时自动创建一个同名文件夹. </p><p>完美!</p><p><img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421124001298.png" alt="image-20230421124001298"></p><p>这样, 我们在Typora上写文章, 完全不用担心插入图片问题, 而且文章的图片也会有序的存放, 方面日后的管理. </p><p>现在我们只需要<code>hexo n &#39;title&#39;</code>然后在Typora上写文章, 就可以直接推到博客了, 照片也可以正常显示. </p><p>你看, 我写完这篇文章的时候, hexo已经完美的生成网页了. </p><p>这太棒了, 不是吗? </p><p><img src="/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/image-20230421124655253.png" alt="image-20230421124655253"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天刚搭建完博客, 发现直接写markdown, hexo 生成后图片全部都没法显示了, 毕竟图片都在本地, 以绝对路径的方式存储的, markdown的路径的hexo的路径不匹配. &lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo重新搭建博客</title>
    <link href="https://trevoewu.github.io/2023/04/21/%E4%BD%BF%E7%94%A8hexo%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://trevoewu.github.io/2023/04/21/%E4%BD%BF%E7%94%A8hexo%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-04-20T16:52:00.000Z</published>
    <updated>2023-04-20T16:58:45.077Z</updated>
    
    <content type="html"><![CDATA[<p>之前的博客是学web的时候手搓的, 导致后期管理困难, 每次发布文章我甚至得手写HTML. 后来发现大家都是用hexo搭建博客, 我也尝试了一下. </p><p>我真的好喜欢自己之前博客的风格<a href="https://trevoewu.github.io/Peekaboo/">Peekaboo的部落格</a></p><p>现在就先用next主题吧, 这个主题虽然不怎么好看, 但是帮助文档太友好了, 感谢感谢. </p>]]></content>
    
    
    <summary type="html">之前的博客是学web的时候手搓的, 导致后期管理困难, 每次发布文章我甚至得手写HTML. 后来发现大家都是用hexo搭建博客, 我也尝试了一下.</summary>
    
    
    
    
    <category term="Talk" scheme="https://trevoewu.github.io/tags/Talk/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark lab HTTP</title>
    <link href="https://trevoewu.github.io/2023/04/20/Wireshark-lab-HTTP/"/>
    <id>https://trevoewu.github.io/2023/04/20/Wireshark-lab-HTTP/</id>
    <published>2023-04-20T15:01:49.000Z</published>
    <updated>2023-04-20T15:50:51.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wireshark实验-HTTP"><a href="#Wireshark实验-HTTP" class="headerlink" title="Wireshark实验 - HTTP"></a>Wireshark实验 - HTTP</h1><p><strong>官方英文文档：<a href="Wireshark_HTTP_v7.0"><a href="http://www-net.cs.umass.edu/wireshark-labs/Wireshark_HTTP_v7.0.pdf">Wireshark_HTTP_v7.0</a></a></strong></p><p><strong>以下内容为笔者翻译：</strong></p><hr><p><strong>《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross</strong></p><p>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 </p><p>© 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved</p><hr><p>在介Wireshark实验-入门里，我们已经初步使用了Wireshark包嗅探器，我们现在可以操作Wireshark来查看网络协议。在这个实验中，我们会探索HTTP协议的几个方面：基本的GET&#x2F;response交互，HTTP消息格式，检索大型HTML文件，检索具有嵌入对象的HTML文件，HTTP认证和安全性。在开始这些实验之前，您可能想查看书中第2.2节。</p><h3 id="1-基本HTTP-GET-x2F-response交互"><a href="#1-基本HTTP-GET-x2F-response交互" class="headerlink" title="1.基本HTTP GET&#x2F;response交互"></a>1.基本HTTP GET&#x2F;response交互</h3><p>我们开始探索HTTP，方法是下载一个非常简单的HTML文件<br>非常短，并且不包含嵌入的对象。执行以下操作：</p><ol><li>启动您的浏览器。</li><li>启动Wireshark数据包嗅探器，如Wireshark实验-入门所述（还没开始数据包捕获）。在display-filter-specification窗口中输入“http”（只是字母，不含引号标记），这样就在稍后的分组列表窗口中只捕获HTTP消息。（我们只对HTTP协议感兴趣，不想看到其他所有的混乱的数据包）。</li><li>稍等一会儿（我们将会明白为什么不久），然后开始Wireshark数据包捕获。</li><li>在浏览器中输入以下内容 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html</a> 您的浏览器应显示非常简单的单行HTML文件。</li><li>停止Wireshark数据包捕获。</li></ol><p>你的Wireshark窗口应该类似于图1所示的窗口。如果你无法连接网络并运行Wireshark，您可以根据后面的步骤下载已捕获的数据包：</p><p>下载zip文件 <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a> </p><p>解压缩文件 http-ethereal-trace-1。这个zip文件中的数据是由本书作者之一使用Wireshark在作者电脑上收集的，并且是按照Wireshark实验中的步骤做的。 如果你下载了数据文件，你可以将其加载到Wireshark中，并使用文件菜单选择打开并查看数据，然后选择http-ethereal-trace-1文件。 结果显示应与图1类似。（在不同的操作系统上，或不同的Wireshark版本上，Wireshark的界面会不同）。</p><p><strong>图1：Wireshark显示 <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTPwireshark-file1.html">http://gaia.cs.umass.edu/wireshark-labs/HTTPwireshark-file1.html</a> 已被您的浏览器打开</strong></p><p>图1中的示例在分组列表窗口中显示了两个被捕获的HTTP消息：GET消息（从您的浏览器发送到gaia.cs.umass.edu 的web服务器）和从服务器到浏览器的响应消息。分组内容窗口显示所选消息的详细信息（在这种情况下为HTTP OK消息，其在分组列表窗口中高亮显示）。回想一下，因为HTTP消息被装载在TCP报文段内，该报文段是在IP分组封装吗，进而在以太网帧，和帧中封装，所以界面中显示了帧，以太网，IP，TCP分组信息以及HTTP报文信息。我们想最小化非HTTP数据的显示（我们这里只对HTTP感兴趣，这些其他协议将在以后的实验中研究），所以确保帧，以太网，IP和TCP行的信息被隐藏，注意左边有一个加号或一个向右的三角形（这意味着有信息被隐藏），而HTTP行具有减号或向下三角形（表示显示有关HTTP消息的所有信息）。</p><p>（注意：您应该忽略与favicon.ico相关的任何HTTP GET和response。 如果你看到一个关于这个文件的引用，这是你的浏览器自动询问服务器是否有一个图标文件应显示在浏览器的URL旁边。 我们会忽略这个引起麻烦的引用。）</p><p>通过查看HTTP GET和响应消息中的信息，回答以下问题。 在回答以下问题时，您应该打印出GET和响应消息（请参阅Wireshark-入门实验以获取信息），并指出您在消息中的哪个具体位置找到了回答以下问题的信息。 当您上交作业时，请注明输出，显示您在哪些地方表示了您的答案（例如，对于我们的课程，我们要求学生用笔标记纸质副本，或用彩色字体在电子副本的中注释文本）。</p><ol><li><p>您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？</p><p>HTTP&#x2F;1.1</p><p>![image-20230416143533797](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416143533797.png)</p></li><li><p>您的浏览器会从接服务器接受哪种语言（如果有的话）？</p><p>![image-20230416144437584](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144437584.png)</p></li><li><p>您的计算机的IP地址是什么？ gaia.cs.umass.edu服务器地址呢？</p><p>![image-20230416143642203](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416143642203.png)</p></li><li><p>服务器返回到浏览器的状态代码是什么？</p><p>![image-20230416144507009](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144507009.png)</p></li><li><p>服务器上HTML文件的最近一次修改是什么时候？</p><p>![image-20230416144603595](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144603595.png)</p></li><li><p>服务器返回多少字节的内容到您的浏览器？</p><p>![image-20230416144632313](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416144632313.png)</p></li><li><p>通过检查数据包内容窗口中的原始数据，你是否看到有协议头在数据包列表窗口中未显示？ 如果是，请举一个例子。</p><p>没有</p></li></ol><p>在您对上述问题5的回答中，您可能会惊讶地发现您刚才检索的文档在下载文档之前最近一次修改是一分钟前。 那是因为（对于这个特定文件），gaia.cs.umass.edu服务器将文件的最后修改时间设置为当前时间，并且每分钟执行一次。 因此，如果您在两次访问之间等待一分钟，则该文件看起来已被修改，因此您的浏览器将下载文档的“新”副本。</p><h3 id="2-HTTP条件Get-x2F-response交互"><a href="#2-HTTP条件Get-x2F-response交互" class="headerlink" title="2.HTTP条件Get&#x2F;response交互"></a>2.HTTP条件Get&#x2F;response交互</h3><p>回顾书的第2.2.5节，大多数Web浏览器使用对象缓存，从而在检索HTTP对象时执行条件GET。执行以下步骤之前，请确保浏览器的缓存为空。（要在Firefox下执行此操作，请选择“工具” - &gt; “清除最近历史记录”，然后检查缓存框，对于Internet Explorer，选择“工具” - &gt;“Internet选项” - &gt;“删除文件”；这些操作将从浏览器缓存中删除缓存文件。 现在按下列步骤操作：</p><ul><li>启动您的浏览器，并确保您的浏览器的缓存被清除，如上所述。</li><li>启动Wireshark数据包嗅探器。</li><li>在浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html</a> 您的浏览器应显示一个非常简单的五行HTML文件。</li><li>再次快速地将相同的URL输入到浏览器中（或者只需在浏览器中点击刷新按钮）。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只捕获HTTP消息，并在数据包列表窗口中显示。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-2数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>回答下列问题：</p><ol start="8"><li><p>检查第一个从您浏览器到服务器的HTTP GET请求的内容。您在HTTP GET中看到了“IF-MODIFIED-SINCE”行吗？</p><p>没有</p></li><li><p>检查服务器响应的内容。服务器是否显式返回文件的内容？ 你是怎么知道的？</p><p>是的,![image-20230416150206500](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416150206500.png)</p></li><li><p>现在，检查第二个HTTP GET请求的内容。 您在HTTP GET中看到了“IF-MODIFIED-SINCE:”行吗？ 如果是，“IF-MODIFIED-SINCE:”头后面包含哪些信息？</p><p>看见了. 日期</p><p>![image-20230416151334645](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151334645.png)</p></li><li><p>针对第二个HTTP GET，从服务器响应的HTTP状态码和短语是什么？服务器是否明确地返回文件的内容？请解释。</p><p>![image-20230416150249214](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416150249214.png)</p></li></ol><h3 id="3-检索长文件"><a href="#3-检索长文件" class="headerlink" title="3.检索长文件"></a>3.检索长文件</h3><p>在我们到目前为止的例子中，检索的文档是简短的HTML文件。 接下来我们来看看当我们下载一个长的HTML文件时会发生什么。 按以下步骤操作：</p><ul><li>启动您的浏览器，并确保您的浏览器缓存被清除，如上所述。</li><li>启动Wireshark数据包嗅探器</li><li>在您的浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html</a> 您的浏览器应显示相当冗长的美国权利法案。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-3数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>在分组列表窗口中，您应该看到您的HTTP GET消息，然后是对您的HTTP GET请求的多个分组的TCP响应。这个多分组响应值得进行一点解释。回顾第2.2节（见文中的图2.9），HTTP响应消息由状态行组成，后跟标题行，后跟一个空行，后跟实体主体。在我们的HTTP GET这种情况下，响应中的实体主体是整个请求的HTML文件。在我们的例子中，HTML文件相当长，4500字节太大，一个TCP数据包不能容纳。因此，单个HTTP响应消息由TCP分成几个部分，每个部分包含在单独的TCP报文段中（参见书中的图1.24）。在Wireshark的最新版本中，Wireshark将每个TCP报文段指定为独立的数据包，并且单个HTTP响应在多个TCP数据包之间分段的事实由Wireshark显示的Info列中的“重组PDU的TCP段”指示。 Wireshark的早期版本使用“继续”短语表示HTTP消息的整个内容被多个TCP段打断。我们在这里强调，HTTP中没有“继续”消息！</p><p>回答下列问题：</p><ol start="12"><li><p>您的浏览器发送多少HTTP GET请求消息？哪个数据包包含了美国权利法案的消息？</p><p>![image-20230416151626850](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151626850.png)</p><p>两个, 第一个</p></li><li><p>哪个数据包包含响应HTTP GET请求的状态码和短语？</p><p>![image-20230416151652019](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151652019.png)</p><p>第二个</p></li><li><p>响应中的状态码和短语是什么？</p><p>200 OK</p></li><li><p>需要多少包含数据的TCP段来执行单个HTTP响应和权利法案文本？</p><p>4个TCP段</p><p>![image-20230416151853132](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416151853132.png)</p></li></ol><h3 id="4-具有嵌入对象的HTML文档"><a href="#4-具有嵌入对象的HTML文档" class="headerlink" title="4.具有嵌入对象的HTML文档"></a>4.具有嵌入对象的HTML文档</h3><p>现在我们已经看到Wireshark如何显示捕获的大型HTML文件的数据包流量，我们可以看看当浏览器使用嵌入的对象下载文件时，会发生什么，即包含其他对象的文件（在下面的例子中是图像文件） 的服务器。<br>执行以下操作：</p><ul><li>启动您的浏览器。</li><li>启动Wireshark数据包嗅探器。</li><li>在浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html">http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html</a> 您的浏览器应显示包含两个图像的短HTML文件。这两个图像在基本HTML文件中被引用。也就是说，图像本身不包含在HTML文件中；相反，图像的URL包含在已下载的HTML文件中。如书中所述，您的浏览器将不得不从指定的网站中检索这些图标。我们的出版社的图标是从 <a href="http://www.aw-bc.com/">www.aw-bc.com</a> 网站检索的。而我们第5版（我们最喜欢的封面之一）的封面图像存储在manic.cs.umass.edu服务器。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-4数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>回答下列问题：</p><ol start="16"><li><p>您的浏览器发送了几个HTTP GET请求消息？ 这些GET请求发送到哪个IP地址？</p><p>三个</p><p>![image-20230416152201783](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152201783.png)</p></li><li><p>浏览器从两个网站串行还是并行下载了两张图片？请说明。</p><p>猜测为串行, 因为这两个GET请求发送有时间差</p><p>![image-20230416152416694](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152416694.png)</p></li></ol><h3 id="5-HTTP认证"><a href="#5-HTTP认证" class="headerlink" title="5.HTTP认证"></a>5.HTTP认证</h3><p>最后，我们尝试访问受密码保护的网站，并检查网站的HTTP消息交换的序列。URL <a href="http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html">http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html</a> 是受密码保护的。用户名是“wireshark-students”（不包含引号），密码是“network”（再次不包含引号）。所以让我们访问这个“安全的”受密码保护的网站。执行以下操作：</p><ul><li>请确保浏览器的缓存被清除，如上所述，然后关闭你的浏览器，再然后启动浏览器</li><li>启动Wireshark数据包嗅探器。</li><li>在浏览器中输入以下URL <a href="http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html">http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html</a> 在弹出框中键入所请求的用户名和密码。</li><li>停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。</li><li>（注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-5数据包跟踪来回答以下问题；请参见上文注释。）</li></ul><p>现在来看看Wireshark输出。 您可能需要首先阅读HTTP身份验证相关信息，方法是在 <a href="http://frontier.userland.com/stories/storyReader$2159">http://frontier.userland.com/stories/storyReader$2159</a> 上查看“HTTP Access Authentication Framework ”上的易读材料。</p><p>回答下列问题：</p><ol start="18"><li><p>对于您的浏览器的初始HTTP GET消息，服务器响应（状态码和短语）是什么响应？</p><p>![image-20230416152712931](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152712931.png)</p><p>未授权</p></li><li><p>当您的浏览器第二次发送HTTP GET消息时，HTTP GET消息中包含哪些新字段？</p><p>![image-20230416152814670](&#x2F;Users&#x2F;trevorwu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230416152814670.png)</p><p>一个Credentials: 的字段</p></li></ol><p>您输入的用户名（wireshark-students）和密码（network）按照客户端HTTP GET消息中请求头的“Authorization: Basic ”的字符串（d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms&#x3D;）编码。虽然您的用户名和密码可能加密，但它们只是以一种称为Base64格式的格式进行编码。用户名和密码并没有加密！要确认这些，请访问 <a href="http://www.motobit.com/util/base64-decoder-encoder.asp">http://www.motobit.com/util/base64-decoder-encoder.asp</a> 并输入base64编码的字符串d2lyZXNoYXJrLXN0dWRlbnRz 并进行解码。瞧！您已从Base64编码转换为ASCII编码，因此应该看到您的用户名！要查看密码，请输入字符串Om5ldHdvcms&#x3D;的剩余部分，然后按解码。因为任何人都可以下载像Wireshark这样的工具，而且可以通过网络适配器嗅探数据包（不仅仅是自己的），任何人都可以从Base64转换为ASCII（你刚刚就这么做了！），所以你应该很清楚，WWW网站上的简单密码并不安全，除非采取其他措施。</p><p>wireshark自带解码….</p><p>不要害怕！ 正如我们将在第8章中看到的，有一些方法可以使WWW访问更加安全。然而，我们显然需要一些超出基本HTTP认证框架的知识！</p>]]></content>
    
    
    <summary type="html">在这个实验中，我们会探索HTTP协议的几个方面：基本的GET/response交互，HTTP消息格式，检索大型HTML文件，检索具有嵌入对象的HTML文件，HTTP认证和安全性</summary>
    
    
    
    
    <category term="computer network" scheme="https://trevoewu.github.io/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark Lab: IP v7.0</title>
    <link href="https://trevoewu.github.io/2023/04/20/Wireshark-Lab-IP-v7-0/"/>
    <id>https://trevoewu.github.io/2023/04/20/Wireshark-Lab-IP-v7-0/</id>
    <published>2023-04-20T10:22:06.000Z</published>
    <updated>2023-04-21T03:44:49.965Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Select the first ICMP Echo Request message sent by your computer, and expand the Internet Protocol part of the packet in the packet details window.(选择您的计算机发送的第一个 ICMP Echo Request 消息，并在数据包详细信息窗口中展开数据包的 Internet 协议部分)<br>不知道为什么, 我的电脑只能收到Time to live exceeded报文段.<span id="more"></span>结果是因为我在过滤了ICMP, 而<strong>traceroute默认使用UDP而不是ICMP</strong>, 所以只能收到路由器发给我的ICMP time to live exceeded 报文,告诉我的数据包被干掉了.</li></ul><p>tracert 默认使用 ICMP 包探测，traceroute 使用 UDP 包，也可以使用 ICMP 和 TCP 包探测, 带上参数-T即可.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-I      Use ICMP ECHO instead of UDP datagrams.  (A synonym for &quot;-P icmp&quot;).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">traceroute baidu.com 2000  # 使用baidu测试, 默认使用UDP, 数据报大小为2000byte<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>What is the IP address of your computer?</p></li><li><p>在 IP header 中，上层协议字段的值是多少?</p><p>我的IP地址: 10.51.172.226 </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421113757555.png" alt="image-20230421113757555"></p><p>这是traceroute发送的第一个数据报, 可以得到以下信息: </p><ul><li>该数据报是IP数据报, 上层协议为UDP</li><li>数据报被分片了, More Fragment字段被设为1</li><li>源IP是10.51.172.226, 这是host IP</li><li>目标IP是110,242,68,66, 这是Baidu.com的IP地址, 我用百度来测试.</li></ul></li><li><p>IP datagram 的有效负载中有多少 bytes? 说明如何 确定 payload bytes 的数。</p></li></ul><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421113848009.png" alt="image-20230421113848009"></p><p>payload &#x3D; Total Len - header Len &#x3D; 1500 - 20 &#x3D; 1480, 是的, 我直接发送了2000byte的报文</p><ul><li><p>此 IP 数据报是否已被分段(fragmented)?解释您如何确定数据报是否已被分段(fragmented)</p><p>是的, 前文有提到, 这里不再赘述.</p></li></ul><blockquote><p>接下来，通过单击 Source 列标题，根据 IP 源地址对跟踪的数据包进行排序，一个小的向下箭头应出现在 Source 旁边，如果箭头指向上方请再次单击“Source column header”。选择计算机发送的第一个 ICMP Echo Request 消息，然后展开“details of selected packet header”窗口中的 Internet 协议部分。在“listing of captured packets”窗 口中，您应该在第一个 ICMP 下面看到所有后续 ICMP 消息(可能还有计算器上运行的其他协议发送的其他散布数据包)，使用向下箭头浏览计算器发送的 ICMP 消息。</p></blockquote><ul><li><p>在您的计算器发送的这一系列 ICMP 消息中，IP 数据报中的哪些字段总有改变</p><p>使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">traceroute -I gaia.cs.umass.edu -80# 用作者给的网站测试, -I表示使用ICMP# The default probe datagram length is 40 bytes[traceroute manual]# 但是我使用作者提议用56作为数据报(ip datagrame)大小时, 收到以下警告: # traceroute: packet length must be &gt; 71# 所以这里数据报大小设为80, 实际上, 我使用不带数据报大小参数的命令时, 默认数据报大小为1380<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次抓包, 由于traceroute实际上会发送三个ICMP的数据报, 所以三个为一组.  所以可发现每一组的ID值差3, 当然是因为一组发了三个ICMP数据报啊..</p></li></ul><p>第一个:</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421113947335.png" alt="image-20230421113947335"></p><p>第二个: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114009587.png" alt="image-20230421114009587"></p><p>第三个: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114026434.png" alt="image-20230421114026434"></p><p>可以发现, Id, TTL, Header checksum改变了.</p><ul><li><p>哪些字段保持不变? 哪个字段必须保持不变? 哪些字段必须更改? 为什么?</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114245968.png" alt="image-20230421114245968"></p><ul><li>Version, Header Length , TOS(Differentiate Services Field差异化服务领域), Flag, TTL, Protocol, SIP,DIP保持不变</li><li>Version, Protocol, TOS, Header Len必须保持不变.</li><li>Identification, checksum,TTL必须更改</li></ul></li><li><p>描述您在 IP 数据报的标识字段的值中看到的模式</p></li></ul><p>每发一个ICMP的数据报, ID字段加一(不分片的情况下, 分片时一个IP数据报的不同片具有相同的ID)</p><ul><li>下一步(数据包仍按来源地址排序)查找最近的(第一跳)路由器发送到您的计算器的一系列 ICMP TTL 超出的回复讯息。</li><li>ID 字段和 TTL 字段的值是多少?</li></ul><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114303180.png" alt="image-20230421114303180"></p><ul><li><p>对于最近(第一跳)路由器发送到您的计算器的所有 ICMP TTL 超出的回复，这些值是否保持不变?为什么?</p><p>TTL保持不变, 但ID改变了. TTL都为64(可以改变, 理论上可以为1, 因为第一台路由器到我的主机一跳可达)</p><p>在不管是发回给我的time to live exceeded还是ICMP reply TTL的值都为64, 可能是默认的值.</p></li></ul><blockquote><p>单击“时间”列，再次按时间对数据包列表进行排序。</p></blockquote><ul><li>在将 pingplotter 中的数据包大小更改为 2000 后，查找计算机发送的第一个 ICMP Echo Request 消息。该消息是否已分片为多个 IP 数据报?</li><li>打印出碎片 IP 数据报的第一个片段。 IP 头中的哪些信息表明数据报已碎片 化? IP 头中的哪些信息表明这是第一个片段还是后一个片段? 这个 IP 数据报有多长?</li><li>打印出碎片 IP 数据报的第二个片段。 IP 标头中的哪些信息表明这不是第一 个数据报片段? 是否还有更多的片段? 你是如何知道的?</li></ul><p>是的, 该消息被分片了, 可以通过flag字段看出, Fragmen Offset 为1480, 而More Fragment为0 ,告诉这是第二个message, 那第一个到哪里去了呢?</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114317964.png" alt="image-20230421114317964"></p><p>Wireshark告诉我在frame 73, 于是我去寻找frame73</p><p><em>73frame和74frame的payload 和 为 1980, 因为规定了ICMP的IP数据报大小为2000, 但由于IP头部的20byte, 实际的payload恰好为1980byte</em></p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114327978.png" alt="image-20230421114327978"></p><p>注意到发到第一个message竟然不是ICMPmessage, 而是一个IPdatagram</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114340203.png" alt="image-20230421114340203"></p><p>打开IP头部, 我们发现, 这仍然是一个ICMP的数据报, 但是在IP的数据部分并没有ICMP头部.</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114350725.png" alt="image-20230421114350725"></p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114403647.png" alt="image-20230421114403647"></p><ul><li><p>在第一个和第二个片段中，IP 标头中哪些字段发生了变化?</p><p>第一个fregment: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114415389.png" alt="image-20230421114415389"></p><p>第二片: </p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114431692.png" alt="image-20230421114431692"></p><p>注意到红色部分发送了改变, 而蓝色部分没有改变, IP数据报用ID来标识多个片是否属于同一个IP数据报.</p></li></ul><blockquote><p>现在，在将 pingplotter 中的数据包大小更改为 3500 后，找到计算机发送的第一个 ICMP Echo Request 消息。</p></blockquote><ul><li><p>从原始数据报创建了多少个片?</p><p>三个片</p><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114440735.png" alt="image-20230421114440735"></p></li><li><p>片段中 IP 标头中的哪些字段发生了变化?</p><p>和上一个结论相同, 红色部分发送了改变, 而蓝色部分没有改变, IP数据报用ID来标识多个片是否属于同一个IP数据报.</p></li></ul><p><img src="/Wireshark-Lab-IP-v7-0/image-20230421114449611.png" alt="image-20230421114449611"></p>]]></content>
    
    
    <summary type="html">在本实验中, 我们将研究 IP 协议,重点关注IP datagram. 我们将通过分析在执行 traceroute 程序发送和接收的一系列 IP 数据报的过程来完成这个实验,我们将研究IP datagram 中的各个字段(fields)，并详细研究 IP fragmentation 的方法</summary>
    
    
    
    
    <category term="computer network" scheme="https://trevoewu.github.io/tags/computer-network/"/>
    
    <category term="lab" scheme="https://trevoewu.github.io/tags/lab/"/>
    
  </entry>
  
</feed>
