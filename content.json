{"meta":{"title":"楼兰","subtitle":"","description":"楼兰的Blog","author":"楼兰","url":"https://trevoewu.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-04-21T12:11:32.000Z","updated":"2023-04-21T12:12:24.531Z","comments":true,"path":"categories/index.html","permalink":"https://trevoewu.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-04-21T11:05:18.000Z","updated":"2023-04-21T11:15:05.927Z","comments":true,"path":"about/index.html","permalink":"https://trevoewu.github.io/about/index.html","excerpt":"","text":"施工中…"},{"title":"tags","date":"2023-04-21T12:23:46.000Z","updated":"2023-04-21T12:24:50.111Z","comments":true,"path":"tags/index.html","permalink":"https://trevoewu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"超市管理系统","slug":"超市管理系统","date":"2023-05-15T13:15:33.000Z","updated":"2023-05-19T13:42:46.033Z","comments":true,"path":"2023/05/15/超市管理系统/","link":"","permalink":"https://trevoewu.github.io/2023/05/15/%E8%B6%85%E5%B8%82%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"实战: 超市订单管理系统 为了方便表述和理解, 在编写MVC三层对应的代码时, 使用自顶向下, 但在实际的项目中, 编写代码工作往往是自底向上的. 搭建项目框架 编写数据库操作的基础公共类DB 数据库配置文件，这是一个资源文件，应该创建在maven项目的resources文件中 1234DRIVER=com.mysql.jdbc.DriverURL=jdbc:mysql://localhost:3307/smbms?useUnicode=true&amp;characterEncoding=utf-8USERNAME=rootPASSWORD= 使用静态代码块实现初始化参数 该类为数据库访问工具类，提供了获取数据库连接、执行查询和更新等常用操作的方法。 类名：DB 属性： DRIVER：String类型，表示数据库驱动名。 URL：String类型，表示数据库连接地址。 USERNAME：String类型，表示连接数据库的用户名。 PASSWORD：String类型，表示连接数据库的密码。 方法： close：用于释放数据库连接、预处理语句和结果集资源。 getConnection：用于获取数据库连接。 executeQuery：用于执行查询操作，返回一个结果集。 executeUpdate：用于执行更新操作，返回受影响的行数。 方法的参数： conn：Connection类型，表示数据库连接。 pstmt：PreparedStatement类型，表示预处理语句。 resSet：ResultSet类型，表示结果集。 query：String类型，表示要执行的SQL语句。 params：Object[]类型，表示SQL语句中的参数值。 在类中还定义了一个静态代码块，该代码块在类加载时会被执行。静态代码块中的主要作用是读取配置文件中的数据库连接参数，并将其赋值给类的静态属性。具体实现如下： 创建Properties对象。 通过类加载器加载配置文件为字节输入流。 使用Properties对象的load()方法加载字节输入流中的内容。 从Properties对象中获取数据库连接参数，并将其赋值给类的静态属性。 通过这种方式，可以在不修改Java代码的情况下，更改数据库连接参数，提高了代码的灵活性和可维护性。 1234567891011121314151617181920212223public class DB &#123; private static String DRIVER; private static String URL; private static String USERNAME; private static String PASSWORD; //静态代码块， 类加载的时候执行 static &#123; //读取配置文件 //1、创建properties对象 Properties properties = new Properties(); //2、通过类加载器加载资源文件为字节输入流 InputStream in = DB.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); try &#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; DRIVER = properties.getProperty(&quot;DRIVER&quot;); URL = properties.getProperty(&quot;URL&quot;); USERNAME = properties.getProperty(&quot;USERNAME&quot;); PASSWORD = properties.getProperty(&quot;PASSWORD&quot;); &#125;&#125; 编写数据库操作的公共方法 该类为数据库访问工具类，提供了获取数据库连接、执行查询和更新等常用操作的方法。 类名：DB 属性： DRIVER：String类型，表示数据库驱动名。 URL：String类型，表示数据库连接地址。 USERNAME：String类型，表示连接数据库的用户名。 PASSWORD：String类型，表示连接数据库的密码。 方法： close：用于释放数据库连接、预处理语句和结果集资源。 getConnection：用于获取数据库连接。 executeQuery：用于执行查询操作，返回一个结果集。 executeUpdate：用于执行更新操作，返回受影响的行数。 方法的参数： conn：Connection类型，表示数据库连接。 pstmt：PreparedStatement类型，表示预处理语句。 resSet：ResultSet类型，表示结果集。 query：String类型，表示要执行的SQL语句。 params：Object[]类型，表示SQL语句中的参数值。 该类还包含一个静态代码块，用于初始化数据库连接参数，但代码块的内容未给出，需要进行补充。 同时需要注意，该类并没有实现单例模式，每次获取数据库连接都会重新创建一个新的连接，这可能会导致性能问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package util;public class DB &#123; private static String DRIVER; private static String URL; private static String USERNAME; private static String PASSWORD; /* 静态代码块， 类加载的时候执行 */ //释放链接资源 public static void close(Connection conn, PreparedStatement pstmt, ResultSet resSet) throws SQLException &#123; if(resSet != null)&#123; resSet.close(); &#125; if(pstmt != null)&#123; pstmt.close(); &#125; if(conn != null) &#123; conn.close(); &#125; &#125; //获取数据库链接 public static Connection getConnection() throws SQLException, ClassNotFoundException &#123; Class.forName(DRIVER); String url = URL; String username = USERNAME; String password = PASSWORD; // 2.连接数据库,代表数据库 Connection connection = DriverManager.getConnection(url, username, password); return connection; &#125; //执行查询, 返回结果集 public static ResultSet executeQuery(Connection conn,String query,Object[] params) throws SQLException, ClassNotFoundException&#123; ResultSet resultSet = null; if(conn != null &amp;&amp; !query.isEmpty() &amp;&amp; params != null)&#123; //预处理 PreparedStatement statement = conn.prepareStatement(query); for (int i = 0; i &lt; params.length;i++)&#123; //设置SQL 语句中的参数 if(params[i] instanceof String)&#123; statement.setString(i+1,params[i].toString()); &#125; else if(params[i] instanceof Integer)&#123; statement.setInt(i+1,Integer.parseInt(params[i].toString())); &#125; else &#123; statement.setObject(i+1,params[i]); &#125; &#125; //执行 resultSet = statement.executeQuery(); &#125; return resultSet; &#125; //执行更新， 返回影响行数 public static int executeUpdate(Connection conn,String query,Object[] params) throws SQLException &#123; int affectedRows = 0; if(conn != null &amp;&amp; !query.isEmpty() &amp;&amp; params != null)&#123; //预处理 PreparedStatement statement = conn.prepareStatement(query); for (int i = 0; i &lt; params.length;i++)&#123; //设置SQL 语句中的参数 if(params[i] instanceof String)&#123; statement.setString(i+1,params[i].toString()); &#125; else if(params[i] instanceof Integer)&#123; statement.setInt(i+1,Integer.parseInt(params[i].toString())); &#125; else &#123; statement.setObject(i+1,params[i]); &#125; &#125; //执行 affectedRows = statement.executeUpdate(); &#125; return affectedRows; &#125;&#125; 登录功能实现 前端页面编写 前端页面由kuang提供 1234567891011121314151617&lt;%-- header--%&gt;&lt;form class=&quot;loginForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot; name=&quot;actionForm&quot; id=&quot;actionForm&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;info&quot;&gt;$&#123;error&#125;&lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;input-text&quot; id=&quot;userCode&quot; name=&quot;userCode&quot; placeholder=&quot;请输入用户名&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;userPassword&quot; name=&quot;userPassword&quot; placeholder=&quot;请输入密码&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;subBtn&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; &lt;/div&gt;&lt;/form&gt;&lt;%-- footer--%&gt; 登录处理Servlet实现 在前端form表单的action属性值我们可以看到提交的URL, 所以, 我们需要编写对应的Servlet来处理这个请求 1action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot; 创建登录处理Servlet 以下是一个名为“Login”的Java servlet类，用于处理HTTP GET请求。该类包括对“UserService”实例的引用，该实例用于从数据库中检索用户信息。 在“doGet”方法中，servlet从HTTP请求中检索userCode和password参数。然后它创建一个“UserServiceImpl”类的新实例（该类实现了“UserService”接口），并调用其“findByUserCode”方法，以根据给定的用户代码从数据库中检索用户对象。 如果用户对象不为null，则servlet检查用户密码是否与给定密码匹配。如果匹配，则servlet使用用户对象设置名为“USER_SESSION”的会话属性，并将用户重定向到“/jsp/frame.jsp”。如果密码不匹配，则servlet使用错误消息设置名为“error”的会话属性，并将用户重定向回“/login.jsp”。 请注意，此代码片段不完整，因为它缺少有关导入，它所依赖的接口和类，以及servlet配置的信息。 12345678910111213141516171819public class Login extends HttpServlet &#123; private UserService service; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String userCode = req.getParameter(&quot;userCode&quot;); String password = req.getParameter(&quot;userPassword&quot;); service = new UserServiceImpl(); User user = null; user = service.findByUserCode(userCode); if(user != null) &#123; if(user.getUserPassword().equals(password)) &#123; req.getSession().setAttribute(Constant.USER_SESSION,user); resp.sendRedirect(&quot;/jsp/frame.jsp&quot;); &#125; else &#123; req.getSession().setAttribute(&quot;error&quot;,&quot;username or password incorrect&quot;); resp.sendRedirect(&quot;/login.jsp&quot;); &#125; &#125; &#125; 映射 servlet 这段代码是一个 servlet 配置的 XML 部分，它用于将请求的 URL 映射到特定的 servlet 上。这段配置指定了一个名为 “Login” 的 servlet，使用了完整的类名 servlet.Login，并将它映射到 URL “/login.do” 上。 这意味着，当用户在浏览器中访问 “/login.do” 时，容器将调用 servlet.Login 的 service() 方法来处理该请求。映射 servlet 的操作是 web 应用的一部分，它在 web.xml 文件中进行配置。 12345678&lt;servlet&gt; &lt;servlet-name&gt;Login&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.Login&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写Service层代码 该代码是一个 Java 类 UserServiceImpl，实现了一个接口 UserService。该类包含了两个方法： findByUserCode(String userCode)：查找数据库中对应用户的信息，该方法返回一个 User 对象。 updateUser(Integer id, String key, String value)：更新数据库中用户的信息，该方法返回一个 boolean 类型的值，表示更新是否成功。 在这个类中，私有成员变量 dao 是一个 UserDao 类型的变量，通过该变量调用 UserDaoImpl 类中的方法来访问数据库。在 findByUserCode 和 updateUser 方法中，都需要先通过 dao 实例化一个 UserDaoImpl 对象来调用相应的方法。 1234567891011121314151617public class UserServiceImpl implements UserService &#123; private UserDao dao; @Override public User findByUserCode(String userCode)&#123; dao = new UserDaoImpl(); User user = dao.findByUserCode(userCode); return user; &#125; @Override public boolean updateUser(Integer id, String key, String value) &#123; dao = new UserDaoImpl(); int i = 0; i = dao.updateUser(id, key, value); return i &gt; 0 ? true : false; &#125;&#125; DAO层代码 这段代码是一个Dao层的实现类，用于和数据库交互，提供了对User表的查询和更新方法。下面是代码的分析： findByUserCode(String userCode) 方法：根据传入的用户名参数 userCode 查询对应的用户记录，并返回一个User对象。该方法使用了数据库连接池技术，在执行完查询后会关闭连接。方法中首先初始化参数，然后执行SQL语句查询结果集，遍历结果集将数据封装到User对象中，最后关闭连接和结果集，返回User对象。 updateUser(Integer id, String key,String value) 方法：根据传入的参数更新User表中的数据。该方法也使用了数据库连接池技术，在执行完更新后会关闭连接。方法中首先判断传入的参数是否为空，然后执行SQL语句更新数据，最后关闭连接，返回更新结果的影响行数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class UserDaoImpl implements UserDao&#123; private User user; private Connection conn; private String sql; @Override public User findByUserCode(String userCode)&#123; //2. 初始化参数 Object[] params = &#123;userCode&#125;; ResultSet set; sql = &quot;SELECT * FROM smbms_user Where userCode = ?&quot;; try &#123; conn = DB.getConnection(); set = DB.executeQuery(conn, sql,params); if(set != null)&#123; user = new User(); while (set.next()) &#123; user.setUserPassword(set.getString(&quot;userPassword&quot;)); //一大串赋值代码... user.setWorkPicPath(&quot;workPicPath&quot;); &#125; &#125; else &#123; return null; &#125; //关闭链接和结果集 DB.close(conn,null,set); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return user; &#125; @Override public int updateUser(Integer id, String key,String value) &#123; int affectedRow = 0; if(id != null&amp;&amp; value != null &amp;&amp; key != null)&#123; Connection conn = null; sql = &quot;UPDATE smbms_user SET &quot;+key+&quot; = ? WHERE id = ? &quot;; Object[] params = &#123;value,id&#125;; try &#123; conn = DB.getConnection(); affectedRow = DB.executeUpdate(conn, sql, params); DB.close(conn,null,null); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; return affectedRow; &#125; 密码修改实现 前端页面 JSP部分: 页面显示 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@include file=&quot;/jsp/common/head.jsp&quot; %&gt;&lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;location&quot;&gt; &lt;strong&gt;你现在所在的位置是:&lt;/strong&gt; &lt;span&gt;密码修改页面&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;providerAdd&quot;&gt; &lt;form id=&quot;userForm&quot; name=&quot;userForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;savepwd&quot;/&gt; &lt;!--div的class 为error是验证错误，ok是验证成功--&gt; &lt;div class=&quot;info&quot;&gt;$&#123;message&#125;&lt;/div&gt; &lt;div class=&quot;&quot;&gt; &lt;label for=&quot;oldPassword&quot;&gt;旧密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;oldpassword&quot; id=&quot;oldpassword&quot; value=&quot;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;newPassword&quot;&gt;新密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;newpassword&quot; id=&quot;newpassword&quot; value=&quot;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;newPassword&quot;&gt;确认新密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;rnewpassword&quot; id=&quot;rnewpassword&quot; value=&quot;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div class=&quot;providerAddBtn&quot;&gt; &lt;!--&lt;a href=&quot;#&quot;&gt;保存&lt;/a&gt;--&gt; &lt;input type=&quot;button&quot; name=&quot;save&quot; id=&quot;save&quot; value=&quot;保存&quot; class=&quot;input-button&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&lt;%@include file=&quot;/jsp/common/foot.jsp&quot; %&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/js/pwdmodify.js&quot;&gt;&lt;/script&gt; 这是一个用 JSP（JavaServer Pages）编写的网页代码，用于修改密码。页面包括一个表单，用户可以在其中输入旧密码、新密码和确认新密码。表单使用POST方法提交到服务器，并使用“/jsp/user.do” URL。 页面包括一个消息区域，用于显示任何错误消息。页面还包括指向名为“pwdmodify.js”的 JavaScript 文件的链接。这个文件应该包含表单的客户端验证逻辑。 页面使用 JSP 表达式语言（EL）将动态内容插入到 HTML 中。例如，页面使用表达式 “${pageContext.request.contextPath}/statics/js/pwdmodify.js” 插入一个链接到 CSS 文件。“${pageContext.request.contextPath}” 表达式计算为 web 应用程序的上下文路径，用于构造 CSS 文件的完整 URL。 JavaScript 表单的客户端验证逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var oldpassword = null;var newpassword = null;var rnewpassword = null;var saveBtn = null;$(function()&#123; oldpassword = $(&quot;#oldpassword&quot;); newpassword = $(&quot;#newpassword&quot;); rnewpassword = $(&quot;#rnewpassword&quot;); saveBtn = $(&quot;#save&quot;); oldpassword.next().html(&quot;*&quot;); newpassword.next().html(&quot;*&quot;); rnewpassword.next().html(&quot;*&quot;); oldpassword.on(&quot;blur&quot;,function()&#123; $.ajax(&#123; type:&quot;GET&quot;, url:path+&quot;/jsp/user.do&quot;, data:&#123;method:&quot;pwdmodify&quot;,oldpassword:oldpassword.val()&#125;, dataType:&quot;json&quot;, success:function(data)&#123; if(data.result == &quot;true&quot;)&#123;//旧密码正确 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else if(data.result == &quot;false&quot;)&#123;//旧密码输入不正确 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 原密码输入不正确&quot;,false); &#125;else if(data.result == &quot;sessionerror&quot;)&#123;//当前用户session过期，请重新登录 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 当前用户session过期，请重新登录&quot;,false); &#125;else if(data.result == &quot;error&quot;)&#123;//旧密码输入为空 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 请输入旧密码&quot;,false); &#125; &#125;, error:function(data)&#123; //请求出错 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 请求错误&quot;,false); &#125; &#125;); &#125;).on(&quot;focus&quot;,function()&#123; validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入原密码&quot;,false); &#125;); newpassword.on(&quot;focus&quot;,function()&#123; validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 密码长度必须是大于6小于20&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(newpassword.val() != null &amp;&amp; newpassword.val().length &gt; 5 &amp;&amp; newpassword.val().length &lt; 20 )&#123; validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 密码输入不符合规范，请重新输入&quot;,false); &#125; &#125;); rnewpassword.on(&quot;focus&quot;,function()&#123; validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入与上面一致的密码&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(rnewpassword.val() != null &amp;&amp; rnewpassword.val().length &gt; 5 &amp;&amp; rnewpassword.val().length &lt; 20 &amp;&amp; newpassword.val() == rnewpassword.val())&#123; validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 两次密码输入不一致，请重新输入&quot;,false); &#125; &#125;); saveBtn.on(&quot;click&quot;,function()&#123; oldpassword.blur(); newpassword.blur(); rnewpassword.blur(); if( oldpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; newpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; rnewpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot;)&#123; if(confirm(&quot;确定要修改密码？&quot;))&#123; $(&quot;#userForm&quot;).submit(); &#125; &#125; &#125;);&#125;); 这是一个 JavaScript 代码段，它使用 jQuery 库为一个包含密码修改表单的网页添加了客户端验证逻辑。代码使用 AJAX 技术从服务器获取 JSON 格式的响应数据，以验证用户输入的旧密码是否正确，并在页面上显示相关提示信息。 代码中首先定义了四个变量，分别是旧密码、新密码、确认新密码和提交按钮的 jQuery 对象。然后使用 $() 函数将代码包装在一个回调函数中，确保代码在文档加载完成后才执行。回调函数内部做了以下工作： 通过选择器获取页面上的旧密码输入框、新密码输入框、确认新密码输入框和提交按钮，并将它们的 jQuery 对象赋值给前面定义的四个变量。 为旧密码输入框绑定 blur 事件处理函数，当输入框失去焦点时，使用 $.ajax() 函数向服务器发送 GET 请求，验证用户输入的旧密码是否正确，并根据服务器返回的响应数据显示相应的提示信息。在成功回调函数中，根据 data.result 的值判断旧密码是否正确，并通过 validateTip() 函数显示相应的提示信息。在失败回调函数中，显示请求出错的提示信息。 为旧密码输入框绑定 focus 事件处理函数，当输入框获得焦点时，显示输入提示信息。 为新密码输入框绑定 focus 和 blur 事件处理函数，当输入框获得焦点时，显示输入提示信息；当输入框失去焦点时，判断用户输入的新密码是否符合规范，如果符合则显示正确提示，否则显示错误提示。 为确认新密码输入框绑定 focus 和 blur 事件处理函数，当输入框获得焦点时，显示输入提示信息；当输入框失去焦点时，判断用户输入的确认新密码是否与新密码一致，如果一致则显示正确提示，否则显示错误提示。 为提交按钮绑定 click 事件处理函数，当按钮被点击时，先让旧密码、新密码和确认新密码输入框失去焦点，然后判断它们的验证状态是否都为 true，如果是，则显示确认修改密码的提示框，如果用户点击确定，则提交表单，将新密码保存到服务器上。 编写处理Servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class UserDo extends HttpServlet &#123; private UserService service; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getParameter(&quot;method&quot;); if(&quot;savepwd&quot;.equals(method))&#123; savePwd(req, resp); &#125; else if(&quot;pwdmodify&quot;.equals(method))&#123; pwdModify(req, resp); &#125; &#125; protected void savePwd(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //拿到USer Session , 用于得到用户id HttpSession session = req.getSession(); User user = (User) session.getAttribute(Constant.USER_SESSION); String newPwd = req.getParameter(&quot;newpassword&quot;); System.out.println(&quot;用户输入的：new password: &quot;+newPwd); System.out.println(&quot;Session password: &quot;+user.getUserPassword()+&quot;, id: &quot;+ user.getId()); Integer id = user.getId(); boolean flag; //method 值为 savepwd, 表示用户执行修改密码操作 if(newPwd != null)&#123; service = new UserServiceImpl(); flag = service.updateUser(id, &quot;userPassword&quot;, newPwd); //修改成功 if(flag)&#123; System.out.println(&quot;修改成功&quot;); req.setAttribute(&quot;message&quot;,&quot;密码修改成功， 请重新登录&quot;); // 移除Session session.removeAttribute(Constant.USER_SESSION); &#125; else &#123; System.out.println(&quot;密码修改失败&quot;); req.setAttribute(&quot;message&quot;,&quot;密码修改失败&quot;); &#125; &#125; else &#123; req.setAttribute(&quot;message&quot;,&quot;新密码格式错误&quot;); &#125; //转发到当前页面, 不用重定向而使用转发是为了传统参数（attribute) 通知前端密码修改结果（by attribute message） req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req,resp); &#125; /* 由ajax发起的密码查询请求， 用户进行密码修改时触发 放回前端json， ajax用于比对旧密码正确性, */ protected void pwdModify(HttpServletRequest req, HttpServletResponse resp)&#123; HttpSession session = req.getSession(); Object user = session.getAttribute(Constant.USER_SESSION); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if(user != null)&#123; String password = ((User) user).getUserPassword(); String inputPwd = req.getParameter(&quot;oldpassword&quot;); if(inputPwd != null &amp;&amp; inputPwd.length() &gt; 0)&#123; //旧密码正确 if(inputPwd.equals(password))&#123; map.put(&quot;result&quot;,&quot;true&quot;); &#125; else &#123; //旧密码不正确 map.put(&quot;result&quot;,&quot;false&quot;); &#125; &#125; else &#123; //密码输入为空 map.put(&quot;result&quot;,&quot;error&quot;); &#125; &#125; else &#123; //session timeout map.put(&quot;result&quot;,&quot;sessionerror&quot;); &#125; //返回前端json数据 resp.setContentType(&quot;application/json&quot;); try &#123; PrintWriter writer = resp.getWriter(); writer.write(JSONArray.toJSONString(map)); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 这段代码是一个Java Web应用程序中的Servlet，用于处理用户密码修改操作。 在doGet()方法中，根据请求参数&quot;method&quot;的值进行不同的操作。如果&quot;method&quot;的值是&quot;savepwd&quot;，则调用savePwd()方法，保存新密码；如果&quot;method&quot;的值是&quot;pwdmodify&quot;，则调用pwdModify()方法，用于检查旧密码是否正确。 在savePwd()方法中，首先从Session中获取当前用户的信息，然后获取新密码，并使用UserService接口的实现类UserServiceImpl来更新用户密码。如果更新成功，将信息存储在请求属性中，并移除Session中的用户信息，最后将请求转发到密码修改页面。 在pwdModify()方法中，首先获取当前用户的信息，然后获取旧密码。如果旧密码不为空，则将输入的旧密码与Session中存储的旧密码进行比较。如果输入的旧密码与Session中的旧密码相同，则返回前端JSON数据，表示旧密码正确；否则返回JSON数据，表示旧密码不正确。 需要注意的是，在返回JSON数据之前，需要设置响应的Content-Type为&quot;application/json&quot;。 映射Servlet 12345678&lt;servlet&gt; &lt;servlet-name&gt;userDo&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.UserDo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;userDo&lt;/servlet-name&gt; &lt;url-pattern&gt;/jsp/user.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 用户管理底层实现 分页实现 导入分页支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package util;public class PageSupport &#123; //当前页码-来自于用户输入， 1表示第一页， 用于sql做limit查询 limit startPage, length private int currentPageNo = 1; //总数量（表） private int totalCount = 0; //页面容量,每一页展示多少数据 private int pageSize = 0; //总页数: totalCount/pageSize（+1） private int totalPageCount = 1; public int getCurrentPageNo() &#123; return currentPageNo; &#125; public void setCurrentPageNo(int currentPageNo) &#123; if(currentPageNo &gt; 0)&#123; this.currentPageNo = currentPageNo; &#125; &#125; public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; if(totalCount &gt; 0)&#123; this.totalCount = totalCount; //设置总页数 this.setTotalPageCountByRs(); &#125; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; if(pageSize &gt; 0)&#123; this.pageSize = pageSize; &#125; &#125; public int getTotalPageCount() &#123; return totalPageCount; &#125; public void setTotalPageCount(int totalPageCount) &#123; this.totalPageCount = totalPageCount; &#125; public void setTotalPageCountByRs()&#123; if(this.totalCount % this.pageSize == 0)&#123; this.totalPageCount = this.totalCount / this.pageSize; &#125;else if(this.totalCount % this.pageSize &gt; 0)&#123; this.totalPageCount = this.totalCount / this.pageSize + 1; &#125;else&#123; this.totalPageCount = 0; &#125; &#125;&#125; 这段代码是一个用于分页的工具类 PageSupport。它包含了用于处理分页逻辑的属性和方法。 让我们逐个分析这些属性和方法： currentPageNo（当前页码）: 保存当前页的页码，默认为1（表示第一页）。用户可以通过调用 setCurrentPageNo() 方法来设置当前页码。 totalCount（总数量）: 表示总的数据量。用户可以通过调用 setTotalCount() 方法来设置总数量。 pageSize（页面容量）: 每一页显示的数据数量。用户可以通过调用 setPageSize() 方法来设置页面容量。 totalPageCount（总页数）: 表示总的页数，根据总数量和页面容量计算得出。用户可以通过调用 getTotalPageCount() 方法来获取总页数。 setTotalPageCountByRs() 方法: 根据总数量和页面容量计算总页数，并将结果设置给 totalPageCount 属性。 此外，对于一些属性的设置，代码中进行了一些限制条件的判断： currentPageNo 和 pageSize 必须大于0，否则将不进行设置。 totalCount 必须大于0，否则将不进行设置，并且会将 totalPageCount 设置为0。 这个工具类主要用于在分页查询中计算总页数和进行当前页码的设置。 前端 Header下用户管理二级菜单 1&lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do?method=query&quot;&gt;用户管理&lt;/a&gt;&lt;/li&gt; 点击这个菜单, 跳转到/jsp/user.do?method=query这个请求, user.do是对应的处理请求的Servlet, 问号后面是通过请求传递的参数, 为method = query, Servlet可以根据这个参数对请求的不同类型做对应的处理, 实现Servlet的复用. 用户管理界面: 1234567891011121314151617181920212223242526272829303132 &lt;div class=&quot;search&quot;&gt; &lt;form method=&quot;get&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do&quot;&gt; &lt;input name=&quot;method&quot; value=&quot;query&quot; class=&quot;input-text&quot; type=&quot;hidden&quot;&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input name=&quot;queryname&quot; class=&quot;input-text&quot; type=&quot;text&quot; value=&quot;$&#123;queryUserName &#125;&quot;&gt; &lt;span&gt;用户角色：&lt;/span&gt; &lt;select name=&quot;queryUserRole&quot;&gt; &lt;c:if test=&quot;$&#123;roleList != null &#125;&quot;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;c:forEach var=&quot;role&quot; items=&quot;$&#123;roleList&#125;&quot;&gt; &lt;option &lt;c:if test=&quot;$&#123;role.id == queryUserRole &#125;&quot;&gt;selected=&quot;selected&quot;&lt;/c:if&gt; value=&quot;$&#123;role.id&#125;&quot;&gt;$&#123;role.roleName&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/c:if&gt; &lt;/select&gt; &lt;input type=&quot;hidden&quot; name=&quot;pageIndex&quot; value=&quot;1&quot;/&gt; &lt;input value=&quot;查 询&quot; type=&quot;submit&quot; id=&quot;searchbutton&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;!--用户--&gt;/* 用户的mapping代码*/ &lt;input type=&quot;hidden&quot; id=&quot;totalPageCount&quot; value=&quot;$&#123;totalPageCount&#125;&quot;/&gt; &lt;c:import url=&quot;rollpage.jsp&quot;&gt; &lt;c:param name=&quot;totalCount&quot; value=&quot;$&#123;totalCount&#125;&quot;/&gt; &lt;c:param name=&quot;currentPageNo&quot; value=&quot;$&#123;currentPageNo&#125;&quot;/&gt; &lt;c:param name=&quot;totalPageCount&quot; value=&quot;$&#123;totalPageCount&#125;&quot;/&gt; &lt;/c:import&gt;&lt;/div&gt;&lt;/section&gt; 这段代码展示了一个搜索表单和与分页相关的部分。 &lt;div class=&quot;search&quot;&gt; 标签: 定义一个搜索的区域。 &lt;form&gt; 标签: 定义了一个表单，使用 GET 方法提交到 $&#123;pageContext.request.contextPath&#125;/jsp/user.do。 &lt;input&gt; 标签: 设置了一个隐藏字段 method，值为 &quot;query&quot;，用于指定查询的方法。 &lt;input&gt; 标签: 创建了一个文本输入框，名称为 queryname，值为 $&#123;queryUserName&#125;，显示了之前查询的用户名。 &lt;select&gt; 标签: 创建了一个下拉选择框，名称为 queryUserRole。使用了 JSTL 标签 &lt;c:if&gt; 进行条件判断，如果 roleList 不为 null，将会显示选项。 &lt;option&gt; 标签: 设置了一个默认选项 &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt;，然后使用 &lt;c:forEach&gt; 遍历 roleList 中的角色，并将角色的名称和 ID 设置为选项的值。使用 &lt;c:if&gt; 判断当前角色是否与 queryUserRole 相等，如果相等，则设置该选项为选中状态。 &lt;input&gt; 标签: 设置了一个隐藏字段 pageIndex，值为 1 &lt;input&gt; 标签: 设置了一个隐藏字段 totalPageCount，值为 $&#123;totalPageCount&#125;。 &lt;c:import&gt; 标签: 导入了一个名为 rollpage.jsp 的页面，并传递了三个参数 totalCount、currentPageNo 和 totalPageCount 的值。 这段代码展示了一个搜索表单，用户可以输入用户名和选择用户角色进行查询。同时，还包含了与分页相关的部分，包括当前页码、总页数和总数量的显示。 我们观察这段代码, 这个form表单的一部分代码, 分别展示了提交的目的地 $&#123;pageContext.request.contextPath &#125;/jsp/user.do 以及 一个隐藏域, 包含一个熟悉 method 值为 query, 是不是, 很熟悉, 没错, 这个Servlet和Header菜单进入管理用户界面所发起的请求是一样的, 也就是说, 是一个Servlet的相同处理过程. 为什么会这样呢? 这是因为查询和展示用户信息(未筛选时) 本质是一样的. 12&lt;form method=&quot;get&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do&quot;&gt; &lt;input name=&quot;method&quot; value=&quot;query&quot; class=&quot;input-text&quot; type=&quot;hidden&quot;&gt; DAO层 int getUserCount() 12345678910111213141516171819202122232425262728public int getUserCount(Connection conn, String userName, int userRole) &#123; int count = 0; StringBuffer sql = new StringBuffer(); sql.append(&quot;SELECT count(1) as count from smbms_user s, smbms_role r where s.userRole = r.id&quot; ); ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); ResultSet rs = null; if(userName != null)&#123; sql.append(&quot; and userName like ? &quot;); list.add(&quot;%&quot;+userName+&quot;%&quot;); &#125; if(userRole &gt; 0)&#123; sql.append(&quot; and userRole like ? &quot;); list.add(&quot;%&quot;+userRole+&quot;%&quot;); &#125; System.out.println(&quot;sql----&gt; &quot;+sql.toString()); try &#123; rs = DB.executeQuery(conn, sql.toString(), list.toArray()); while (rs.next()) &#123; count = rs.getInt(&quot;count&quot;); &#125; DB.close(null,null,rs); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return count;&#125; 这段代码是一个方法 getUserCount，用于查询符合条件的用户数量。 让我们逐行解释这段代码： int getUserCount(Connection conn, String userName, int userRole): 这是一个方法声明，它接受一个数据库连接对象 conn、一个用户名 userName 和一个用户角色 userRole 作为参数，并返回一个整数表示符合条件的用户数量。 int count = 0;: 初始化一个计数器变量 count，用于存储查询结果的数量。 StringBuffer sql = new StringBuffer();: 创建一个 StringBuffer 对象 sql，用于构建 SQL 查询语句。 sql.append(&quot;SELECT count(1) as count from smbms_user s, smbms_role r where s.userRole = r.id&quot;);: 将基本的查询语句添加到 sql 对象中，查询用户表 smbms_user 和角色表 smbms_role，并通过 userRole 字段进行关联。 ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();: 创建一个 ArrayList 对象 list，用于存储查询条件的参数值。 ResultSet rs = null;: 初始化一个 ResultSet 对象 rs，用于存储查询结果集。 if(userName != null) &#123; ... &#125;: 如果 userName 不为 null，则将一个条件子句添加到 sql 对象中，使用 LIKE 运算符进行模糊匹配，并将匹配参数添加到 list 中。 if(userRole &gt; 0) &#123; ... &#125;: 如果 userRole 大于 0，则将另一个条件子句添加到 sql 对象中，同样使用 LIKE 运算符进行匹配，并将匹配参数添加到 list 中。 System.out.println(&quot;sql----&gt; &quot;+sql.toString());: 打印输出最终生成的 SQL 查询语句，方便调试和查看。 rs = DB.executeQuery(conn, sql.toString(), list.toArray());: 执行 SQL 查询，并将结果存储在 rs 中。DB.executeQuery() 是一个执行查询语句的方法，接受数据库连接对象、SQL 查询语句和参数值数组作为参数。 while (rs.next()) &#123; ... &#125;: 遍历查询结果集，将每行的计数值存储到 count 变量中。 DB.close(null,null,rs);: 关闭结果集、语句和连接对象，释放资源。DB.close() 是一个关闭数据库资源的方法，接受三个参数：结果集、语句和连接对象。 return count;: 返回符合条件的用户数量。 该方法的作用是查询数据库中符合给定用户名和用户角色条件的用户数量，并将结果返回。 ==getUserList== 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public List&lt;User&gt; getUserList(Connection conn, String userName, int userRole,int currPage, int pageSize) &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); if(conn != null) &#123; //准备要使用的对象 ArrayList&lt;Object&gt; params = new ArrayList&lt;&gt;(); ResultSet rs = null; StringBuffer sql = new StringBuffer(); try &#123; //编写sql sql.append(&quot;SELECT * from smbms_user u ,smbms_role r Where u.userRole = r.id &quot;); //如果用户名不为空， 表示有用户名查询要求，追加限定条件 if(userName != null)&#123; sql.append(&quot; AND userName like ? &quot;); params.add(&quot;%&quot;+userName+&quot;%&quot;); &#125; //同上... if(userRole != 0)&#123; sql.append(&quot; and userRole = ?&quot;); params.add(userRole); &#125; sql.append(&quot; ORDER BY u.creationDate DESC LIMIT ?,? &quot;);//在sql最后追加一个排序和分页 //5 //1 5 //2 10 //3 15 currPage = (currPage-1)*pageSize;//减一的原因就是MYSQL分页的index从0开始 params.add(currPage);//从哪一个下标开始 params.add(pageSize);//从currentPageNo连续取几个 System.out.println(&quot;sql---&gt;&quot;+sql.toString()); //执行sql， 返回结果集, ⚠️需要把sql转化为字符串， params 转化为数组 rs = DB.executeQuery(conn,sql.toString(),params.toArray()); if(rs != null)&#123; while (rs.next())&#123; User user = new User(); user.setUserPassword(rs.getString(&quot;userPassword&quot;)); user.setId(rs.getInt(&quot;id&quot;)); user.setUserCode(rs.getString(&quot;userCode&quot;)); user.setUserName(rs.getString(&quot;userName&quot;)); user.setAddress(rs.getString(&quot;address&quot;)); user.setBirthday((Date) rs.getObject(&quot;birthday&quot;)); user.setGender(rs.getInt(&quot;gender&quot;)); user.setPhone(rs.getString(&quot;phone&quot;)); user.setIdPicPath(rs.getString(&quot;idPicPath&quot;)); user.setUserRole(rs.getInt(&quot;userRole&quot;)); user.setCreatedBy(rs.getInt(&quot;createdBy&quot;)); user.setCreationDate( rs.getDate(&quot;creationDate&quot;)); user.setModifyBy(rs.getInt(&quot;modifyBy&quot;)); user.setModifyDate(rs.getDate(&quot;modifyDate&quot;)); user.setUserRoleName(rs.getString(&quot;roleName&quot;)); userList.add(user);// System.out.println(user.toString()); &#125; &#125; DB.close(null,null,rs); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; else &#123; return null; &#125; return userList; &#125; 这段代码是一个方法 getUserList，用于根据给定的用户名、用户角色、当前页码和页面大小获取符合条件的用户列表。 让我们逐行解释这段代码： public List&lt;User&gt; getUserList(Connection conn, String userName, int userRole, int currPage, int pageSize): 这是一个方法声明，它接受一个数据库连接对象 conn、一个用户名 userName、一个用户角色 userRole、当前页码 currPage 和页面大小 pageSize 作为参数，并返回一个 List&lt;User&gt; 类型的用户列表。 List&lt;User&gt; userList = new ArrayList&lt;&gt;();: 创建一个 ArrayList 对象 userList，用于存储用户列表。 if(conn != null) &#123; ... &#125; else &#123; return null; &#125;: 检查数据库连接对象是否为 null，如果为 null，则直接返回 null。 ArrayList&lt;Object&gt; params = new ArrayList&lt;&gt;();: 创建一个 ArrayList 对象 params，用于存储查询条件的参数值。 ResultSet rs = null;: 初始化一个 ResultSet 对象 rs，用于存储查询结果集。 StringBuffer sql = new StringBuffer();: 创建一个 StringBuffer 对象 sql，用于构建 SQL 查询语句。 sql.append(&quot;SELECT * from smbms_user u ,smbms_role r Where u.userRole = r.id &quot;);: 将基本的查询语句添加到 sql 对象中，查询用户表 smbms_user，和角色表smbms_role , 这里进行了多表的联合查询, 是为了给user(Bean)的RoleNa m e赋值, 以便前端使用. if(userName != null) &#123; ... &#125;: 如果 userName 不为 null，则将一个条件子句添加到 sql 对象中，使用 LIKE 运算符进行模糊匹配，并将匹配参数添加到 params 中。 if(userRole != 0) &#123; ... &#125;: 如果 userRole 不为 0，则将另一个条件子句添加到 sql 对象中，限定用户角色，并将角色参数添加到 params 中。 sql.append(&quot; ORDER BY u.creationDate DESC LIMIT ?,? &quot;);: 在查询语句的末尾追加一个排序和分页的部分，按照 creationDate 字段降序排列，并使用 LIMIT 限制查询结果的起始位置和数量。 currPage = (currPage-1)*pageSize;: 计算实际的起始位置，根据当前页码和页面大小，减一是因为 MYSQL 分页的索引从 0 开始。 params.add(currPage);: 将起始位置参数添加到 params 中。 params.add(pageSize);: 将页面大小参数添加到 params 中。 System.out.println(&quot;sql---&gt;&quot;+sql.toString());: 打印输出最终生成的 SQL 查询语句，方便调试和查看。 rs = DB.executeQuery(conn, sql.toString(), params.toArray());: 执行 SQL 查询，并将结果存储在 rs 中。` ​ ==getRoleList== 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;Role&gt; getRolelist(Connection conn, int id) &#123; //prevent roleList List&lt;Role&gt; roleList = new ArrayList&lt;&gt;(); if(conn != null)&#123; try &#123; ResultSet rs = null; List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); StringBuffer sql = new StringBuffer(); //edit sql expression sql.append(&quot;SELECT * FROM smbms_role &quot;); //输入0表查询全表， 输入&gt;0 为sql拼接条件， 同时准备参数列表 if(id &gt; 0)&#123; sql.append(&quot; WHERE id = ? &quot;); params.add(id); &#125; System.out.println(&quot;sql----&gt;&quot;+sql.toString()); rs = DB.executeQuery(conn, sql.toString(), params.toArray()); if(rs != null)&#123; while (rs.next()) &#123; //赋值 Role role = new Role(); role.setId(rs.getInt(&quot;id&quot;)); role.setRoleCode(rs.getString(&quot;roleCode&quot;)); role.setRoleName(rs.getString(&quot;roleName&quot;)); role.setCreatedBy(rs.getInt(&quot;createdBy&quot;)); role.setModifyDate(rs.getDate(&quot;creationDate&quot;)); role.setCreationDate(rs.getDate(&quot;creationDate&quot;)); role.setModifyBy(rs.getInt(&quot;modifyBy&quot;)); roleList.add(role); &#125; &#125; &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;else &#123; return null; &#125; return roleList;&#125; Service层 ==getUserCount== 123456789101112131415public int getUserCount(String userName, int UserRole) &#123; int count = 0; Connection conn = null; try &#123; conn = DB.getConnection(); dao = new UserDaoImpl(); count = dao.getUserCount(conn, userName, UserRole); DB.close(conn,null,null); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return count; &#125; ==getUserlist== 1234567891011121314public List&lt;User&gt; getUserlist(String userName, int userRole,int currPage, int pageSize) &#123; List&lt;User&gt; usersList = new ArrayList&lt;&gt;(); try &#123; Connection conn = DB.getConnection(); dao = new UserDaoImpl(); usersList = dao.getUserList(conn, userName, userRole,currPage, pageSize); DB.close(conn,null,null); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return usersList;&#125; ==getRoleList== 12345678910111213public List&lt;Role&gt; getRoleList(int id) &#123; List&lt;Role&gt; roles = new ArrayList&lt;&gt;(); try &#123; Connection conn = DB.getConnection(); RoleDao dao = new RoleDaoImpl(); roles = dao.getRolelist(conn, id); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return roles;&#125; Servlet层 类加载读取配置文件： 目前需要读取的数据有：PAGE_SIZE 用于设置页面大小 12345678910111213static &#123; //读取配置文件 //1、创建properties对象 Properties properties = new Properties(); //2、通过类加载器加载资源文件为字节输入流 InputStream in = DB.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); try &#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; PAGE_SIZE = Integer.parseInt(properties.getProperty(&quot;PAGE_SIZE&quot;));&#125; 12345678910protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getParameter(&quot;method&quot;); if(&quot;savepwd&quot;.equals(method))&#123; savePwd(req, resp); &#125; else if(&quot;pwdmodify&quot;.equals(method))&#123; pwdModify(req, resp); &#125; else if (&quot;query&quot;.equals(method)) &#123; query(req, resp); &#125;&#125; 这段代码的作用是根据不同的method值调用不同的方法处理GET请求，实现不同的功能操作。 具体实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected void query(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 从前端获取用户输入的参数 queryname -&gt; userName，queryUserRole -&gt; userRole,pageIndex String userName = req.getParameter(&quot;queryname&quot;); String userRole = req.getParameter(&quot;queryUserRole&quot;); String pageIndex = req.getParameter(&quot;pageIndex&quot;); // 检验参数的合法性 if( userName == null)&#123; userName =&quot;&quot;; &#125; if(userRole == null || userRole.equals(&quot;&quot;))&#123; userRole = &quot;0&quot;; &#125; if(pageIndex == null || pageIndex.equals(&quot;&quot;))&#123; pageIndex = &quot;1&quot;; &#125; //3. 准备前端需要的参数： queryUserName，queryUserRole ,roleList，userList, String queryUserName = userName; String queryUserRole = userRole; List&lt;Role&gt; roleList; List&lt;User&gt; userList; // 以及下列参数： totalPageCount（总页数），totalCount（查询到的用户数），currentPageNo（当前页） // 这些参数的获取需要先调用userService.getUserCount查询用户数， 然后调用PageSupport提供分页支持 UserServiceImpl userService = new UserServiceImpl(); RoleServiceImpl roleService = new RoleServiceImpl(); int totalCount = userService.getUserCount(userName, Integer.parseInt(userRole)); PageSupport pageSupport = new PageSupport(); pageSupport.setPageSize(PAGE_SIZE); pageSupport.setTotalCount(totalCount); pageSupport.setTotalPageCountByRs(); pageSupport.setCurrentPageNo(Integer.parseInt(pageIndex)); int totalPageCount = pageSupport.getTotalPageCount(); // 查询用户和角色 userList = userService.getUserlist(userName, Integer.parseInt(userRole), Integer.parseInt(pageIndex), PAGE_SIZE); roleList = roleService.getRoleList(0); //2. 根据参数返回用户表和角色表 req.setAttribute(&quot;roleList&quot;,roleList); req.setAttribute(&quot;userList&quot;,userList); //3. 返回用户需要的参数 req.setAttribute(&quot;queryUserName&quot;,queryUserName); req.setAttribute(&quot;queryUserRole&quot;,queryUserRole); req.setAttribute(&quot;totalPageCount&quot;, totalPageCount); req.setAttribute(&quot;totalCount&quot;,totalCount); req.setAttribute(&quot;currentPageNo&quot;,pageIndex); //4. 转发到jsp/userlist.jsp， 要使用转发而不是重定向， 便于携带参数 req.getRequestDispatcher(&quot;userlist.jsp&quot;).forward(req,resp); &#125; 这段代码实现了一个查询用户的功能，以下是代码实现的步骤： 从前端获取用户输入的参数：userName（用户名），userRole（用户角色），pageIndex（当前页码）。 根据参数返回用户表和角色表，并将其设置为请求的属性，供jsp文件使用。 准备前端需要的参数： queryUserName（查询用户名），queryUserRole（查询用户角色），roleList（角色列表），userList（用户列表）,totalPageCount（总页数），totalCount（查询到的用户数），currentPageNo（当前页）。 查询用户数，并设置pageSupport的totalCount，currentPageNo，pageSize属性。 查询用户和角色，并将其设置为请求的属性，供jsp文件使用。 将前端需要的参数设置为请求的属性，供jsp文件使用。 将请求转发到userlist.jsp文件，便于携带参数。 其中，代码中调用了UserService类和RoleService类的方法实现具体的查询操作。同时，代码中也对获取的参数进行了一些合法性的检验和设置默认值的操作。最终，将查询到的结果设置为请求的属性，通过转发的方式返回到jsp文件中供前端展示。 用户删除实现 在前端页面找到用户删除的按钮(锚), href是: javascript:, 12345&lt;td&gt; &lt;span&gt;&lt;a class=&quot;viewUser&quot; href=&quot;javascript:;&quot; userid=$&#123;user.id &#125; username=$&#123;user.userName &#125;&gt;&lt;img src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/images/read.png&quot; alt=&quot;查看&quot; title=&quot;查看&quot;/&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&lt;a class=&quot;modifyUser&quot; href=&quot;javascript:;&quot; userid=$&#123;user.id &#125; username=$&#123;user.userName &#125;&gt;&lt;img src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/images/xiugai.png&quot; alt=&quot;修改&quot; title=&quot;修改&quot;/&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;&lt;a class=&quot;deleteUser&quot; href=&quot;javascript:;&quot; userid=$&#123;user.id &#125; username=$&#123;user.userName &#125;&gt;&lt;img src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/images/schu.png&quot; alt=&quot;删除&quot; title=&quot;删除&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/td&gt; 找到对应的javascript 12345$(&quot;.deleteUser&quot;).on(&quot;click&quot;,function()&#123; userObj = $(this); changeDLGContent(&quot;你确定要删除用户【&quot;+userObj.attr(&quot;username&quot;)+&quot;】吗？&quot;); openYesOrNoDLG();&#125;); 当删除被点击后, js调用函数userObj, 接着我们去看这个函数 123456789101112131415161718192021function deleteUser(obj)&#123; $.ajax(&#123; type:&quot;GET&quot;, url:path+&quot;/jsp/user.do&quot;, data:&#123;method:&quot;deluser&quot;,uid:obj.attr(&quot;userid&quot;)&#125;, dataType:&quot;json&quot;, success:function(data)&#123; if(data.delResult == &quot;true&quot;)&#123;//删除成功：移除删除行 cancleBtn(); obj.parents(&quot;tr&quot;).remove(); &#125;else if(data.delResult == &quot;false&quot;)&#123;//删除失败 changeDLGContent(&quot;对不起，删除用户【&quot;+obj.attr(&quot;username&quot;)+&quot;】失败&quot;); &#125;else if(data.delResult == &quot;notexist&quot;)&#123; changeDLGContent(&quot;对不起，用户【&quot;+obj.attr(&quot;username&quot;)+&quot;】不存在&quot;); &#125; &#125;, error:function(data)&#123; changeDLGContent(&quot;对不起，删除失败&quot;); &#125; &#125;);&#125; 这段代码是一个 JavaScript 函数，它使用 jQuery 的 $.ajax 方法发送一个 GET 请求到服务器。以下是对代码的分析： function deleteUser(obj)：这是一个命名为 deleteUser 的函数，它接受一个参数 obj，表示要删除的用户对象。 $.ajax：这是 jQuery 提供的一个函数，用于发送 AJAX 请求到服务器。 AJAX 请求的配置选项包括： type: &quot;GET&quot;：指定请求类型为 GET。 url: path + &quot;/jsp/user.do&quot;：指定请求的 URL 地址，其中 path 是一个变量或常量，表示服务器路径。 data: &#123;method: &quot;deluser&quot;, uid: obj.attr(&quot;userid&quot;)&#125;：指定请求发送的数据，包括 method 和 uid 两个参数。method 的值为 &quot;deluser&quot;，uid 的值通过 obj.attr(&quot;userid&quot;) 获取。 dataType: &quot;json&quot;：指定预期的响应数据类型为 JSON。 success：这是一个成功回调函数，在服务器成功响应时被调用。它接受一个参数 data，表示从服务器返回的数据。函数内部根据返回的数据执行不同的操作： 如果 data.delResult 的值为 &quot;true&quot;，表示删除成功。函数调用 cancleBtn() 取消按钮，并移除 obj 对应的父级 &lt;tr&gt; 行。 如果 data.delResult 的值为 &quot;false&quot;，表示删除失败。函数调用 changeDLGContent 修改对话框的内容，显示删除失败的提示信息。 如果 data.delResult 的值为 &quot;notexist&quot;，表示用户不存在。函数调用 changeDLGContent 修改对话框的内容，显示用户不存在的提示信息。 error：这是一个错误回调函数，在请求发生错误时被调用。它接受一个参数 data，表示错误信息。函数调用 changeDLGContent 修改对话框的内容，显示删除失败的提示信息。 这段代码用于通过 AJAX 请求向服务器发送删除用户的请求，并根据服务器返回的结果执行相应的操作。成功时移除对应的行，失败时显示错误提示信息。 通过这些信息,我们可以得知如何编写我们的后台程序 编写对应的Servlet, 根据method值不同, 调用delUser函数 编写请求处理函数delUser delUser调用Service删除用户, 并返回结果 如果删除用户成功, 返回true或者受影响行数为1, 通过响应向前端返回数据delResult = true 如果Service返回false或者受影响行数为0, 向前端返回delResult = no exist, 表示删除的用户不存在. 出现异常则返回delResult = false(在这里是用户权限不够时返回会false) 12345678910111213141516171819202122protected void delUser(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; //1. 获取用户角色， 如果用户不是系统管理员， 则没有删除用户的权限 User o = (User) req.getSession().getAttribute(Constant.USER_SESSION); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); if(o.getUserRole() == 1)&#123; String uid = req.getParameter(&quot;uid&quot;); service = new UserServiceImpl(); boolean res = service.delUser(Integer.parseInt(uid)); if(res)&#123; map.put(&quot;delResult&quot;, &quot;true&quot;); &#125; else &#123; map.put(&quot;delResult&quot;, &quot;notexist&quot;); &#125; &#125; else &#123; map.put(&quot;delResult&quot;,&quot;false&quot;); &#125; //封装json数据， 并写到前端 PrintWriter writer = resp.getWriter(); writer.write(JSONArray.toJSONString(map)); writer.flush();&#125; 接下来, 我们还需要编写对应的Service层以及Dao层代码, 由于service实际上并没有做什么事, 这里只展示Dao层代码 12345678910111213public int delUser(Connection conn, int id) &#123; int affectedRow = 0; if(conn != null)&#123; try &#123; String sql = &quot;Delete from smbms_user where id = ?&quot;; Object[] params = &#123;id&#125;; affectedRow = DB.executeUpdate(conn, sql, params); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; return affectedRow;&#125; 这段代码及其简单, 只需要写一段sql, 然后交给DB去执行就好了, DB这个类会预处理sql, 以及给占位符赋值, 最后执行sql返回结果. 查看用户实现 和删除用户类似, 找到对应的js请求 12345$(&quot;.viewUser&quot;).on(&quot;click&quot;,function()&#123; //将被绑定的元素（a）转换成jquery对象，可以使用jquery方法 var obj = $(this); window.location.href=path+&quot;/jsp/user.do?method=view&amp;uid=&quot;+ obj.attr(&quot;userid&quot;);&#125;); 编写Servlet 1234567protected void view(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; String uid = req.getParameter(&quot;uid&quot;); service = new UserServiceImpl(); User user = service.findById(Integer.parseInt(uid)); req.setAttribute(&quot;user&quot;, user); req.getRequestDispatcher(req.getContextPath()+&quot;/jsp/userview.jsp&quot;).forward(req, resp);&#125; 编写dao层, service层实现 1234567891011121314151617181920212223242526272829303132333435363738394041public User findById(int id) &#123; //2. 初始化参数 Object[] params = &#123;id&#125;; ResultSet set; sql = &quot;SELECT * FROM smbms_user,smbms_role Where smbms_user.userRole = smbms_role.id and smbms_user.id = ?&quot;; try &#123; conn = DB.getConnection(); set = DB.executeQuery(conn, sql,params); if(set != null)&#123; user = new User(); while (set.next()) &#123; user.setUserRoleName(set.getString(&quot;roleName&quot;)); user.setUserPassword(set.getString(&quot;userPassword&quot;)); user.setId(set.getInt(&quot;id&quot;)); user.setUserCode(set.getString(&quot;userCode&quot;)); user.setUserName(set.getString(&quot;userName&quot;)); user.setAddress(set.getString(&quot;address&quot;)); user.setBirthday((Date) set.getObject(&quot;birthday&quot;)); user.setGender(set.getInt(&quot;gender&quot;)); user.setPhone(set.getString(&quot;phone&quot;)); user.setIdPicPath(set.getString(&quot;idPicPath&quot;)); user.setUserRole(set.getInt(&quot;userRole&quot;)); user.setCreatedBy(set.getInt(&quot;createdBy&quot;)); user.setCreationDate( set.getDate(&quot;creationDate&quot;)); user.setModifyBy(set.getInt(&quot;modifyBy&quot;)); user.setModifyDate(set.getDate(&quot;modifyDate&quot;)); user.setWorkPicPath(&quot;workPicPath&quot;); System.out.println(user.toString()); &#125; &#125; else &#123; return null; &#125; //关闭链接和结果集 DB.close(conn,null,set); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return user;&#125; 修改用户实现 重复重复再重复… 1234$(&quot;.modifyUser&quot;).on(&quot;click&quot;,function()&#123; var obj = $(this); window.location.href=path+&quot;/jsp/user.do?method=modify&amp;uid=&quot;+ obj.attr(&quot;userid&quot;);&#125;); 12345678protected void modify(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException&#123; String uid = req.getParameter(&quot;uid&quot;); service = new UserServiceImpl(); User user = service.findById(Integer.parseInt(uid)); req.setAttribute(&quot;user&quot;, user); req.getRequestDispatcher(req.getContextPath()+&quot;/jsp/usermodify.jsp&quot;).forward(req, resp);&#125; 和之前不同的是, 这次修改用户指向一个新的jsp页面, 也就是修改用户的页面. 也就是说, 删除用户的请求提交以后, 我们需要把这个请求转发到/jsp/usermodify.jsp这个URL对应的jsp页面去, 由于这个jsp页面需要修改前的user数据, 我们需要查询对应的id,得到user数据后把数据传递给usermodify.jsp这个jsp页面, jsp页面需要这些数据来向用户展示修改前的数据. 下面我们去看这个jsp页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@include file=&quot;/jsp/common/head.jsp&quot;%&gt;&lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;location&quot;&gt; &lt;strong&gt;你现在所在的位置是:&lt;/strong&gt; &lt;span&gt;用户管理页面 &gt;&gt; 用户修改页面&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;providerAdd&quot;&gt; &lt;form id=&quot;userForm&quot; name=&quot;userForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;modifyexe&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id &#125;&quot;/&gt; &lt;div&gt; &lt;label for=&quot;userName&quot;&gt;用户名称：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot; value=&quot;$&#123;user.userName &#125;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label &gt;用户性别：&lt;/label&gt; &lt;select name=&quot;gender&quot; id=&quot;gender&quot;&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;user.gender == 1 &#125;&quot;&gt; &lt;option value=&quot;1&quot; selected=&quot;selected&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;女&lt;/option&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;option value=&quot;1&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;女&lt;/option&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;label &gt;出生日期：&lt;/label&gt; &lt;input type=&quot;text&quot; Class=&quot;Wdate&quot; id=&quot;birthday&quot; name=&quot;birthday&quot; value=&quot;$&#123;user.birthday &#125;&quot; readonly=&quot;readonly&quot; onclick=&quot;WdatePicker();&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label &gt;用户电话：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; id=&quot;phone&quot; value=&quot;$&#123;user.phone &#125;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label &gt;用户地址：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;address&quot; id=&quot;address&quot; value=&quot;$&#123;user.address &#125;&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;label &gt;用户角色：&lt;/label&gt; &lt;!-- 列出所有的角色分类 --&gt; &lt;input type=&quot;hidden&quot; value=&quot;$&#123;user.userRole&#125;&quot; id=&quot;rid&quot; /&gt; &lt;select name=&quot;userRole&quot; id=&quot;userRole&quot;&gt;&lt;/select&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div class=&quot;providerAddBtn&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;save&quot; id=&quot;save&quot; value=&quot;保存&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;back&quot; name=&quot;back&quot; value=&quot;返回&quot;/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&lt;%@include file=&quot;/jsp/common/foot.jsp&quot; %&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/js/usermodify.js&quot;&gt;&lt;/script&gt; 先观察表单提交的目的地, &#123;pageContext.request.contextPath &#125;/jsp/user.do, 对应一个Servlet, 但是这里并没有提交的按钮, 但是我发现这里有一个usermodify.js的脚本文件, 定位到这个脚本文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120var userName = null;var birthday = null;var phone = null;var userRole = null;var saveBtn = null;var backBtn = null;$(function()&#123; userName = $(&quot;#userName&quot;); birthday = $(&quot;#birthday&quot;); phone = $(&quot;#phone&quot;); userRole = $(&quot;#userRole&quot;); saveBtn = $(&quot;#save&quot;); backBtn = $(&quot;#back&quot;); userName.next().html(&quot;*&quot;); birthday.next().html(&quot;*&quot;); phone.next().html(&quot;*&quot;); userRole.next().html(&quot;*&quot;); $.ajax(&#123; type:&quot;GET&quot;,//请求类型 url:path+&quot;/jsp/user.do&quot;,//请求的url data:&#123;method:&quot;getrolelist&quot;&#125;,//请求参数 dataType:&quot;json&quot;,//ajax接口（请求url）返回的数据类型 success:function(data)&#123;//data：返回数据（json对象） if(data != null)&#123; var rid = $(&quot;#rid&quot;).val(); userRole.html(&quot;&quot;); var options = &quot;&lt;option value=\\&quot;0\\&quot;&gt;请选择&lt;/option&gt;&quot;; for(var i = 0; i &lt; data.length; i++)&#123; if(rid != null &amp;&amp; rid != undefined &amp;&amp; data[i].id == rid )&#123; options += &quot;&lt;option selected=\\&quot;selected\\&quot; value=\\&quot;&quot;+data[i].id+&quot;\\&quot; &gt;&quot;+data[i].roleName+&quot;&lt;/option&gt;&quot;; &#125;else&#123; options += &quot;&lt;option value=\\&quot;&quot;+data[i].id+&quot;\\&quot; &gt;&quot;+data[i].roleName+&quot;&lt;/option&gt;&quot;; &#125; &#125; userRole.html(options); &#125; &#125;, error:function(data)&#123;//当访问时候，404，500 等非200的错误状态码 validateTip(userRole.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo+&quot; 获取用户角色列表error&quot;,false); &#125; &#125;); userName.on(&quot;focus&quot;,function()&#123; validateTip(userName.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 用户名长度必须是大于1小于10的字符&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(userName.val() != null &amp;&amp; userName.val().length &gt; 1 &amp;&amp; userName.val().length &lt; 10)&#123; validateTip(userName.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(userName.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo+&quot; 用户名输入的不符合规范，请重新输入&quot;,false); &#125; &#125;); birthday.on(&quot;focus&quot;,function()&#123; validateTip(birthday.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 点击输入框，选择日期&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(birthday.val() != null &amp;&amp; birthday.val() != &quot;&quot;)&#123; validateTip(birthday.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(birthday.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 选择的日期不正确,请重新输入&quot;,false); &#125; &#125;); phone.on(&quot;focus&quot;,function()&#123; validateTip(phone.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入手机号&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; var patrn=/^(13[0-9]|15[0-9]|18[0-9])\\d&#123;8&#125;$/; if(phone.val().match(patrn))&#123; validateTip(phone.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(phone.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 您输入的手机号格式不正确&quot;,false); &#125; &#125;); userRole.on(&quot;focus&quot;,function()&#123; validateTip(userRole.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请选择用户角色&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(userRole.val() != null &amp;&amp; userRole.val() &gt; 0)&#123; validateTip(userRole.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(userRole.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo+&quot; 请重新选择用户角色&quot;,false); &#125; &#125;); saveBtn.on(&quot;click&quot;,function()&#123; userName.blur(); phone.blur(); birthday.blur(); userRole.blur(); if(userName.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; phone.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; birthday.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; userRole.attr(&quot;validateStatus&quot;) == &quot;true&quot;)&#123; if(confirm(&quot;是否确认要提交数据？&quot;))&#123; $(&quot;#userForm&quot;).submit(); &#125; &#125; &#125;); backBtn.on(&quot;click&quot;,function()&#123; //alert(&quot;modify: &quot;+referer); if(referer != undefined &amp;&amp; null != referer &amp;&amp; &quot;&quot; != referer &amp;&amp; &quot;null&quot; != referer &amp;&amp; referer.length &gt; 4)&#123; window.location.href = referer; &#125;else&#123; history.back(-1); &#125; &#125;);&#125;); 直接丢给chatGPT分析: 代码的核心部分是以下部分： 123456789101112131415161718192021222324$.ajax(&#123; type: &quot;GET&quot;, url: path + &quot;/jsp/user.do&quot;, data: &#123; method: &quot;getrolelist&quot; &#125;, dataType: &quot;json&quot;, success: function(data) &#123; if (data != null) &#123; var rid = $(&quot;#rid&quot;).val(); userRole.html(&quot;&quot;); var options = &quot;&lt;option value=\\&quot;0\\&quot;&gt;请选择&lt;/option&gt;&quot;; for (var i = 0; i &lt; data.length; i++) &#123; if (rid != null &amp;&amp; rid != undefined &amp;&amp; data[i].id == rid) &#123; options += &quot;&lt;option selected=\\&quot;selected\\&quot; value=\\&quot;&quot; + data[i].id + &quot;\\&quot; &gt;&quot; + data[i].roleName + &quot;&lt;/option&gt;&quot;; &#125; else &#123; options += &quot;&lt;option value=\\&quot;&quot; + data[i].id + &quot;\\&quot; &gt;&quot; + data[i].roleName + &quot;&lt;/option&gt;&quot;; &#125; &#125; userRole.html(options); &#125; &#125;, error: function(data) &#123; validateTip(userRole.next(), &#123; &quot;color&quot;: &quot;red&quot; &#125;, imgNo + &quot; 获取用户角色列表error&quot;, false); &#125;&#125;); 这部分代码使用了 $.ajax 函数发起一个 GET 请求，请求的目标 URL 是 path + &quot;/jsp/user.do&quot;。请求的数据参数中包含了一个名为 method 的参数，其值为 &quot;getrolelist&quot;。预期的响应数据类型为 JSON。 在成功回调函数中，首先判断返回的数据 data 是否为非空。如果不为空，则继续执行后续逻辑。 通过获取 $(&quot;#rid&quot;).val() 获取一个表示角色的 ID 值。 接下来，清空 userRole 元素的内容，然后使用循环遍历返回的数据数组 data。对于每个数据项，根据其 ID 值和当前选中的角色 ID (rid) 进行比较。如果两者相等，说明该选项应该被选中，否则为普通选项。在循环过程中，动态生成了一段 HTML 字符串 options，包含了所有的选项。 最后，将生成的选项字符串设置为 userRole 元素的 HTML 内容，从而在页面上显示这些选项。 在错误回调函数中，对获取用户角色列表出错的情况进行处理，调用 validateTip 函数显示相应的错误提示信息。 该部分代码的核心功能是通过 AJAX 请求获取用户角色列表，并根据返回的数据动态生成下拉选项，用于用户在表单中选择角色。 所以, 我们需要一个servlet来处理这段ajax请求, 这个请求需要一个角色表 ,整理前端提供的数据, 以及前端需要的数据 提供的数据: name=&quot;method&quot; value=&quot;modifyexe&quot; name=&quot;uid&quot; value=&quot;$&#123;user.id &#125; name=&quot;userName&quot; value=&quot;$&#123;user.userName &#125; name=&quot;gender&quot; name=&quot;birthday&quot; value=&quot;$&#123;user.birthday &#125; name=&quot;phone&quot; value=&quot;$&#123;user.phone &#125; name=&quot;address&quot; value=&quot;$&#123;user.address &#125; name=&quot;userRole&quot; 需要的数据 name=&quot;birthday&quot; value=&quot;$&#123;user.birthday &#125; name=&quot;phone&quot; value=&quot;$&#123;user.phone &#125; name=&quot;address&quot; value=&quot;$&#123;user.address &#125; name=&quot;uid&quot; value=&quot;$&#123;user.id &#125; name=&quot;userName&quot; value=&quot;$&#123;user.userName &#125; 角色表 下面我们来编写servlet 通过method的值对请求做不同处理, 这里有三个个请求, 分别是 method=modify method = getrolelist metho=modidyexe method=modify 这个请求当用户点击修改按钮时被触发, 目的是导航到用户修改页面, 以及返回修改用户的信息 method = getrolelist 这个请求当用户跳转到用户修改页面触发, 目的是通过 AJAX 请求获取用户角色列表，并根据返回的数据动态生成下拉选项，用于用户在表单中选择角色。 metho=modidyexe, 这个请求当用户提交修改信息的时候触发, 修改数据库内容 一个复用的Servlet, 用来响应对用户表进行操作的请求. (实际上组合查询了角色表) 1234567891011121314151617181920212223242526protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getParameter(&quot;method&quot;); if(&quot;savepwd&quot;.equals(method))&#123; savePwd(req, resp); &#125; else if(&quot;pwdmodify&quot;.equals(method))&#123; pwdModify(req, resp); &#125; else if (&quot;query&quot;.equals(method)) &#123; query(req, resp); &#125; else if (&quot;add&quot;.equals(method)) &#123; addUser(req, resp); &#125; else if (&quot;getrolelist&quot;.equals(method)) &#123; getRoleList(req, resp); &#125; else if (&quot;ucexist&quot;.equals(method)) &#123; //ajax后台验证--userCode是否已存在 // //user.do?method=ucexist&amp;userCode=** isUserCodeExit(req, resp); &#125; else if (&quot;view&quot;.equals(method)) &#123; view(req, resp); &#125; else if (&quot;deluser&quot;.equals(method)) &#123; delUser(req, resp); &#125; else if (&quot;modifyexe&quot;.equals(method)) &#123; modifyExe(req, resp); &#125; else if (&quot;modify&quot;.equals(method)) &#123; modify(req, resp); &#125;&#125; ​ ==getRoleList(req, resp)== 12345678910protected void getRoleList(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; RoleServiceImpl roleService = new RoleServiceImpl(); List&lt;Role&gt; roleList = roleService.getRoleList(0); resp.setContentType(&quot;application/json&quot;); resp.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter writer = resp.getWriter(); writer.write(JSONArray.toJSONString(roleList)); writer.flush(); writer.close();&#125; ​ ==modify(req, resp);== 12345678protected void modify(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException&#123; String uid = req.getParameter(&quot;uid&quot;); service = new UserServiceImpl(); User user = service.findById(Integer.parseInt(uid)); req.setAttribute(&quot;user&quot;, user); req.getRequestDispatcher(req.getContextPath()+&quot;/jsp/usermodify.jsp&quot;).forward(req, resp);&#125; ​ ==modifyExe(req, resp);== 12345678910111213141516171819202122232425262728293031protected void modifyExe(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException &#123; // 1. 从前端获取参数: userCode userName password gender birthday phone address userRole Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); String uid = req.getParameter(&quot;uid&quot;); map.put(&quot;id&quot;,uid); map.put(&quot;userName&quot;,req.getParameter(&quot;userName&quot;)); map.put(&quot;gender&quot;,Integer.parseInt(req.getParameter(&quot;gender&quot;))); map.put(&quot;phone&quot;,req.getParameter(&quot;phone&quot;)); map.put(&quot;address&quot;,req.getParameter(&quot;address&quot;)); map.put(&quot;userRole&quot;,Integer.parseInt(req.getParameter(&quot;userRole&quot;))); String birthday = req.getParameter(&quot;birthday&quot;); Date date = null; try &#123; date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(birthday); map.put(&quot;birthday&quot;,date); &#125; catch (ParseException e) &#123; throw new RuntimeException(e); &#125; // 2. 封装数据 User o = (User) req.getSession().getAttribute(Constant.USER_SESSION); map.put(&quot;modifyBy&quot;,o.getId()); Date modifyDate = new Date(); map.put(&quot;modifyDate&quot;,new Date()); //3. 调用service service = new UserServiceImpl(); for (String key : map.keySet()) &#123; boolean res = service.updateUser(Integer.parseInt(uid), key, map.get(key)); &#125; resp.sendRedirect(req.getContextPath()+&quot;/jsp/user.do?method=query&quot;);&#125; 剩下的编写Service以及Dao层实现对数据库的操作, 整个功能就实现了. 这里不在叙述. 尾巴 ​ 到这里, 这个项目的搭建算是告一段落了. 在这个项目中, 我基本上是从零开始搭建. 说来惭愧, 现在大三下下学期已经过半, 学校的JavaEE也结课两周. 我对整个课程却没什么印象, 这当然也和我根本没去上几次课有关系, 除了实验课我基本就不去了. 这也不是我不想学, 只是觉得要是跟着老师学我会更糟. 老师上课完全不顾学生, 只将电脑的idea投屏到投影仪上便能自顾自的讲一节课. 投影仪本来亮度就不高, idea字体又小,完全不知道怎么听. 听过几次我就是在不想去了. ​ 加之又有考研的计划, 基本都呆在图书馆学习高数和计算机网络了, JavaEE基本上没怎么碰了, 连分组的实践也是完全丢下给小组其他同学了(小组实践能不能从大学消失啊). 小组其他几个也都是混子, 这留下我的旁边床铺的室友了, 这让我感觉实在很惭愧. 当然最后的结果也是压根没人管这个小组实践了, 直到deadline的前一天晚上, 这事才被重新提起. 当然也只能从github匆匆找一个应付交作业了. ​ 那么如果总结这半学期学到了什么的话, 只剩下把计算机网络算是完完整整的学完了, 不过这也是补了之前欠下的债了. 高数我已经接近一个月没有看过了, 现在也已经没什么印象了, 不知道考研要怎么办了. 我也已经做好了二战的准备了. ​ 写这个项目的契机, 也是学校又莫名其妙多了个课程设计, 相比学校的什么破实验实践, 我很喜欢学校的课程设计, 上次操作系统的实践设计是关于xv6的, 那次让我对操作系统的理解提升了很多, 现在我都不舍得删掉电脑里的qemu模拟器. 不过这和老师没什么关系, 老师基本上只是把课题扔在那, 我们自己独立完成. 但也同时我有了更多的时间去完成这个课程设计, 没有其他课程任务的干扰, 我可以全心全意的投入到这个课程设计中去. 这很符合我自己的学习习惯, 我更喜欢把一个课程学完了, 或者是一个阶段的任务完成了, 才去开始下一项学习计划. 相比于去课堂上听无意义的课程, 这种把时间留给学生自己的做法, 在这个大学老师基本上起不到什么帮助的破大学里, 显然是更值得的. ​ 说回写这个项目的契机, 也是学校的课程设计. 到这个时候所以的课程也已经结束了, 我本以为可以完完全全的开始自己的学习计划的时候, 来这么一个任务一开始我是蛮不开心的. 这次的任务是写一个图书管理系统, 狂神这个课程写了一个超市管理系统, 但是这些什么学生管理系统啊, 图书管理系统之类的, 都没区别, 随便改一改就可以. ​ 这次的课程设计分为了几个小组, 和其他小组不同的是, 我们小组的老师要求每个同学独立完成, 这让我很喜这个老师的做法. 而我们每天上课的内容也就是在自习室写自己的项目罢了, 除了早上八点要爬上11楼外, 我没什么抱怨的. ​ 接下来的学习计划, 我准备把CSAPP的内容补上, 这个从大一开始便一直计划要学的内容, 到现在也没开始, 我真是废物啊. 如果可以穿越回大一到话, 当然是带着现在的记忆穿越回去, 不然结局也是淹没在大学的无意义的课程中了. 不过带着记忆的话, 与其幻想这个不切实际的梦, 这个幻想其本质和我接下把自己缺失的补上是一样的. ​ 即使我对自己的能力不满意, 但我也确实没什么可以抱怨的, 毕竟这就是我, 这才是我. 除了暑假的时间顾着玩了, 大学的生活我的学习步伐一直都是踏踏实实的. 我不得不说我已经够努力了, 靠着我一个人, 在一个远离家乡的城市. 这个指望不上老师的地方, 我做到现在我已经和满意了, 从大一到现在的我, 以及学会了太多太多, 完完全全成长了很多, 学到很多. 剩下的遗憾, 留下没有一个好的环境, 一个良师益友引导我. 不知道这个遗憾能不能在研究生生活中补上呢, 至少现在先考上一个好多大学, 补完这些遗憾吧. 加油啊, 自己. 以下是改为图书管理系统的字段替换: 1234567891011121314供应商表-&gt; 图书ISBN：-&gt;provider.proCode书名：-&gt;provider.proName作者：-&gt;provider.proContact定价：-&gt;provider.proPhone 出版社-&gt;provider.proFax 分类：-&gt;provider.proDesc订单管理-&gt;借阅记录管理未归还 -&gt; queryIsPayment == 1 已归还-&gt; queryIsPayment == 2 用户：-&gt;queryProductName借阅记录编码-&gt;billCode图书 -&gt;providerName金额-&gt;totalPrice","categories":[{"name":"Java web","slug":"Java-web","permalink":"https://trevoewu.github.io/categories/Java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://trevoewu.github.io/tags/java-web/"},{"name":"jsp","slug":"jsp","permalink":"https://trevoewu.github.io/tags/jsp/"},{"name":"servlet","slug":"servlet","permalink":"https://trevoewu.github.io/tags/servlet/"},{"name":"jdbc","slug":"jdbc","permalink":"https://trevoewu.github.io/tags/jdbc/"},{"name":"fullstack","slug":"fullstack","permalink":"https://trevoewu.github.io/tags/fullstack/"},{"name":"smbms","slug":"smbms","permalink":"https://trevoewu.github.io/tags/smbms/"}]},{"title":"Java Web 快速入门","slug":"Java-Web-快速入门","date":"2023-05-12T09:45:29.000Z","updated":"2023-05-15T13:19:42.582Z","comments":true,"path":"2023/05/12/Java-Web-快速入门/","link":"","permalink":"https://trevoewu.github.io/2023/05/12/Java-Web-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"静态web和动态web 静态Web和动态Web都是Web应用程序的不同类型，它们的主要区别在于页面内容是如何生成和呈现的。 静态Web是由静态网页组成的Web应用程序，网页的内容在页面请求时已经存在，并且不会随着用户的请求而发生变化。网页内容通常是由HTML、CSS、JavaScript等静态文件组成的，这些文件都是在服务器端预先生成的，当用户访问这些网页时，服务器只需将这些文件发送给用户的浏览器，浏览器将文件解析并显示给用户即可。静态Web通常包含少量的网页，内容不会发生频繁变化，适合于展示企业宣传网站、个人博客等简单的网站。 动态Web是由动态网页组成的Web应用程序，网页内容是在用户请求时根据请求参数和服务器端的处理生成的。网页内容可以根据用户的不同请求参数、数据库查询结果等实时生成。动态Web需要使用服务器端脚本语言（如Java、PHP、Python Servlet/JSP等）来生成HTML页面内容，通常使用数据库来存储和管理数据。动态Web可以实现更复杂的功能，例如在线商城、社交网络、新闻门户等。 总的来说，静态Web适合于内容不会频繁变化，网站规模较小的场景，可以使用简单的HTML、CSS、JavaScript等前端技术来实现；而动态Web适合于内容需要频繁变化、网站规模较大的场景，需要使用服务器端脚本语言和数据库来实现。 web服务器 Tomcat Web服务器是一种软件程序，主要用于处理客户端和服务器之间的HTTP请求和响应。它可以接收来自客户端（通常是Web浏览器）的HTTP请求，并返回处理后的HTTP响应。Web服务器通常运行在互联网上，提供各种各样的服务，例如Web网站、电子邮件服务、文件传输等。 Tomcat是一种流行的开源Web服务器，它实现了Java Servlet和JavaServer Pages (JSP) 规范。Tomcat支持多种操作系统，包括Windows、Linux和Mac OS等，它提供了一个简单的、易于使用的管理界面，允许管理员对服务器进行配置和管理。 Tomcat的主要特点包括： 支持Java Servlet和JSP规范：Tomcat可以运行和处理Java Web应用程序，例如Java Servlet、JSP和JavaServer Faces (JSF) 等。 可扩展性：Tomcat支持各种插件和扩展，可以根据需要添加新功能或修改现有功能。 易于配置和管理：Tomcat提供了一个简单的管理界面，允许管理员轻松地配置和管理Web服务器，包括添加或删除Web应用程序、配置访问权限等。 开源免费：Tomcat是一个开源项目，可以免费使用和修改。这意味着用户可以根据自己的需要进行定制和修改，而不需要支付高昂的授权费用。 总的来说，Tomcat是一种功能强大的Web服务器，非常适合运行Java Web应用程序。它具有可扩展性、易于配置和管理、开源免费等优点，因此在企业和个人用户中非常受欢迎。 Tomcat文件结构 1cd ~/tomcat //tomcart 安装目录 访问测试：http://localhost:8080 默认端口8080 配置文件 可以修改配置的启动端口号, 默认为8080 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 可以配置主机的名称, 默认网站的存放位置 name=“locahost” 默认主机名对于的ip地址 127.0.0.1 默认网站存放地址: webapps 12&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; 发布一个网站 将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了。 HTTP HTPP 请求 123456789Request URL:https://www.baidu.com/ 请求地址Request Method:GET get方法/post方法Status Code:200 OK 状态码：200Remote（远程） Address:14.215.177.39:443Accept:text/html 客户端可以接受的语言Accept-Encoding:gzip, deflate, br 编码Accept-Language:zh-CN,zh;q=0.9 语言Cache-Control:max-age=0 是否设置缓存Connection:keep-alive 是否为持续性链接 Servlet 简介 Servlet就是sun公司开发动态web的一门技术。 Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤： 编写一个类，实现Servlet接口。 把开发好的Java类部署到web服务器中。 把实现了Servlet接口的Java程序叫做，Servlet。 第一个Servlet程序 HelloServlet 修改web.xml为最新的 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot; metadata-complete=&quot;true&quot;&gt;&lt;/web-app&gt; 编写一个Servlet程序。 编写一个普通类Bean 实现servlet接口, 这里我们直接继承HttpServlet 1234567891011public class HelloServlet extends HttpServlet &#123; // 由于get或post只是请求实现的不同的方式，可以相互调用，业务逻辑都是一样； //HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，//HTTP请求中的所有信息会被封装到HttpServletRequest，//通过这个HttpServletRequest的方法，获得客户端的所有信息； @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); // 响应流 writer.print(&quot;Hello,Serlvet&quot;); writer.flush() &#125; write( )和println( ) servletResponse.getWriter().write()``servletResponse.getWriter().println()都是用于将字符串写入到HTTP响应中的方法，但是它们之间有一些关键的区别。 servletResponse.getWriter().write()方法是将指定的字符串写入到HTTP响应输出流中，它不会在字符串末尾添加任何换行符或其他字符。如果需要在输出的字符串后面添加换行符或其他字符，就需要在字符串后面显式添加这些字符。 servletResponse.getWriter().println()方法也是将指定的字符串写入到HTTP响应输出流中，但是它会在字符串末尾自动添加一个换行符。这个换行符的样式和操作系统相关，通常是\\n或\\r\\n。使用println()方法可以让每个输出的字符串都独占一行，使得输出更易于阅读和处理。 因此，write()方法适合于需要将多个字符串写入到同一行的情况，例如输出CSV格式的数据或者HTML代码的片段。而println()方法适合于需要输出多行字符串的情况，例如输出日志信息或HTML代码的整个页面。 需要注意的是，无论使用哪种方法，都需要在使用完之后调用servletResponse.getWriter().flush()方法将输出流刷新并将数据发送到客户端。如果不调用flush()方法，可能会导致响应数据无法正常发送到客户端。 编写Servlet的映射 为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径； 12345678910&lt;!--注册Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.loulan.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--Servlet的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet Mapping 一个Servlet可以指定一个映射路径。 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一个Servlet可以指定多个映射路径。 1234567891011121314151617181920&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一个Servlet可以指定通用映射路径。 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 默认请求路径。 12345&lt;!--默认请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 指定一些后缀或者前缀等等…. 12345678&lt;!-- 可以自定义后缀实现请求映射 注意点，*前面不能加项目映射的路径 hello/subei.github --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.github&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 优先级问题。 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； Servlet Context web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用(Application)； ServletContext是Java Web应用程序的一个接口，它提供了一个Web应用程序的运行环境，可以访问应用程序的配置信息、资源、请求和会话等。每个Web应用程序都有一个ServletContext实例，可以通过getServletContext()方法获取。 ServletContext提供了以下功能： 应用程序作用域：ServletContext对象是一个应用程序级别的对象，可以在整个应用程序范围内共享数据。 应用程序配置信息：ServletContext对象提供了访问Web应用程序的配置信息的方法，例如Web.xml中配置的上下文参数，初始化参数等。 资源访问：ServletContext对象提供了一些方法，例如getRealPath()和getResourceAsStream()，可以访问Web应用程序中的资源文件。 请求转发：ServletContext对象提供了getRequestDispatcher()方法，可以将请求转发到其他Web组件，例如Servlet或JSP。 会话管理：ServletContext对象提供了创建和管理会话的方法，例如getSession()和getSessionCookieConfig()。 ServletContex为Java Web应用程序提供了一个环境，使开发人员可以访问应用程序的配置信息、资源、请求和会话等，并且可以将请求转发到其他Web组件。这使得Java Web应用程序开发变得更加容易和灵活。 利用servletContext实现不同Servlet之前的数据共享 在这个Servlet中保存的数据，可以在另外一个servlet中拿到； 1234567891011121314151617public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String name = &quot;学习超好&quot;; // 数据 context.setAttribute(&quot;name&quot;,name); &#125;&#125;public class GetServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String name = (String)context.getAttribute(&quot;name&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.getWriter().print(&quot;名字:&quot;+name); &#125; 利用Servlet获取初始化参数 1234567891011121314&lt;!-- 配置一些Web应用初始化参数 --&gt; &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;gp&lt;/servlet-name&gt; &lt;servlet-class&gt;com.github.servlet.ServletDemo03&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;gp&lt;/servlet-name&gt; &lt;url-pattern&gt;/gp&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 1234567public class ServletDemo03 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String url = context.getInitParameter(&quot;url&quot;); resp.getWriter().print(url); &#125; 实现请求的转发 利用ServletContext实现请求的转发 12345678public class ServletDemo04 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext();// 调用forward实现请求转发;// requestDispatcher.forward(req,resp); context.getRequestDispatcher(&quot;url&quot;).forward(req,resp); &#125; 用来读取资源文件 在resources目录下新建properties 思路：需要一个文件流； 1username=&quot;楼兰&quot; 1234567891011public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; InputStream stream = this.getServletContext().getResourceAsStream(&quot;WEB-INF/classes/db.properties&quot;); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(&quot;username&quot;);// 但是如果配置文件中如果包含中文，就会出现乱码，所以可以通过中转的形式优化一下： prop.load(new InputStreamReader(stream,&quot;UTF-8&quot;)); resp.getWriter().print(user); &#125; HttpServletResponse web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest； 如果要给客户端响应一些信息：找HttpServletResponse。 1.简单分类 负责向浏览器发送数据的方法。 12ServletOutputStream getOutputStream();PrintWriter getWriter(); 负责向浏览器发送响应头的方法。 12void setCharacterEncoding(String var1);void setContentType(String var1); 响应的状态码。 1234int SC_OK = 200;int SC_MOVED_PERMANENTLY = 301;int SC_NOT_FOUND = 404;int SC_INTERNAL_SERVER_ERROR = 500; 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 2.下载文件 向浏览器输出消息； 下载文件： 要获取下载文件的路径； 下载的文件名是啥？ 设置想办法让浏览器能够支持下载我们需要的东西； 获取下载文件的输入流； 创建缓冲区； 获取OutputStream对象； 将FileOutputStream流写入到buffer缓冲区； 使用OutputStream将缓冲区中的数据输出到客户端！ 12345678910111213141516171819202122232425262728293031323334353637public class FIleServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// 1. 获取下载文件的路径； String url = &quot;/Users/trevorwu/Maven_03/HelloServlet/src/main/resources/Peekaboo.png&quot;;// 2. 获取文件名 String fileName = &quot;downFile.png&quot;;// 3. 让浏览器能够支持下载我们需要的东西；// 这段代码是用来设置 HTTP 响应头，将服务器返回的内容作为文件附件（attachment）下载，而非直接在浏览器中打开。// 具体地，`resp.setHeader()` 方法设置了一个名为 &quot;Content-Disposition&quot; 的响应头，// 其值为 &quot;attachment;filename=xxxxx&quot;，其中 &quot;xxxxx&quot; 是要下载的文件名。// 这个文件名可以是服务器上的文件名，也可以是通过代码生成的文件名。// 这个文件名决定了用户下载得到的文件名， 而非服务器上的文件名， 服务器的文件名在下载文件的地址中指定 resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + URLEncoder.encode(fileName,&quot;UTF-8&quot;));// 4. 获取下载文件的输入流； FileInputStream in = new FileInputStream(url);// 5. 创建缓冲区； int len = 0; byte buffer[] = new byte[1024];// 6. 获取OutputStream对象； ServletOutputStream out = resp.getOutputStream();// 7. 将FileOutputStream流写入到buffer缓冲区；// 这段代码是将输入流 `in` 中的数据读取到缓冲区 `buffer` 中，再通过输出流 `out` 输出到目标位置。// 具体地，循环读取操作会在输入流中读取数据，并将数据写入到缓冲区中，// 当读取到的数据长度为0时，说明已经读取完毕，退出循环。//在每次循环中，通过调用 `out.write(buffer, 0, len)` 方法，将缓冲区中的数据写入输出流中。// 这里的 `buffer` 是一个字节数组，`len` 是每次读取的字节数。// 第二个参数 `0` 表示从缓冲区的第一个字节开始写入，而不是从数组的第一个元素开始写入。//通过这段代码，我们可以实现从输入流中读取数据，然后将数据输出到目标位置的操作，通常用于文件下载或数据传输等场景。 while ((len=in.read(buffer)) &gt; 0)&#123; out.write(buffer,0,len); &#125;// close input output stream in.close(); out.close(); &#125; 3.验证码功能* 验证怎么来的？ 前端实现； 后端实现，需要用到 Java 的图片类，生产一个图片。 12345678910111213141516171819202122232425262728293031323334353637383940public class ImageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;// 如何让浏览器3秒自动刷新一次; resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);// 在内存中创建一个图片 BufferedImage image = new BufferedImage(90,40,BufferedImage.TYPE_INT_RGB);// 得到图片,笔 Graphics2D g = (Graphics2D) image.getGraphics();// 设置图片的背景颜色 g.setColor(Color.white); g.fillRect(0,0,90,40);// 给图片写数据 g.setColor(Color.RED); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),8,30);// 告诉浏览器，这个请求用图片的方式打开 resp.setContentType(&quot;image/jpeg&quot;);// 网站存在缓存，不让浏览器缓存 resp.setDateHeader(&quot;expires&quot;,-1); resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);// 把图片写给浏览器 ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream()); &#125;// 生成随机数 private String makeNum()&#123; Random random = new Random(); String num = random.nextInt(9999999) + &quot;&quot;; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; 7-num.length() ; i++) &#123; sb.append(&quot;0&quot;); &#125; num = sb.toString() + num; return num; &#125; 4.实现重定向 之前我们学过利用Servlet实现请求的转发, 这里我们利用response来实现请求重定向 重定向和转发的区别 重定向和转发是在Java Servlet编程中常用的两种将请求从一个Servlet转发到另一个Servlet或JSP的方式，它们有一些关键的区别。 重定向（Redirect）是指当一个Servlet收到一个请求时，它会发送一个HTTP响应告诉浏览器发送一个新的请求到指定的URL。这个URL可以是一个Servlet、JSP、HTML页面或其他任何类型的资源。因此，重定向会导致浏览器向指定的URL发起一个全新的请求，而这个新请求的路径是由浏览器在重定向时自动发送的，不再是原始请求的路径。在重定向中，所有请求参数都会丢失，因此需要通过查询字符串或Session等方式传递参数。重定向可以用于将用户重定向到一个新的页面，或者将用户从一个应用程序重定向到另一个应用程序。 转发（Forward）是指当一个Servlet收到一个请求时，它会将请求转发到另一个Servlet或JSP来处理。在转发中，请求和响应对象是同一个，只是Servlet容器将请求转发给了另一个资源来生成响应。因此，在转发中，所有请求参数都会保留，并且可以在目标Servlet或JSP中访问。转发通常用于将请求从一个Servlet传递到另一个Servlet或JSP来生成响应，以便可以在请求和响应之间共享数据。 因此，重定向和转发都可以将请求从一个Servlet转发到另一个Servlet或JSP来生成响应，但它们的区别在于重定向会发送一个新的请求到指定的URL，而转发则将请求转发到另一个Servlet或JSP来处理，响应由目标Servlet或JSP生成。重定向导致的性能开销比转发更高，因为它需要向浏览器发送一个新的请求，而转发则在服务器内部进行，无需向浏览器发送任何内容。 123456public class RedirectServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.sendRedirect(&quot;/response/img&quot;); // 重定向 &#125; 5.简单实现登录重定向 12345public class Log extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.getServletContext().getRequestDispatcher(&quot;/hello&quot;).forward(req, resp); &#125; 这段代码用于Java Servlet编程中，将一个请求从一个Servlet转发到同一Web应用程序中的另一个Servlet或JSP（Java服务器页面）。 getRequestDispatcher()方法的参数是请求转发到的资源的相对或绝对路径。在本例中，路径为“/hello”，这是另一个Servlet. 然后调用RequestDispatcher对象的forward()方法，传递req和resp参数。这些是传递到原始Servlet的doGet()或doPost()方法中的HttpServletRequest和HttpServletResponse对象。forward()方法将这些对象发送到指定的资源，并允许该资源生成要发送回客户端的响应。 总之，这段代码将一个请求从当前Servlet转发到同一Web应用程序中的另一个Servlet或JSP，同时传递HttpServletRequest和HttpServletResponse对象。目标资源将生成要发送回客户端的响应。 HttpServletRequest HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息； 12345678910111213// HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，// HTTP请求中的所有信息会被封装到HttpServletRequest，// 通过这个HttpServletRequest的方法，获得客户端的所有信息； String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String host = req.getHeader(&quot;Host&quot;); resp.getWriter().println(&quot;username:&quot;+username+&quot; password:&quot;+password+&quot; host:&quot;+host);// `req.getContextPath()` 是一个 Java Servlet API 中的方法，它返回当前 Servlet 的上下文路径。// 上下文路径是指 Web 应用程序的 URL 中，主机名和端口号后的第一个路径。//例如，如果 Web 应用程序的 URL 是 `http://example.com:8080/myapp/index.jsp`，// 那么上下文路径就是 `/myapp`。 resp.getWriter().println(&quot;Context path&quot;+req.getContextPath()); 保存会话的两种技术 Cookies HTTP cookie，简称cookie，又称“网站／浏览＋魔饼／魔片”等，是浏览网站时由网络服务器创建并由网页浏览器存放在用户计算机或其他设备的小文本文件。 Cookie使Web服务器能在用户的设备存储状态信息（如添加到在线商店购物车中的商品）或跟踪用户的浏览活动（如点击特定按钮、登录或记录历史. cookie 是服务器在 HTTP 响应中发送的一段数据。客户端（可选）存储 cookie 并在后续请求中返回它。这允许客户端和服务器共享状态。要设置 cookie，服务器会在响应中包含一个 Set-Cookie 标头。cookie 的格式是名称-值对，带有可选属性。例如： 1Set-Cookie: session-id=1234567 这是一个带有属性的示例： 1Set-Cookie: session-id=1234567; max-age=86400; domain=example.com; path=/; 为了向服务器返回 cookie，客户端在以后的请求中包含一个 Cookie 标头。 1Cookie: session-id=1234567 利用Cookies记录用户上一次登录时间 1234567891011121314151617public class Cookie extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //get all cookies javax.servlet.http.Cookie[] cookies = req.getCookies(); for (javax.servlet.http.Cookie cookie : cookies) &#123; String name = cookie.getName(); if(name.equals(&quot;lastLoginTime&quot;))&#123; String value = cookie.getValue(); long parseLong = Long.parseLong(cookie.getValue()); Date date = new Date(parseLong); resp.getWriter().println(&quot;lastLoginTime: &quot;+date.toLocaleString()); &#125; &#125; javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis() + &quot;&quot;); resp.addCookie(cookie); &#125; session 在计算机科学领域来说，尤其是在网络领域，会话（英语：session，Microsoft Windows译作工作阶段、连线阶段）是一种持久网络协议，在用户（或用户代理）端和服务器端之间创建关联，从而起到交换数据包的作用机制，session在网络协议（例如telnet或FTP）中是非常重要的部分。 在不包含会话层（例如UDP）或者是无法长时间驻留会话层（例如HTTP）的传输协议中，会话的维持需要依靠在传输数据中的高级别程序。例如，在浏览器和远程主机之间的HTTP传输中，HTTP cookie就会被用来包含一些相关的信息，例如session ID，参数和权限信息等。 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！ 服务器会给每一个用户（浏览器）创建一个Seesion对象； 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息…… Session和cookie的区别： Cookie和Session是Web应用程序中常用的两种用于保存用户状态信息的机制。 相同点： 都是用于在Web应用程序中保存用户状态信息的机制。 都可以在多个请求之间保持用户的状态信息，使用户在浏览网站时能够保持状态的连续性。 都可以在一定程度上提高Web应用程序的性能，减少对服务器的负载。 不同点： 存储位置不同：Cookie保存在客户端的浏览器中，而Session保存在服务器端的内存或者硬盘中。 存储容量不同：Cookie的存储容量比Session小。 安全性不同：由于Session数据存储在服务器端，因此相对于Cookie更加安全，Cookie数据容易被篡改或盗用。 过期时间不同：Session的过期时间可以由开发人员在代码中设置，而Cookie的过期时间可以在创建Cookie时设置，也可以在浏览器中手动删除。 使用场景不同：Cookie适用于需要长期保存用户状态信息的场景，例如保存用户的登录状态、偏好设置等；而Session适用于需要在短时间内保存用户状态信息的场景，例如购物车、会话信息等。 利用Session返回客户端一个Person对象, 并在浏览器上打印 1234567891011121314151617public class Session extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); session.setAttribute(&quot;person&quot;,new Person(&quot;Alice&quot;, &quot;Alice@gmail.com&quot;)); resp.getWriter().write(&quot;Session id&quot;+session.getId()); Person person = (Person) session.getAttribute(&quot;person&quot;); resp.getWriter().write(&quot;name&quot;+person.toString()); &#125; //client 每次访问服务器都会在服务器端维护一个Session, 并向用户以Cookie的方式，发送Session id,// 但是对于client而言， 这个Session id 是以Cookie的形式存储在浏览器上的， 所以更换浏览器访问后Cookie改变了// 所以，服务器会认为这是一个新的Session.// 下一次用户再次访问的时候就会拿着这个Session id 访问Serve， Server就知道这个客户的信息// 1. 拿到Session， 这个Cookie是由客户端发送给服务器的// Session 可以使用setAttribute方法来保存信息// 不同于Cookie，Session 可以保存一个对象(Object)， 而不是仅仅是一个String 会话自动过期：web.xml配置！ 12345&lt;!--设置Session默认的失效时间--&gt;&lt;session-config&gt; &lt;!--15分钟后Session自动失效，以分钟为单位--&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt; JSP (Java Server Pages) JSP（全称Jakarta Server Pages，曾称为JavaServer Pages）是由Sun Microsystems公司主导创建的一种动态网页技术标准。 Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！ 最大的特点： 写JSP就像在写HTML； 区别： HTML只给用户提供静态的数据； JSP页面中可以嵌入JAVA代码，为用户提供动态数据； JSP原理 思路：JSP到底怎么执行的！ 服务器内部工作： tomcat中有一个work目录； IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录； IDEA会为每个Tomcat Webapps创建一个文件夹,用来存放这个APP的配置文件, 工作路径, 在我的MAC路径/Users/trevorwu/Library/Caches/JetBrains/IntelliJIdea2022.3/tomcat/47ad80c0-0fbd-41b1-a4ae-e036ca41705b 我们进入这个路径的最深处 `cd Catalina/localhost/ROOT/org/apache/jsp 可以看到这里面有两个文件, 一个是index_jsp.class 另一个是index_jsp.java` 很明显, `index_jsp.class`就是index_jsp.java` 编译生成的class文件. 这是只有一个这样的class, 也就是我们的主页index.jsp 也就是说, 如果我们访问index.jsp, 相当于访问根目录localhost:8080/ 服务器就会生成对应的.java文件, 以及.class文件用来处理请求. 这个.java文件本质上就是Servlet. 如果这时候我们访问别的页面, 就会生成新的Servlet. 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！ JSP最终也会被转换成为一个Java类！ JSP 本质上就是一个Servlet！ 123456789// 初始化 public void _jspInit() &#123; &#125;// 销毁 public void _jspDestroy() &#123; &#125;// JSPService public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; 内置一些对象； 12345678final javax.servlet.jsp.PageContext pageContext; // 页面上下文javax.servlet.http.HttpSession session = null; // sessionfinal javax.servlet.ServletContext application; // applicationContextfinal javax.servlet.ServletConfig config; // configjavax.servlet.jsp.JspWriter out = null; // outfinal java.lang.Object page = this; // page：当前HttpServletRequest request // 请求HttpServletResponse response // 响应 输出页面前增加的代码； 123456789response.setContentType(&quot;text/html&quot;); // 设置响应的页面类型pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();session = pageContext.getSession();out = pageContext.getOut();_jspx_out = out; 以上的这些个对象我们可以在JSP页面中直接使用！ 在JSP页面中： 只要是 JAVA代码就会原封不动的输出； 如果是HTML代码，就会被转换为： 12345678out.write(&quot;&lt;html&gt;\\n&quot;);out.write(&quot; &lt;head&gt;\\n&quot;);out.write(&quot; &lt;title&gt;$Title$&lt;/title&gt;\\n&quot;);out.write(&quot; &lt;/head&gt;\\n&quot;);out.write(&quot; &lt;body&gt;\\n&quot;);out.write(&quot; $END$\\n&quot;);out.write(&quot; &lt;/body&gt;\\n&quot;);out.write(&quot;&lt;/html&gt;\\n&quot;); 这样的格式，输出到前端！ JSP语法 任何语言都有自己的语法，JAVA中有，JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！ 配置必需的maven环境： 123456789101112131415161718&lt;!-- JSP 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt;&lt;!-- JSTL表达式的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;!-- standard标签库--&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; JSP表达式 1234567&lt;body&gt;&lt;%--JSP表达式 作用：用来将程序的输出，输出到客户端 &lt;%= 变量或者表达式%&gt;--%&gt;&lt;%= new java.util.Date()%&gt;&lt;/body&gt; jsp脚本片段 12345678910&lt;body&gt;&lt;%--jsp脚本片段--%&gt;&lt;% int sum = 0; for (int i = 1; i &lt;=100 ; i++) &#123; sum+=i; &#125; out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt;&lt;/body&gt; JSP声明 &lt;%! code %&gt; 1234567891011&lt;body&gt;&lt;%! static &#123; System.out.println(&quot;Loading Servlet!&quot;); &#125; private int globalVar = 0; public void guo()&#123; System.out.println(&quot;进入了方法guo！&quot;); &#125;%&gt;&lt;/body&gt; JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！ JSP指令: 404与500页面实现 1234567891011&lt;!-- 自定义错误页面--&gt;&lt;!-- 配置之后记得重启Tomcat服务， 修改tomcat配置文件web.xml热部署不生效--&gt;&lt;!-- 自由修改jsp文件才能热部署--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.jsp&lt;/location&gt; &lt;/error-page&gt; 头部和尾部页面拼接 123456789101112131415161718&lt;body&gt; &lt;%-- @include会将两个页面合二为一 --%&gt; &lt;%@include file=&quot;common/header.jsp&quot;%&gt; &lt;h1&gt;网页主体&lt;/h1&gt; &lt;%@include file=&quot;common/footer.jsp&quot;%&gt; &lt;hr&gt; &lt;%-- jsp标签 jsp:include：拼接页面，本质还是三个 --%&gt; &lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt; &lt;h1&gt;网页主体&lt;/h1&gt; &lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;&lt;/body&gt; 内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【SerlvetContext】 存东西 config 【SerlvetConfig】 out page ，不用了解 exception 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt;&lt;%--内置对象--%&gt;&lt;% pageContext.setAttribute(&quot;name1&quot;,&quot;天启1号&quot;); // 保存的数据只在一个页面中有效 request.setAttribute(&quot;name2&quot;,&quot;天启2号&quot;); // 保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(&quot;name3&quot;,&quot;天启3号&quot;); // 保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(&quot;name4&quot;,&quot;天启4号&quot;); // 保存的数据只在服务器中有效，从打开服务器到关闭服务器%&gt;&lt;%-- 脚本片段中的代码，会被原封不动生成到.jsp.java 要求：这里面的代码，必须保证Java语法的正确性--%&gt;&lt;% // 从pageContent取出，我们通过寻找的方式来 // 从底层到高层（作用域）: String name1 = (String) pageContext.findAttribute(&quot;name1&quot;); String name2 = (String) pageContext.findAttribute(&quot;name2&quot;); String name3 = (String) pageContext.findAttribute(&quot;name3&quot;); String name4 = (String) pageContext.findAttribute(&quot;name4&quot;); String name5 = (String) pageContext.findAttribute(&quot;name5&quot;); // 作用域%&gt;&lt;%--使用EL表达式输出 $&#123;&#125; --%&gt;&lt;h1&gt;取出的值:&lt;/h1&gt;&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;&lt;h3&gt; &lt;%=name5%&gt; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车； application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据； JSP标签.JSTL标签.EL表达式 EL表达式： ${ } 获取数据 执行运算 获取web开发的常用对象 123456789101112&lt;!-- JSTL表达式的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- standard标签库 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; JSP标签 利用JSP标签实现请求转发, 并设置参数 &lt;jsp:forward page=“url”&gt; 1234567&lt;body&gt;&lt;%--jsp:include--%&gt;&lt;jsp:forward page=&quot;/jspTag2.jsp&quot;&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;subeiLY&quot;/&gt; &lt;jsp:param name=&quot;age&quot; value=&quot;18&quot;/&gt;&lt;/jsp:forward&gt;&lt;/body&gt; 再转发的目标Servlet取参数 12345&lt;body&gt;&lt;%--取出参数--%&gt;名字:&lt;%=request.getParameter(&quot;name&quot;)%&gt;年龄:&lt;%=request.getParameter(&quot;age&quot;)%&gt;&lt;/body&gt; JSTL表达式 JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！ 格式化标签 SQL标签 XML 标签 核心标签 （掌握部分） JSTL标签库使用步骤： 引入对应的 taglib； 使用其中的方法； 在Tomcat 的lib目录下也需要引入 jstl-api-1.2.jar、standard-1.1.2.jar的包，否则会报错：JSTL解析错误； c：if标签 EL表达式获取表单中的数据 1234567891011121314151617&lt;body&gt;&lt;form action=&quot;core-if.jsp&quot; method=&quot;get&quot;&gt; &lt;%-- EL表达式获取表单中的数据 $&#123;param.参数名&#125; --%&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;&lt;c:if test=&quot;$&#123;param.username==&#x27;admin&#x27;&#125;&quot; var=&quot;isAdmin&quot;&gt; &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;&lt;/c:if&gt; &lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;&lt;/body&gt; c:choose c:when 实现成绩判断(Switch case) 1234567891011121314151617181920&lt;body&gt;&lt;%--定义一个变量score，值为85--%&gt;&lt;c:set var=&quot;score&quot; value=&quot;65&quot;/&gt;&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt; 你的成绩为优秀 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt; 你的成绩为一般 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt; 你的成绩为良好 &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&lt;=60&#125;&quot;&gt; 你的成绩为不及格 &lt;/c:when&gt;&lt;/c:choose&gt;&lt;/body&gt; c:forEach 123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;% ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;(); people.add(0,&quot;Alice&quot;); people.add(1,&quot;Bob&quot;); people.add(2,&quot;楼兰&quot;); people.add(3,&quot;Goobus&quot;); people.add(4,&quot;Kris&quot;); request.setAttribute(&quot;list&quot;,people);%&gt;&lt;%--var , 每一次遍历出来的变量items, 要遍历的对象begin, 哪里开始end, 到哪里step, 步长 (i++)--%&gt;&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot;&gt; &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;1&quot; &gt; &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt; &lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt; JavaBean 实体类，JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法； 一般用来和数据库的字段做映射 ORM； ORM ：对象关系映射 表—&gt;类 字段–&gt;属性 行记录----&gt;对象 1234567891011&lt;jsp:useBean id=&quot;people&quot; class=&quot;cn.loulan.Bean.People&quot; /&gt;&lt;jsp:setProperty name=&quot;people&quot; property=&quot;address&quot; value=&quot;成都&quot;/&gt;&lt;jsp:setProperty name=&quot;people&quot; property=&quot;id&quot; value=&quot;1&quot;/&gt;&lt;jsp:setProperty name=&quot;people&quot; property=&quot;age&quot; value=&quot;2&quot;/&gt;&lt;jsp:setProperty name=&quot;people&quot; property=&quot;name&quot; value=&quot;哇哈哈AD钙&quot;/&gt;姓名:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;name&quot;/&gt; ID:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;id&quot;/&gt;年龄:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;age&quot;/&gt;地址:&lt;jsp:getProperty name=&quot;people&quot; property=&quot;address&quot;/&gt; MVC三层架构 什么是MVC： Model view Controller 模型.视图.控制器 1.早些年 用户直接访问控制层，控制层就可以直接操作数据库； 12345678910servlet--CRUD--&gt;数据库弊端：程序十分臃肿，不利于维护 servlet的代码中：处理请求.响应.视图跳转.处理JDBC.处理业务代码.处理逻辑代码架构：没有什么是加一层解决不了的！程序猿调用|JDBC|Mysql Oracle SqlServer .... 2.MVC三层架构 Model 业务处理 ：业务逻辑（Service） 数据持久层：CRUD （Dao） View 展示数据 提供链接发起Servlet请求 （a，form，img…） Controller （Servlet） 接收用户的请求 ：（req：请求参数.Session信息….） 交给业务层处理对应的代码 控制视图的跳转 1登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库 Filter(重点) Filter：过滤器 ，用来过滤网站的数据； 处理中文乱码 登录验证…. Filter开发步骤： 导包 编写过滤器 123456789101112131415161718192021222324252627282930&lt;!-- Servlet 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSP 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSTL表达式的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- standard标签库--&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 连接数据库--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 实现Filter接口，重写对应的方法即可； 使用Filter设置编码, 防止乱码 123456789101112public class Filter implements javax.servlet.Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; //项目启动的时候被调用 System.out.println(&quot;init filter&quot;); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;UTF-8&quot;); servletResponse.setCharacterEncoding(&quot;UTF-8&quot;); filterChain.doFilter(servletRequest,servletResponse); &#125; 这段代码是Java Servlet中用于实现Filter的接口方法doFilter()的签名。 Filter是一种用于在Servlet容器中对请求和响应进行预处理和后处理的组件。Filter可以截取请求和响应，修改请求参数或响应内容，或者根据某些条件决定是否允许请求继续处理。 doFilter()方法接受三个参数： ServletRequest servletRequest、 ServletResponse servletResponse FilterChain filterChain ServletRequest表示接收到的HTTP请求，ServletResponse表示将要发送的HTTP响应，FilterChain表示Filter链。 在doFilter()方法中，Filter可以对请求和响应进行任何必要的操作。 例如，可以检查请求参数、修改请求头、记录请求日志等。 然后，Filter必须调用filterChain.doFilter()方法，将请求传递给下一个Filter或目标Servlet来进行处理。 如果不调用filterChain.doFilter()方法，请求将不会传递到下一个组件，也不会生成响应。在最后一个Filter或目标Servlet中，必须生成响应并将其发送回客户端。 在Filter链中的每个Filter都必须调用filterChain.doFilter()方法，否则请求将停止在当前Filter，不会传递到后续的Filter或目标Servlet。 如果在Filter链中的某个Filter中调用了filterChain.doFilter()方法之前或之后生成了响应，或者没有调用filterChain.doFilter()方法，都会导致请求失败或无法正常响应。 在web.xml中配置 Filter； 12345678910&lt;!--mapping filter--&gt; &lt;filter&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;filter-class&gt;cn.loulan.servlet.Filter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encode&lt;/filter-name&gt; &lt;!--只要是 /filter的任何请求，会经过这个过滤器--&gt; &lt;url-pattern&gt;/filter&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 监听器(Listener) 实现一个监听器的接口；（有N种） 编写一个监听器； 实现监听器的接口… 1234567891011121314151617181920212223242526272829public class OnlineCountListener implements HttpSessionListener &#123;// 我们使用一个Integer对象来表示当前在线用户数，// 并且在每次Session创建时，都将在线用户数加1。// 然后，我们将在线用户数存储在ServletContext中，// 以便在整个Web应用程序中共享和使用。 @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123; ServletContext servletContext = httpSessionEvent.getSession().getServletContext(); Integer onlineCounter = (Integer) servletContext.getAttribute(&quot;onlineCounter&quot;); if(onlineCounter == null)&#123; onlineCounter = Integer.valueOf(1); &#125; else &#123; onlineCounter = Integer.valueOf(onlineCounter.intValue() + 1); &#125; servletContext.setAttribute(&quot;onlineCounter&quot;, onlineCounter); &#125; @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123; Integer onlineCounter = (Integer) httpSessionEvent.getSession().getServletContext().getAttribute(&quot;onlineCounter&quot;); if(onlineCounter == null)&#123; onlineCounter = Integer.valueOf(0); &#125;else &#123; onlineCounter = Integer.valueOf(onlineCounter.intValue()- 1); &#125; httpSessionEvent.getSession().setAttribute(&quot;onlineCounter&quot;, onlineCounter); &#125;&#125; 注册监听器 1234&lt;!-- Listener--&gt; &lt;listener&gt; &lt;listener-class&gt;cn.loulan.servlet.OnlineCountListener&lt;/listener-class&gt; &lt;/listener&gt; 过滤器.监听器常见应用 监听器：GUI编程中经常使用； 12345678910111213141516171819202122232425public class TestPanel &#123; public static void main(String[] args) &#123; // 新建一个窗体 Frame frame = new Frame(&quot;Happy Day&quot;); // 面板 Panel panel = new Panel(null); // 设置窗体的布局 frame.setLayout(null); frame.setBounds(300,300,500,500); // 设置背景颜色1 frame.setBackground(Color.lightGray); // 设置背景颜色2 panel.setBackground(Color.orange); panel.setBounds(frame.getX()/2, frame.getY()/2, frame.getWidth()/2, frame.getHeight()/2); frame.add(panel); frame.setVisible(true); // 监听事件，监听关闭事件 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; frame.dispose(); &#125; &#125;); &#125;&#125; 过滤器：用户登录之后才能进入主页！用户注销后就不能进入主页了 用户登录之后，向Sesison中放入用户的数据 进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！ 12345678910111213public class Log extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); HttpSession session = req.getSession(); if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;root&quot;.equals(password)) &#123; session.setAttribute(Constants.USER_SESSION,new Person(username,password)); resp.sendRedirect(&quot;/pages/success.jsp&quot;); &#125; else &#123; resp.sendRedirect(&quot;/&quot;); &#125; &#125; LoginFilter 123456789101112131415public class LoginFilter extends Filter&#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;// ServletRequest 转化为 HttpServletRequest // 目的是拿到Session, 以便获取Attribute HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; Object o = request.getSession().getAttribute(Constants.USER_SESSION); if(o == null) &#123; response.sendRedirect(&quot;/&quot;); &#125; filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; LogoutServlet 1234567,public class Logout extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getSession().setAttribute(Constants.USER_SESSION,null); resp.sendRedirect(&quot;/&quot;); &#125;,&#125; 通过设置Session的Attribute(Constants.USER_SESSION)值为空来实现用户的登录, 这种方式不需要服务器重复创建和销毁Session就可以实现用户的注销, 减轻了服务器负担. JDBC 什么是JDBC ： Java连接数据库！ 需要jar包的支持： java.sql javax.sql mysql-connecter-java… 连接驱动（必须要导入） 加载驱动 连接数据库,代表数据库 编写SQL （根据业务，不同的SQL） 预编译 执行SQL 关闭连接 12345678910111213141516171819202122232425public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 配置信息 // useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码 String url=&quot;jdbc:mysql://localhost:3307/JDBC?useUnicode=true&amp;characterEncoding=utf-8&quot;; String username = &quot;root&quot;; String password = &quot;&quot;; // 2.连接数据库,代表数据库 Connection connection = DriverManager.getConnection(url, username, password); // 3.编写SQL String sql = &quot;select * from user&quot;;// 4. 预编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // 5.执行查询SQL，返回一个 ResultSet ： 结果集 ResultSet rs = preparedStatement.executeQuery(sql); while (rs.next()) &#123; System.out.println(rs.getObject(&quot;name&quot;)); System.out.println(rs.getObject(&quot;email&quot;)); System.out.println(rs.getObject(&quot;password&quot;)); System.out.println(rs.getObject(&quot;role&quot;)); &#125; // 6.关闭连接，释放资源（一定要做） 先开后关 rs.close(); preparedStatement.close(); connection.close();&#125; 预编译: 使用占位符 在 JDBC 中，预编译 SQL 的主要目的是提高执行 SQL 语句的效率。当一个 SQL 语句被预编译后，JDBC 驱动程序会将该语句存储在数据库中，并将其与一个预定义的执行计划关联起来。这样，在执行该 SQL 语句时，JDBC 驱动程序可以直接使用预定义的执行计划，而不必重新解析 SQL 语句和生成执行计划，从而提高了执行效率。 另外，预编译 SQL 还可以提高代码的可维护性和安全性。通过使用预编译 SQL，我们可以将 SQL 语句与 Java 代码分离开来，使得代码更易于维护。此外，预编译 SQL 可以避免 SQL 注入等安全问题。 具体地，预编译 SQL 的过程包括两个步骤：首先，使用 Connection 接口中的 prepareStatement() 方法创建一个 PreparedStatement 对象；然后，使用 PreparedStatement 对象的 setXXX() 方法设置 SQL 语句中的参数，并使用 execute() 或 executeUpdate() 方法执行 SQL 语句。 以下是一个使用预编译 SQL 的示例代码： 1234567String sql = &quot;SELECT * FROM users WHERE name = ?&quot;;PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1, &quot;John&quot;);ResultSet rs = pstmt.executeQuery();while (rs.next()) &#123; // process the result set&#125; 在上述示例代码中，我们首先使用 prepareStatement() 方法创建了一个 PreparedStatement 对象，然后使用 setString() 方法设置了 SQL 语句中的参数，并最终使用 executeQuery() 方法执行 SQL 语句。这样，在执行 SQL 语句时，JDBC 驱动程序会使用预定义的执行计划，从而提高了执行效率。 SQL注入 SQL 注入（SQL Injection）是一种常见的网络安全漏洞，它允许攻击者在执行 SQL 查询时向查询中插入恶意代码，从而获得对数据库的非授权访问。攻击者可以通过构造特定的 SQL 查询语句，从而绕过身份验证、窃取数据或破坏数据库。 例如，考虑下面的 SQL 查询语句： 1SELECT * FROM users WHERE username = &#x27;&lt;input&gt;&#x27;; 如果用户输入 &lt;input&gt; 的值为 ' or '1'='1，那么最终的 SQL 查询语句就会变成： 1SELECT * FROM users WHERE username = &#x27;&#x27; or &#x27;1&#x27;=&#x27;1&#x27;; 这样就会返回所有用户的记录，而不仅仅是指定的用户名。攻击者可以通过这种方式获取到数据库中的敏感数据或者执行其他恶意操作。 实战: 超市订单管理系统 为了方便表述和理解, 在编写MVC三层对应的代码时, 使用自顶向下, 但在实际的项目中, 编写代码工作往往是自底向上的. 搭建项目框架 编写数据库操作的基础公共类DB 数据库配置文件，这是一个资源文件，应该创建在maven项目的resources文件中 1234DRIVER=com.mysql.jdbc.DriverURL=jdbc:mysql://localhost:3307/smbms?useUnicode=true&amp;characterEncoding=utf-8USERNAME=rootPASSWORD= 使用静态代码块实现初始化参数 该类为数据库访问工具类，提供了获取数据库连接、执行查询和更新等常用操作的方法。 类名：DB 属性： DRIVER：String类型，表示数据库驱动名。 URL：String类型，表示数据库连接地址。 USERNAME：String类型，表示连接数据库的用户名。 PASSWORD：String类型，表示连接数据库的密码。 方法： close：用于释放数据库连接、预处理语句和结果集资源。 getConnection：用于获取数据库连接。 executeQuery：用于执行查询操作，返回一个结果集。 executeUpdate：用于执行更新操作，返回受影响的行数。 方法的参数： conn：Connection类型，表示数据库连接。 pstmt：PreparedStatement类型，表示预处理语句。 resSet：ResultSet类型，表示结果集。 query：String类型，表示要执行的SQL语句。 params：Object[]类型，表示SQL语句中的参数值。 在类中还定义了一个静态代码块，该代码块在类加载时会被执行。静态代码块中的主要作用是读取配置文件中的数据库连接参数，并将其赋值给类的静态属性。具体实现如下： 创建Properties对象。 通过类加载器加载配置文件为字节输入流。 使用Properties对象的load()方法加载字节输入流中的内容。 从Properties对象中获取数据库连接参数，并将其赋值给类的静态属性。 通过这种方式，可以在不修改Java代码的情况下，更改数据库连接参数，提高了代码的灵活性和可维护性。 1234567891011121314151617181920212223public class DB &#123; private static String DRIVER; private static String URL; private static String USERNAME; private static String PASSWORD; //静态代码块， 类加载的时候执行 static &#123; //读取配置文件 //1、创建properties对象 Properties properties = new Properties(); //2、通过类加载器加载资源文件为字节输入流 InputStream in = DB.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); try &#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; DRIVER = properties.getProperty(&quot;DRIVER&quot;); URL = properties.getProperty(&quot;URL&quot;); USERNAME = properties.getProperty(&quot;USERNAME&quot;); PASSWORD = properties.getProperty(&quot;PASSWORD&quot;); &#125;&#125; 编写数据库操作的公共方法 该类为数据库访问工具类，提供了获取数据库连接、执行查询和更新等常用操作的方法。 类名：DB 属性： DRIVER：String类型，表示数据库驱动名。 URL：String类型，表示数据库连接地址。 USERNAME：String类型，表示连接数据库的用户名。 PASSWORD：String类型，表示连接数据库的密码。 方法： close：用于释放数据库连接、预处理语句和结果集资源。 getConnection：用于获取数据库连接。 executeQuery：用于执行查询操作，返回一个结果集。 executeUpdate：用于执行更新操作，返回受影响的行数。 方法的参数： conn：Connection类型，表示数据库连接。 pstmt：PreparedStatement类型，表示预处理语句。 resSet：ResultSet类型，表示结果集。 query：String类型，表示要执行的SQL语句。 params：Object[]类型，表示SQL语句中的参数值。 该类还包含一个静态代码块，用于初始化数据库连接参数，但代码块的内容未给出，需要进行补充。 同时需要注意，该类并没有实现单例模式，每次获取数据库连接都会重新创建一个新的连接，这可能会导致性能问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class DB &#123; private static String DRIVER; private static String URL; private static String USERNAME; private static String PASSWORD; //插入静态代码块(need to fininsh) //释放链接资源 public static void close(Connection conn, PreparedStatement pstmt, ResultSet resSet) throws SQLException &#123; if(resSet != null)&#123; resSet.close(); &#125; if(pstmt != null)&#123; pstmt.close(); &#125; if(conn != null) &#123; conn.close(); &#125; &#125; //获取数据库链接 public static Connection getConnection() throws SQLException, ClassNotFoundException &#123; Class.forName(DRIVER); String url = URL; String username = USERNAME; String password = PASSWORD; // 2.连接数据库,代表数据库 Connection connection = DriverManager.getConnection(url, username, password); return connection; &#125; //执行查询, 返回结果集 public static ResultSet executeQuery(Connection conn,String query,Object[] params) throws SQLException, ClassNotFoundException&#123; ResultSet resultSet = null; if(conn != null &amp;&amp; !query.isEmpty() &amp;&amp; params != null)&#123; //预处理 PreparedStatement statement = conn.prepareStatement(query); for (int i = 0; i &lt; params.length;i++)&#123; //设置SQL 语句中的参数 statement.setString(i+1,params[i].toString()); &#125; //执行 resultSet = statement.executeQuery(); &#125; return resultSet; &#125; //执行更新， 返回影响行数 public static int executeUpdate(Connection conn,String query,Object[] params) throws SQLException &#123; int affectedRows = 0; if(conn != null &amp;&amp; !query.isEmpty() &amp;&amp; params != null)&#123; //预处理 PreparedStatement statement = conn.prepareStatement(query); for (int i = 0; i &lt; params.length;i++)&#123; //设置SQL 语句中的参数 statement.setString(i+1,params[i].toString()); &#125; //执行 affectedRows = statement.executeUpdate(); &#125; return affectedRows; &#125;&#125; 登录功能实现 前端页面编写 前端页面由kuang提供 1234567891011121314151617&lt;%-- header--%&gt;&lt;form class=&quot;loginForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot; name=&quot;actionForm&quot; id=&quot;actionForm&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;info&quot;&gt;$&#123;error&#125;&lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;input-text&quot; id=&quot;userCode&quot; name=&quot;userCode&quot; placeholder=&quot;请输入用户名&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;userPassword&quot; name=&quot;userPassword&quot; placeholder=&quot;请输入密码&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;subBtn&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; &lt;/div&gt;&lt;/form&gt;&lt;%-- footer--%&gt; 登录处理Servlet实现 在前端form表单的action属性值我们可以看到提交的URL, 所以, 我们需要编写对应的Servlet来处理这个请求 1action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot; 创建登录处理Servlet 以下是一个名为“Login”的Java servlet类，用于处理HTTP GET请求。该类包括对“UserService”实例的引用，该实例用于从数据库中检索用户信息。 在“doGet”方法中，servlet从HTTP请求中检索userCode和password参数。然后它创建一个“UserServiceImpl”类的新实例（该类实现了“UserService”接口），并调用其“findByUserCode”方法，以根据给定的用户代码从数据库中检索用户对象。 如果用户对象不为null，则servlet检查用户密码是否与给定密码匹配。如果匹配，则servlet使用用户对象设置名为“USER_SESSION”的会话属性，并将用户重定向到“/jsp/frame.jsp”。如果密码不匹配，则servlet使用错误消息设置名为“error”的会话属性，并将用户重定向回“/login.jsp”。 请注意，此代码片段不完整，因为它缺少有关导入，它所依赖的接口和类，以及servlet配置的信息。 12345678910111213141516171819public class Login extends HttpServlet &#123; private UserService service; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String userCode = req.getParameter(&quot;userCode&quot;); String password = req.getParameter(&quot;userPassword&quot;); service = new UserServiceImpl(); User user = null; user = service.findByUserCode(userCode); if(user != null) &#123; if(user.getUserPassword().equals(password)) &#123; req.getSession().setAttribute(Constant.USER_SESSION,user); resp.sendRedirect(&quot;/jsp/frame.jsp&quot;); &#125; else &#123; req.getSession().setAttribute(&quot;error&quot;,&quot;username or password incorrect&quot;); resp.sendRedirect(&quot;/login.jsp&quot;); &#125; &#125; &#125; 映射 servlet 这段代码是一个 servlet 配置的 XML 部分，它用于将请求的 URL 映射到特定的 servlet 上。这段配置指定了一个名为 “Login” 的 servlet，使用了完整的类名 servlet.Login，并将它映射到 URL “/login.do” 上。 这意味着，当用户在浏览器中访问 “/login.do” 时，容器将调用 servlet.Login 的 service() 方法来处理该请求。映射 servlet 的操作是 web 应用的一部分，它在 web.xml 文件中进行配置。 12345678&lt;servlet&gt; &lt;servlet-name&gt;Login&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.Login&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写Service层代码 该代码是一个 Java 类 UserServiceImpl，实现了一个接口 UserService。该类包含了两个方法： findByUserCode(String userCode)：查找数据库中对应用户的信息，该方法返回一个 User 对象。 updateUser(Integer id, String key, String value)：更新数据库中用户的信息，该方法返回一个 boolean 类型的值，表示更新是否成功。 在这个类中，私有成员变量 dao 是一个 UserDao 类型的变量，通过该变量调用 UserDaoImpl 类中的方法来访问数据库。在 findByUserCode 和 updateUser 方法中，都需要先通过 dao 实例化一个 UserDaoImpl 对象来调用相应的方法。 1234567891011121314151617public class UserServiceImpl implements UserService &#123; private UserDao dao; @Override public User findByUserCode(String userCode)&#123; dao = new UserDaoImpl(); User user = dao.findByUserCode(userCode); return user; &#125; @Override public boolean updateUser(Integer id, String key, String value) &#123; dao = new UserDaoImpl(); int i = 0; i = dao.updateUser(id, key, value); return i &gt; 0 ? true : false; &#125;&#125; DAO层代码 这段代码是一个Dao层的实现类，用于和数据库交互，提供了对User表的查询和更新方法。下面是代码的分析： findByUserCode(String userCode) 方法：根据传入的用户名参数 userCode 查询对应的用户记录，并返回一个User对象。该方法使用了数据库连接池技术，在执行完查询后会关闭连接。方法中首先初始化参数，然后执行SQL语句查询结果集，遍历结果集将数据封装到User对象中，最后关闭连接和结果集，返回User对象。 updateUser(Integer id, String key,String value) 方法：根据传入的参数更新User表中的数据。该方法也使用了数据库连接池技术，在执行完更新后会关闭连接。方法中首先判断传入的参数是否为空，然后执行SQL语句更新数据，最后关闭连接，返回更新结果的影响行数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class UserDaoImpl implements UserDao&#123; private User user; private Connection conn; private String sql; @Override public User findByUserCode(String userCode)&#123; //2. 初始化参数 Object[] params = &#123;userCode&#125;; ResultSet set; sql = &quot;SELECT * FROM smbms_user Where userCode = ?&quot;; try &#123; conn = DB.getConnection(); set = DB.executeQuery(conn, sql,params); if(set != null)&#123; user = new User(); while (set.next()) &#123; user.setUserPassword(set.getString(&quot;userPassword&quot;)); //一大串赋值代码... user.setWorkPicPath(&quot;workPicPath&quot;); &#125; &#125; else &#123; return null; &#125; //关闭链接和结果集 DB.close(conn,null,set); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; return user; &#125; @Override public int updateUser(Integer id, String key,String value) &#123; int affectedRow = 0; if(id != null&amp;&amp; value != null &amp;&amp; key != null)&#123; Connection conn = null; sql = &quot;UPDATE smbms_user SET &quot;+key+&quot; = ? WHERE id = ? &quot;; Object[] params = &#123;value,id&#125;; try &#123; conn = DB.getConnection(); affectedRow = DB.executeUpdate(conn, sql, params); DB.close(conn,null,null); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; return affectedRow; &#125; 密码修改实现 前端页面 JSP部分: 页面显示 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@include file=&quot;/jsp/common/head.jsp&quot; %&gt;&lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;location&quot;&gt; &lt;strong&gt;你现在所在的位置是:&lt;/strong&gt; &lt;span&gt;密码修改页面&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;providerAdd&quot;&gt; &lt;form id=&quot;userForm&quot; name=&quot;userForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/jsp/user.do&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;savepwd&quot;/&gt; &lt;!--div的class 为error是验证错误，ok是验证成功--&gt; &lt;div class=&quot;info&quot;&gt;$&#123;message&#125;&lt;/div&gt; &lt;div class=&quot;&quot;&gt; &lt;label for=&quot;oldPassword&quot;&gt;旧密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;oldpassword&quot; id=&quot;oldpassword&quot; value=&quot;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;newPassword&quot;&gt;新密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;newpassword&quot; id=&quot;newpassword&quot; value=&quot;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;newPassword&quot;&gt;确认新密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;rnewpassword&quot; id=&quot;rnewpassword&quot; value=&quot;&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;/font&gt; &lt;/div&gt; &lt;div class=&quot;providerAddBtn&quot;&gt; &lt;!--&lt;a href=&quot;#&quot;&gt;保存&lt;/a&gt;--&gt; &lt;input type=&quot;button&quot; name=&quot;save&quot; id=&quot;save&quot; value=&quot;保存&quot; class=&quot;input-button&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&lt;%@include file=&quot;/jsp/common/foot.jsp&quot; %&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;pageContext.request.contextPath &#125;/statics/js/pwdmodify.js&quot;&gt;&lt;/script&gt; 这是一个用 JSP（JavaServer Pages）编写的网页代码，用于修改密码。页面包括一个表单，用户可以在其中输入旧密码、新密码和确认新密码。表单使用POST方法提交到服务器，并使用“/jsp/user.do” URL。 页面包括一个消息区域，用于显示任何错误消息。页面还包括指向名为“pwdmodify.js”的 JavaScript 文件的链接。这个文件应该包含表单的客户端验证逻辑。 页面使用 JSP 表达式语言（EL）将动态内容插入到 HTML 中。例如，页面使用表达式 “${pageContext.request.contextPath}/statics/js/pwdmodify.js” 插入一个链接到 CSS 文件。“${pageContext.request.contextPath}” 表达式计算为 web 应用程序的上下文路径，用于构造 CSS 文件的完整 URL。 JavaScript 表单的客户端验证逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var oldpassword = null;var newpassword = null;var rnewpassword = null;var saveBtn = null;$(function()&#123; oldpassword = $(&quot;#oldpassword&quot;); newpassword = $(&quot;#newpassword&quot;); rnewpassword = $(&quot;#rnewpassword&quot;); saveBtn = $(&quot;#save&quot;); oldpassword.next().html(&quot;*&quot;); newpassword.next().html(&quot;*&quot;); rnewpassword.next().html(&quot;*&quot;); oldpassword.on(&quot;blur&quot;,function()&#123; $.ajax(&#123; type:&quot;GET&quot;, url:path+&quot;/jsp/user.do&quot;, data:&#123;method:&quot;pwdmodify&quot;,oldpassword:oldpassword.val()&#125;, dataType:&quot;json&quot;, success:function(data)&#123; if(data.result == &quot;true&quot;)&#123;//旧密码正确 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else if(data.result == &quot;false&quot;)&#123;//旧密码输入不正确 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 原密码输入不正确&quot;,false); &#125;else if(data.result == &quot;sessionerror&quot;)&#123;//当前用户session过期，请重新登录 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 当前用户session过期，请重新登录&quot;,false); &#125;else if(data.result == &quot;error&quot;)&#123;//旧密码输入为空 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 请输入旧密码&quot;,false); &#125; &#125;, error:function(data)&#123; //请求出错 validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 请求错误&quot;,false); &#125; &#125;); &#125;).on(&quot;focus&quot;,function()&#123; validateTip(oldpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入原密码&quot;,false); &#125;); newpassword.on(&quot;focus&quot;,function()&#123; validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 密码长度必须是大于6小于20&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(newpassword.val() != null &amp;&amp; newpassword.val().length &gt; 5 &amp;&amp; newpassword.val().length &lt; 20 )&#123; validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(newpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 密码输入不符合规范，请重新输入&quot;,false); &#125; &#125;); rnewpassword.on(&quot;focus&quot;,function()&#123; validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;#666666&quot;&#125;,&quot;* 请输入与上面一致的密码&quot;,false); &#125;).on(&quot;blur&quot;,function()&#123; if(rnewpassword.val() != null &amp;&amp; rnewpassword.val().length &gt; 5 &amp;&amp; rnewpassword.val().length &lt; 20 &amp;&amp; newpassword.val() == rnewpassword.val())&#123; validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;green&quot;&#125;,imgYes,true); &#125;else&#123; validateTip(rnewpassword.next(),&#123;&quot;color&quot;:&quot;red&quot;&#125;,imgNo + &quot; 两次密码输入不一致，请重新输入&quot;,false); &#125; &#125;); saveBtn.on(&quot;click&quot;,function()&#123; oldpassword.blur(); newpassword.blur(); rnewpassword.blur(); if( oldpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; newpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot; &amp;&amp; rnewpassword.attr(&quot;validateStatus&quot;) == &quot;true&quot;)&#123; if(confirm(&quot;确定要修改密码？&quot;))&#123; $(&quot;#userForm&quot;).submit(); &#125; &#125; &#125;);&#125;); 这是一个 JavaScript 代码段，它使用 jQuery 库为一个包含密码修改表单的网页添加了客户端验证逻辑。代码使用 AJAX 技术从服务器获取 JSON 格式的响应数据，以验证用户输入的旧密码是否正确，并在页面上显示相关提示信息。 代码中首先定义了四个变量，分别是旧密码、新密码、确认新密码和提交按钮的 jQuery 对象。然后使用 $() 函数将代码包装在一个回调函数中，确保代码在文档加载完成后才执行。回调函数内部做了以下工作： 通过选择器获取页面上的旧密码输入框、新密码输入框、确认新密码输入框和提交按钮，并将它们的 jQuery 对象赋值给前面定义的四个变量。 为旧密码输入框绑定 blur 事件处理函数，当输入框失去焦点时，使用 $.ajax() 函数向服务器发送 GET 请求，验证用户输入的旧密码是否正确，并根据服务器返回的响应数据显示相应的提示信息。在成功回调函数中，根据 data.result 的值判断旧密码是否正确，并通过 validateTip() 函数显示相应的提示信息。在失败回调函数中，显示请求出错的提示信息。 为旧密码输入框绑定 focus 事件处理函数，当输入框获得焦点时，显示输入提示信息。 为新密码输入框绑定 focus 和 blur 事件处理函数，当输入框获得焦点时，显示输入提示信息；当输入框失去焦点时，判断用户输入的新密码是否符合规范，如果符合则显示正确提示，否则显示错误提示。 为确认新密码输入框绑定 focus 和 blur 事件处理函数，当输入框获得焦点时，显示输入提示信息；当输入框失去焦点时，判断用户输入的确认新密码是否与新密码一致，如果一致则显示正确提示，否则显示错误提示。 为提交按钮绑定 click 事件处理函数，当按钮被点击时，先让旧密码、新密码和确认新密码输入框失去焦点，然后判断它们的验证状态是否都为 true，如果是，则显示确认修改密码的提示框，如果用户点击确定，则提交表单，将新密码保存到服务器上。 编写处理Servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class UserDo extends HttpServlet &#123; private UserService service; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getParameter(&quot;method&quot;); if(&quot;savepwd&quot;.equals(method))&#123; savePwd(req, resp); &#125; else if(&quot;pwdmodify&quot;.equals(method))&#123; pwdModify(req, resp); &#125; &#125; protected void savePwd(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //拿到USer Session , 用于得到用户id HttpSession session = req.getSession(); User user = (User) session.getAttribute(Constant.USER_SESSION); String newPwd = req.getParameter(&quot;newpassword&quot;); System.out.println(&quot;用户输入的：new password: &quot;+newPwd); System.out.println(&quot;Session password: &quot;+user.getUserPassword()+&quot;, id: &quot;+ user.getId()); Integer id = user.getId(); boolean flag; //method 值为 savepwd, 表示用户执行修改密码操作 if(newPwd != null)&#123; service = new UserServiceImpl(); flag = service.updateUser(id, &quot;userPassword&quot;, newPwd); //修改成功 if(flag)&#123; System.out.println(&quot;修改成功&quot;); req.setAttribute(&quot;message&quot;,&quot;密码修改成功， 请重新登录&quot;); // 移除Session session.removeAttribute(Constant.USER_SESSION); &#125; else &#123; System.out.println(&quot;密码修改失败&quot;); req.setAttribute(&quot;message&quot;,&quot;密码修改失败&quot;); &#125; &#125; else &#123; req.setAttribute(&quot;message&quot;,&quot;新密码格式错误&quot;); &#125; //转发到当前页面, 不用重定向而使用转发是为了传统参数（attribute) 通知前端密码修改结果（by attribute message） req.getRequestDispatcher(&quot;/jsp/pwdmodify.jsp&quot;).forward(req,resp); &#125; /* 由ajax发起的密码查询请求， 用户进行密码修改时触发 放回前端json， ajax用于比对旧密码正确性, */ protected void pwdModify(HttpServletRequest req, HttpServletResponse resp)&#123; HttpSession session = req.getSession(); Object user = session.getAttribute(Constant.USER_SESSION); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if(user != null)&#123; String password = ((User) user).getUserPassword(); String inputPwd = req.getParameter(&quot;oldpassword&quot;); if(inputPwd != null &amp;&amp; inputPwd.length() &gt; 0)&#123; //旧密码正确 if(inputPwd.equals(password))&#123; map.put(&quot;result&quot;,&quot;true&quot;); &#125; else &#123; //旧密码不正确 map.put(&quot;result&quot;,&quot;false&quot;); &#125; &#125; else &#123; //密码输入为空 map.put(&quot;result&quot;,&quot;error&quot;); &#125; &#125; else &#123; //session timeout map.put(&quot;result&quot;,&quot;sessionerror&quot;); &#125; //返回前端json数据 resp.setContentType(&quot;application/json&quot;); try &#123; PrintWriter writer = resp.getWriter(); writer.write(JSONArray.toJSONString(map)); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 这段代码是一个Java Web应用程序中的Servlet，用于处理用户密码修改操作。 在doGet()方法中，根据请求参数&quot;method&quot;的值进行不同的操作。如果&quot;method&quot;的值是&quot;savepwd&quot;，则调用savePwd()方法，保存新密码；如果&quot;method&quot;的值是&quot;pwdmodify&quot;，则调用pwdModify()方法，用于检查旧密码是否正确。 在savePwd()方法中，首先从Session中获取当前用户的信息，然后获取新密码，并使用UserService接口的实现类UserServiceImpl来更新用户密码。如果更新成功，将信息存储在请求属性中，并移除Session中的用户信息，最后将请求转发到密码修改页面。 在pwdModify()方法中，首先获取当前用户的信息，然后获取旧密码。如果旧密码不为空，则将输入的旧密码与Session中存储的旧密码进行比较。如果输入的旧密码与Session中的旧密码相同，则返回前端JSON数据，表示旧密码正确；否则返回JSON数据，表示旧密码不正确。 需要注意的是，在返回JSON数据之前，需要设置响应的Content-Type为&quot;application/json&quot;。 映射Servlet 12345678&lt;servlet&gt; &lt;servlet-name&gt;userDo&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.UserDo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;userDo&lt;/servlet-name&gt; &lt;url-pattern&gt;/jsp/user.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;","categories":[{"name":"Java web","slug":"Java-web","permalink":"https://trevoewu.github.io/categories/Java-web/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://trevoewu.github.io/tags/JavaWeb/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://trevoewu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"大学生就业指导课程心得体会","slug":"学习心得","date":"2023-05-11T10:36:45.000Z","updated":"2023-05-11T09:05:21.910Z","comments":true,"path":"2023/05/11/学习心得/","link":"","permalink":"https://trevoewu.github.io/2023/05/11/%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/","excerpt":"大学生就业指导课程是为了帮助大学生更好地了解职业发展、掌握求职技巧、提高职场竞争力而设计的一门课程。学习这门课程，可以让学生更好地了解自己、掌握自己的优势和劣势，规划自己的职业道路，提高就业竞争力。","text":"大学生就业指导课程是为了帮助大学生更好地了解职业发展、掌握求职技巧、提高职场竞争力而设计的一门课程。学习这门课程，可以让学生更好地了解自己、掌握自己的优势和劣势，规划自己的职业道路，提高就业竞争力。 自我认知非常重要。在课程中，我们学习了如何通过自我分析、职业测评等方式，了解自己的性格、兴趣、能力和价值观等，这对于选择适合自己的职业非常重要。因此，在学习课程时，我认为要重视自我认知，认真分析自己的优势和劣势，了解自己的职业目标和规划。 掌握求职技巧。在课程中，我们学习了如何制作简历、撰写求职信、面试技巧等，这些技巧对于我们成功找到一份工作非常重要。因此，在学习课程时，我认为要认真学习这些技巧，并在实践中不断提高。 学习职业规划。在课程中，我们学习了如何规划自己的职业道路，了解职业发展方向、职业发展阶段等。在我看来，这些知识对于大学生来说非常有价值，因为我们需要在职业生涯中不断发展自己，提高自己的职业素养和能力，才能更好地适应职业发展的要求。 积极参与课程活动。在课程中，我们参加了模拟面试、实习招聘会等活动，这些活动让我更好地了解了职业发展的现状和要求，也提高了我对职业发展的认识和信心。因此，我认为积极参与课程活动是非常重要的。 注重实践和经验积累。除了学习理论知识，我们还需要注重实践和经验积累。在课程中，我们可以通过实习、兼职、志愿活动等方式，积累实践经验，丰富自己的简历和求职经历。同时，在实践中也可以不断提高自己的职业素养和能力。 保持乐观心态和自信。在职业发展的过程中，我们难免会遇到挫折和困难，但是保持乐观心态和自信非常重要。在课程中，我们学习了如何应对挫折和压力，如何调整自己的心态和情绪。我认为，只有保持乐观心态和自信，才能充满信心地面对职业发展的挑战和机遇。 建立个人品牌。在现今竞争激烈的职场中，个人品牌的建立非常重要。在大学生就业指导课程中，我们学习了如何打造自己的个人品牌，包括简历的编写、面试技巧、自我介绍等。建立良好的个人品牌可以让我们在众多求职者中脱颖而出，增加求职的成功率。 不断学习和提升自己。职场是一个不断学习和成长的过程，我们需要不断学习和提升自己的能力和素养。在大学生就业指导课程中，我们学习了如何制定职业发展计划，如何选择职业发展方向，如何评估自己的职业发展进展等。通过不断学习和提升自己，我们可以更好地适应职场的变化和挑战，实现职业发展的跨越式提升。 大学生就业指导课程对于大学生职业发展非常重要，通过学习这门课程，我们可以更好地了解自己、掌握求职技巧、规划职业发展，提高职业竞争力。我认为，只有认真学习和实践，才能真正掌握这些知识和技能，为自己的职业生涯打下坚实的基础。","categories":[],"tags":[{"name":"水课论文","slug":"水课论文","permalink":"https://trevoewu.github.io/tags/%E6%B0%B4%E8%AF%BE%E8%AE%BA%E6%96%87/"}]},{"title":"Wireshark Lab: Ethernet and ARP","slug":"Wireshark-Lab-Ethernet-and-ARP","date":"2023-05-08T11:02:02.000Z","updated":"2023-05-08T13:26:30.036Z","comments":true,"path":"2023/05/08/Wireshark-Lab-Ethernet-and-ARP/","link":"","permalink":"https://trevoewu.github.io/2023/05/08/Wireshark-Lab-Ethernet-and-ARP/","excerpt":"","text":"官方英文文档：Wireshark_Intro_v6.01.pdf 以下内容为笔者翻译： Wireshark 实验: Ethernet and ARP v7.0 《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross “不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 © 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved 在本实验中，我们将研究以太网协议和 ARP 协议。在开始实验之前， 您可以查看课本的 6.4.1 节（链路层地址和 ARP）和 6.4.2（以太网）, 您也可以去看 RFC 826(ftp://ftp.rfc-editor.org/in-notes/std/std37.txt)了解关于 ARP 的协议详细信息,该协议可以根据 IP 地址获取远程主机的的物理地址。 捕获和分析以太网帧 让我们从捕获一组以太网帧开始研究。 请执行下列操作 : 首先，清除浏览器缓存。 在Firefox 下执行此操作，请选择 历史记录，然后选中清除历史记录。 然后启动 Wireshark 数据包嗅探器 打开以下 URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-ethereal-lab-file3.html 您的浏览器应显示相当冗长的美国权利法案。 接下来停止 Wireshark 数据包捕获，找到您向 gaia.cs.umass.edu 的 HTTP GET 消 息的数据包编号以及 gaia.cs.umass.edu 相应您的 HTTP 回应。您的抓包结果应 看起来向下面一样: 由于本实验是关于以太网和 ARP 的，我们对 IP 或更高层协议不感兴趣。 因此，让我们更改 Wireshark 的“捕获数据包列表”窗口，以便它仅显示有关 IP 以下协议的信息。 要让 Wireshark 执行此操作，请选择 Analyze-&gt; Enabled Protocols(分析-启用的协议)。 然后取消选中 IP 框(译者注:这里指的 IPV4 协议，下面有搜索)并选择确定。 您现在 Wireshark 窗口应该如下所示: 为了回答以下问题，您需要查看数据包详细信息和数据包内容窗口(Wireshark 中 的中间和下部显示窗口，译者注: 若您看到的不是如此-建议您重置布局(视图-重 置布局))。 选择包含 HTTP GET 消息的以太网帧。 (回想一下，HTTP GET 请求是被加上 TCP 头封装到 TCP 段进行传输,TCP 段加上 IP 头被封装到 IP 数据报进行传输,IP 数 据报又被加上以太网头封装成以太网帧进行传输;如果你发现这个封装有点令人困 惑，请重读文本中的第 1.5.2 节)。 在数据包详细信息窗口中展开以太网 II 信息。 请注意，以太网帧的内容(标题以及有效负载)显示在数据包内容窗口中 根据包含 HTTP GET 消息的以太网帧进行分析，如果有可能建议您使用标记的方式展现您的答案。 你的电脑 48 位的地址是多少 以太网帧中的 48 位目标地址是什么?这是 gaia.cs.umass.edu 的以太网地址 吗?(提示:答案是否定的)。那么它是什么?注意这一题可能会犯错，请 阅读 468-469(中文版 305-308 页)然后理解它 下一跳路由器的对应接口的MAC地址. 以太网帧上层协议 16 进制值是什么?这对应的上层协议是什么? 从以太帧的开始，一直到“GET”中的 ASCII“G”出现在以太网帧中為止，有多 少字节? G 的ascii码为0x47, 对应地址为0x0042, 故在这之前共有0x43字节, 即67Byte 接下来，根据包含 HTTP 响应消息的第一个字节的以太网帧的内容，回答以下问题 这个以太网帧中，以太网源地址的值是多少?这是你的计算机的地址，还是gaia.cs.umass.edu 的地址(提示:答案是否定的)。拥有这个以太网地址的设备是什么? ANS: 是最后一跳路由器网卡的MAC地址 以太网帧中的目的地址是什么?这是您的计算机的以太网地址吗? ANS: 是的 以太网帧上层协议 16 进制值是什么?这对应的上层协议是什么? ANS: 0x0800, IPv4 从以太帧的开始，一直到“OK”中的 ASCII“O”出现在以太网帧中为止，有多少字节? ANS: 0x4f Byte, 79Byte The Address Resolution Protocol 地址解析协议 在本节中，我们将观察 ARP 协议的作用。我们强烈建议您在继续实验之前重读课文 6.4.1 节 ARP Caching(ARP 缓存) 回想一下，ARP 协议通常在您的计算机上维护 IP 到以太网地址转换对的缓存.arp 命令(在 MSDOS 和 Linux / Unix 中)用于查看和操作此缓存的内容。由于 arp 命 令和 ARP 协议具有相同的名称，因此很容易混淆它们。但请记住，它们是不同的: arp 命令用于查看和操作 ARP 缓存内容，而 ARP 协议定义了发送和接收的消息的 格式和含义，并定义了对消息传输和接收所采取的操作。 我们来看看您计算机上 ARP 缓存的内容: MS-DOS:arp 命令位于 c:\\windows\\system32 中，因此在 MS-DOS 命令行中 输入“arp”或“c:\\windows\\system32\\arp”(没有引号) Linux/Unix/MacOS. 根据安装位置不同路径而不同，一般有/sbin/arp (linux) 和/usr/etc/arp (Unix) 没有参数的 Windows arp 命令将显示计算机上 ARP 缓存的内容。运行 ARP 命 令。 写下计算机 ARP 缓存的内容。每个列值的含义是什么? 123456789// mac/linux arp commend by tldr - Show the current ARP table: arp -a- Delete a specific entry: arp -d address- Create an entry in the ARP table: arp -s address mac_address IP地址, MAC地址 为了观察您的计算机发送和接收 ARP 消息，我们需要清除 ARP 缓存，否则您的计算机很可能在其缓存中找到所需的 IP-Ethernet 地址转换关系，因此不会发送 ARP 消息。 MS-DOS:MS-DOS arp -d 命令将清除 ARP 缓存。-d 标志指示删除操作， * 是表示删除所有表项的通配符。 Linux/Unix/MacOS: 清除 arp 缓存的 arp –d *需要 root 权限，如果您没有也没办法使用 Windows 系统进行实验，请下载作者的抓包结果。 所有在Linux系统下 arp -d $ip 命令只能清除一个IP地址的对应MAC地址缓存，当然可以使用组合命令操作，这也算是Linux的一个优点吧。 Observing ARP in action 抓取 ARP 消息 请进行以下操作: 清除你的 ARP 缓存，如上所述。 1sudo arp -a -d //clear arp cahce in mac os 接下来，确保浏览器的缓存是空的。 启动 Wireshark 捕捉封包 打开以下 URL，http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-lab-file3.html。你的浏览器应该再次显示相当长的美国权利法案 同样设置不显示 IP 和更高层协议，请选择 Analyze-&gt; Enabled Protocols(分析 -启用的协议)。 然后取消选中 IP 框(译者注:这里指的 IPV4 协议，下面有 搜索)并选择确定。 您现在 Wireshark 窗口应该如下所示: 图示是作者的抓包结果截图，您可以发现第 1，2，6 帧都包含 ARP 消息 Answer the following questions: (回答下列问题) 包含 ARP 请求消息的以太网帧中源和目标地址的十六进制值是什么? 以太网帧上层协议 16 进制值是什么? 下载 ARP 规范(ftp://ftp.rfc-editor.org/in-notes/std/std37.txt.),讨论请移步 (http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html) a) ARP 操作码字段开始从以太网帧的最开始有多少字节? 0x13Byte = 19Byte, 操作码：1为ARP请求，2为ARP应答，3为RARP请求，4为RARP应答。 b) 在进行 ARP 请求的以太网帧的 ARP 负载部分中，操作码字段的值是 多少? 操作码1为ARP请求 c) ARP 消息是否包含发送方的 IP 地址? 不包括. d) 在 ARP 请求中从哪里看出我们要查询相应 IP 的以太网地址? 图中蓝色部分, 可以看到要查询的IP(16进制), 转换为十进制为: 10.51.187.123 找到相应 ARP 请求的而发送 ARP 回复 1. a) ARP 操作码字段开始从以太网帧的最开始有多少字节? 2. b) 在进行 ARP 响应的以太网帧的 ARP 负载部分中，操作码字段的值是 多少? 2, 表示ARP响应 3. c) 在响应 ARP 中从哪里看出现早期 ARP 请求的答案? 响应ARP中的源MAC地址 包含 ARP 回复消息的以太网帧中的源地址和目标地址的十六进制值是多 少? 在作者抓包结果中，他有两台电脑，一台运行 wireshark 进行抓包，一台没 有，那么为什么运行 wireshark 那台电脑发送 ARP 请求得到了应答，另外一 台电脑的 ARP 请求没有得到应答?(没有相应第 6 帧的 ARP 的请求) 请求ARP的目标MAC地址48位全1, 是广播地址, 所以局域网设备都能收到, 而响应ARP是单播地址, 目标MAC为请求目标的MAC地址, 故只有发起对该IP请求对电脑能收到. Extra Credit 额外实验 EX-1. The arp command: arp 命令: 1arp -s InetAddr EtherAddr 这个命令允许你手动添加 arp 记录到缓存表中。它会把您输入的 IP 地址 (InetAddr)解析为物理地址(EtherAddr)，请问您输入正确 IP 地址但是物理地 址错误会发生什么。 成功写入了, 类型为permanent, 没有发生什么, 而且可以在ARP table中看到两条同一IP地址的不同MAC地址条目. EX-2. 在删除 ARP 缓存之前，请问它们默认的有效时间是多少，您可以通过不定 时的查看缓存内容得出结论或者查询相应的操作系统文档。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"}]},{"title":"Wireshark Lab 802.11","slug":"Wireshark-Lab-802-11","date":"2023-05-08T10:36:45.000Z","updated":"2023-05-08T11:01:19.094Z","comments":true,"path":"2023/05/08/Wireshark-Lab-802-11/","link":"","permalink":"https://trevoewu.github.io/2023/05/08/Wireshark-Lab-802-11/","excerpt":"","text":"Wireshark 实验: 802.11 《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross “不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 © 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved 在本实验中，我们将研究 802.11 无线协议。在开始本实验之前，建议您重新阅读课本的中第 7.3 节。因为我们将比课本深入研究 802.11 协议内容，因此您可能需要查看 Pablo Brenner (Breezecom Communications)写的《802.11 协议技术指南》ATechnical Tutorial on the 802.11Protocol 以及 Jim Geier 写的《了解 802.11 帧类型》Understanding 802.11 Frame Types 。当然，您还需要查阅 802.11 的圣经-它的标准书《ANSI / IEEE 标准 802.11,1999 版(R2003)》(ANSI/IEEE Std 802.11, 1999 Edition (R2003)。您可能会发现标准书第 36 页的表 1 在分析无线跟踪特别有用. 在除本次实验以外其它的 Wireshark 实验中，我们都是在有线以太网连接进行抓包(捕获帧)。在本实验中，因为 802.11 是无线链路层协议，我们将在“空中”捕获帧。不幸的是，带有 802.11 协议的无线网卡(NIC)设备驱动无法提供钩子将捕获/接收的 802.11 帧用于 Wireshark 实验分析。因此，在本实验中，您可能会使用作 者捕获的 802.11 帧(抓包结果)进行分析。如果您有能力自己捕获，欢迎您自己动手。如果您乐意自己跟踪，或许你可以买一个小的 USB 网卡 AirPcap 用以捕获 802.1 帧 Getting Started 开始实验 从 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 下载压缩包并且得到 Wireshark_802_11.pcap。本结果由团队的一个作者在家庭网络使用 AirPcap 以及运行 Wireshark 的计算机得到，结果其中包括 Linksys 802.11g 的组合接入点(路由器)，该接入点为两台有线 PC 和一台无线 PC 提供服务。作者幸运邻居也使用无线接入点。在此跟踪文件中，我们能看到在通道 6 上捕获的帧。由于我们需要分析主机和接入点不是使用通道 6 的唯一组合，我们也会看到其他例如邻居接入点使用通道6被作者收集到。跟踪文件中采用的无线主机活动包括: 跟踪开始时，主机已经与 30 Munroe St 接入点关联(associated)。 在时间 24.82 时刻，主机向 IP 地址 128.119.245.12 的服务器发送 HTTP 请 求，请求内容是 http://gaia.cs.umass.edu/wireshark-labs/alice.txt 。 在时间 32.82 时刻，主机向 IP 地址 128.119.240.19.的服务器发送 HTTP 请求，请求内容是 http://www.cs.umass.edu。 在时间 49.58 的时刻，主机断开了与 30 Munroe St 接入点的关联，并且尝试 连接到 linksys_ses_24086 接入点。该接入点不是开放的接入点，因此主机始终没有成功与该接入点关联成功。 在时间 63.0 时刻，主机放弃尝试关联 linksys_ses_24086 接入点，并且再次连接30 Munroe St 接入点关联。 下载作者的抓包结果后，使用 Wireshark 的 File 菜单打开该文件 Wireshark_802_11.pcap，您应该看到与图 1 显示相同的结果 Beacon Frames 信标帧 回想一下，802.11 接入点使用信标帧表示其存在。要回答下面的问题，您或许应该 展开 IEEE 802.11 帧并在 Wireshark 中间窗口看到它的字段详细信息。请尽量清晰 的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 发送最多信标帧的两个接入点的服务集标识符是多少(SSID)? inksys_ses_24086 接入点和 30 Munroe St.接入点的信标帧传输时间是多少?(提示:此时间间隔包含在信标帧本身之中。) 请以十六进制表示法找到 30 Munroe St 接入点的源 MAC 地址。回想课本中 图 7-13，并说明源地址，目的地址，基本服务集(BSS)的地址是什么。有 关 802.11 帧结构的详细讨论说明，请参阅 IEEE 802.11 标准文档(上文所 提)中的第 7 节。 30 Munroe St 接入点的信标帧目的地址十六进制表示是什么? 30 Munroe St 接入点的 BSS ID 地址是什么? 来自 30 Munroe St 接入点的信标帧宣告接入点可以支持四种数据速率和八种 额外的“扩展支持速率”。这些速率是多少? Data Transfer 数据传输 由于作者抓包开始时，主机已经与 AP 关联，因此在做下面 AP 关联/解除关联之 前，我们首先研究已经主机与关联 802.11 AP 的数据传输。回想一下，在作者抓包 结果中，在时间 24.82 的时刻，主机向 http://gaia.cs.umass.edu/wireshark- labs/alice.txt 发出 HTTP 请求。 gaia.cs.umass.edu 的 IP 地址是 128.119.245.12。然 后，在 32.82 时刻，主机向 http://www.cs.umass.edu 发出 HTTP 请求。 找到包含第一个 TCP SYN TCP 报文(下载 alice.txt 会话)的 802.11 帧。 802.11 帧中三个 MAC 地址字段分别是什么?此帧中那个 MAC 地址对应十 六进制的无线主机的 MAC 地址?那个对应接入点 MAC 地址，第一跳路由 器的 MAC 地址?发送此 TCP 报文的无线主机 IP 是什么?目的地 IP 地址是 什么?此目的地是否与主机地址，接入点地址，第一跳路由器地址或者某些 其他网络设备相对应，解释并且说明。 找到包含此 TCP 会话 SYN ACK 报文的 802.11 帧。该帧中三个 MAC 地址 字段是什么?那个 MAC 地址对应十六进制的无线主机的 MAC 地址?那个 对应接入点 MAC 地址，第一跳路由器的 MAC 地址?帧中的发送方 MAC 地址是否与发送此 TCP 报文的设备的 IP 地址相对应? Association/Disassociation 关联/解除关联 回想一下课本的第 7.3.1 节，主机在发送数据之前必须与接入点关联。802.11 中的关联使用 ASSOCIATE REQUEST 帧(从主机发送到 AP，帧类型 0 和子类型 0，参 见本文中的第 7.3.3 节)和 ASSOCIATE RESPONSE 帧(由 AP 发送给具有主机， 帧类型 0 和子类型 1，响应于接收到的 ASSOCIATE REQUEST)。有关 802.11 帧 中每个字段的详细说明，请参阅 http://gaia.cs.umass.edu/wireshark-labs/802.11- 1999.pdf 中 802.11 规范的第 34 页(第 7 节)。 在时间 49 的时刻，主机在跟踪中使用那两个动作(例如:发送帧)解除在 跟踪开始之前就已经连接的 30 Munroe St AP 的关联。(提示:一个是 IP 层 多宗，一个是 802.11 层动作)。在查看 802.11 规范之后，请找出抓包结果 中未显示一个动作帧。 在抓包结果中，找到主机发送给无线 AP 的 AUTHENICATION 帧，同时也 找无线 AP 的回复响应帧。在时间 49 时刻之后，无线主机向 linksys_ses_24086 AP(MAC 地址包括 Cisco_Li_f5:ba:bb)发送了多少 AUTHENTICATION 消息? 主机是否希望身份认证和关联 AP? 您是否在跟踪中看到来自 linksys_ses_24086 AP 回的 AUTHENTICATION? 现在让我们来分析当主机放弃尝试与 linksys_ses_24086 AP 关联并且现在尝 试与 30 Munroe St AP 关联发生什么。查找从主机发送到 AP 的 AUTHENICATION 帧，同时也找无线 AP 的回复响应帧。在什么时间有一 个主机到 30 Munroe St AP 的帧，在什么时间无线 AP 回主机该帧的回复。 (注意:您可以使用“ wlan.fc.subtype == 11and wlan.fc.type == 0 and wlan.addr == IntelCor_d1:b6:4f ”(不含引号)在此跟踪中仅显示无线主机的 AUTHENTICATION 帧) 从主机到 AP 的关联请求，以及相应的 AP 对主机关联请求的响应。在什么 时候有来自主机到 AP 关联请求，什么时候 AP 对主机关联请求响应。(注 意:你可以使用过滤表达式“wlan.fc.subtype &lt; 2 and wlan.fc.type == 0 and wlan.addr == IntelCor_d1:b6:4f”来仅显示 ASSOCIATE REQUEST 和 ASSOCIATE RESPONSE 帧。 主机和 AP 愿意使用什么传输速率?要回答此问题，您或许要查看 802.11 无 线管理帧的字段。 Other Frame types 其他帧类型 作者的抓包结果中含许多 PROBE REQUEST 和 PROBE RESPONSE 帧。 这些帧中的发送方，接收方和 BSS ID MAC 地址是什么? 这两种帧的目的是什么? (要回答最后一个问题，您需要深入研究本实验前面引用说明的 在线参考资料)。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"}]},{"title":"Wireshark Lab: ICMP","slug":"Wireshark-Lab-ICMP","date":"2023-05-05T02:48:32.000Z","updated":"2023-05-05T07:21:30.475Z","comments":true,"path":"2023/05/05/Wireshark-Lab-ICMP/","link":"","permalink":"https://trevoewu.github.io/2023/05/05/Wireshark-Lab-ICMP/","excerpt":"In this lab, we’ll explore several aspects of the ICMP protocol: 在本实验中，我们将探讨 ICMP 协议的几个方面:","text":"In this lab, we’ll explore several aspects of the ICMP protocol: 在本实验中，我们将探讨 ICMP 协议的几个方面: ICMP messages generating by the Ping program; Ping 程序生成的 ICMP 消息; ICMP messages generated by the Traceroute program; Traceroute 程序生成的 ICMP 消息; the format and contents of an ICMP message. ICMP 消息的格式和内容。 Before attacking this lab, you’re encouraged to review the ICMP material in section 5.6 of the text1. We present this lab in the context of the Microsoft Windows operating system. However, it is straightforward to translate the lab to a Unix or Linux environment. 在开始本实验之前，我们建议您查看课本的 5.6 节中的 ICMP 章节。此实验是在Windows 下完成的，如果您使用其他系统也不用担心，因为大体都相同。 ICMP and Ping ICMP 协议和 Ping 程序 Let’s begin our ICMP adventure by capturing the packets generated by the Ping program. You may recall that the Ping program is simple tool that allows anyone (for example, a network administrator) to verify if a host is live or not. The Ping program in the source host sends a packet to the target IP address; if the target is live, the Ping program in the target host responds by sending a packet back to the source host. As you might have guessed (given that this lab is about ICMP), both of these Ping packets are ICMP packets. 让我们通过捕获 Ping 程序生成的数据包开始我们的 ICMP 实验。 您可能还记得Ping 程序是一个简单的工具，允许任何人(例如:网络管理员)验证主机是否存在。 源主机中的 Ping 程序将数据包发送到目标 IP 地址; 如果目标是在线的，则目标主机中的 Ping 程序将会发送响应 Ping 数据包证明他在线，这两个 Ping 数据包都是 ICMP 数据包。 因此您可能猜出我们这个实验都是关于 ICMP 的实验了。 Do the following: 请按照以下动作做: Let’s begin this adventure by opening the Windows Command Prompt application (which can be found in your Accessories folder). 打开 windows 的命令提示符。 Start up the Wireshark packet sniffer, and begin Wireshark packet capture. 启动 Wireshark 数据包嗅探器，并开始 Wireshark 数据包捕获。 The ping command is in c:\\windows\\system32, so type either “ping –n 10 hostname” or “c:\\windows\\system32\\ping –n 10 hostname” in the MS-DOS command line (without quotation marks), where hostname is a host on another continent. If you’re outside of Asia, you may want to enter www.ust.hk for the Web server at Hong Kong University of Science and Technology. The argument “-n 10” indicates that 10 ping messages should be sent. Then run the Ping program by typing return. Ping 程序在 c:\\windows\\system32 目录中，所以您在命令提示符中输入“ping –n 10 hostname” 或 “c:\\windows\\system32\\ping –n 10 hostname”都是正确的 (注意命令是引号里的内容)。其中 hostname 是另一个大陆的主机名。如 您如果在非亚洲地区，建议您访问香港科技大学 www.ust.hk ， 参数-n 10 代表发送 10 个 Ping 消息，然后按下回车执行命令。 When the Ping program terminates, stop the packet capture in Wireshark. 当 Ping 程序终止时，停止在 Wireshark 中捕获数据包。 At the end of the experiment, your Command Prompt Window should look something like Figure 1. In this example, the source ping program is in Massachusetts and the destination Ping program is in Hong Kong. From this window we see that the source ping program sent 10 query packets and received 10 responses. Note also that for each response, the source calculates the round-trip time (RTT), which for the 10 packets is on average 375 msec. 在实验结束时，您的命令提示符窗口应如图 1 所示。在此示例中，源 ping 程序位 于马萨诸塞州，目标 Ping 程序位于香港。 从这个窗口我们看到源 ping 程序发送了10 个查询包并收到了 10 个响应。 另请注意，对于每个响应，源计算往返时间 (RTT)，对于 10 个数据包平均为 375 毫秒。 Figure 2 provides a screenshot of the Wireshark output, after “icmp” has been entered into the filter display window. Note that the packet listing shows 20 packets: the 10 Ping queries sent by the source and the 10 Ping responses received by the source. Also note that the source’s IP address is a private address (behind a NAT) of the form 192.168/12; the destination’s IP address is that of the Web server at HKUST. Now let’s zoom in on the first packet (sent by the client); in the figure below, the packet contents area provides information about this packet. We see that the IP datagram within this packet has protocol number 01, which is the protocol number for ICMP. This means that the payload of the IP datagram is an ICMP packet. 如图 2，在将“icmp”输入过滤器显示窗口后 Wireshark 输出的屏幕截图。 请注意， 数据包列表显示 20 个数据包:源发送的 10 个 Ping 查询和源接收的 10 个 Ping 响 应。 另请注意，源的 IP 地址是 192.168 / 12 格式的私有地址(通过 NAT 协议连接 互联网); 目的地的 IP 地址是香港科技大学网络服务器的 IP 地址。 现在让我们点 击显示第一个由客户端发送的数据包; 在图中的下方，数据包内容区域提供有关此 数据包的信息。 我们看到该数据包中的 IP 数据报具有协议号 01，这是 ICMP 的协 议号。 这意味着 IP 数据报的有效载荷是 ICMP 数据包 图 2 在 Wireshark 中过滤 ICMP 协议并且选中某个 ICMP 消息 Figure 3 focuses on the same ICMP but has expanded the ICMP protocol information in the packet contents window. Observe that this ICMP packet is of Type 8 and Code 0 - a so-called ICMP “echo request” packet. (See Figure 5.19 of text.) Also note that this ICMP packet contains a checksum, an identifier, and a sequence number. 图 3 同样使用相同的 ICMP 过滤器，展开可以看到该 ICMP 包的详情信息。 观察到 该 ICMP 数据包是类型 8 和代码 0 ——所谓的 ICMP“回应请求”数据包。 (请参见 书本的图 5.19。)此外，此 ICMP 数据包包含校验和，标识符和序列号 What to Hand In: 回答问题 You should hand in a screen shot of the Command Prompt window similar to Figure 1 above. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该 简单可读。 1ping -c 10 bing.com // [-c count] You should answer the following questions: 请回答以下问题: What is the IP address of your host? What is the IP address of the destination host? 您的主机的 IP 地址是多少? 目标主机的 IP 地址是多少? Why is it that an ICMP packet does not have source and destination port numbers? 为什么 ICMP 数据包没有源端口号和目的端口号? 大多数TCP/IP实现直接在操作系统中支持ping服务器, 即该服务器不是一个进程. ICMP（Internet Control Message Protocol）数据包没有源端口号和目的端口号，因为ICMP不像TCP（传输控制协议）或UDP（用户数据报协议）那样是传输层协议。相反，ICMP是一种直接在IP（Internet Protocol）层之上运行的网络层协议。 TCP和UDP使用源和目的地端口号来在同一设备上运行的不同应用程序之间进行多路复用和解复用数据。然而，ICMP不用于传输应用程序数据，而是用于在网络设备之间传递错误消息和网络状态信息。因此，ICMP消息并不是针对设备上的特定端口而言的，而是针对设备本身的。 ICMP消息包含类型、代码和校验和等字段，这些字段用于指示消息的目的和内容。这些字段允许网络设备适当地解释和响应ICMP消息。例如，当从一个设备发送ping命令到另一个设备时，ping数据包包含一个ICMP回显请求消息，这促使接收设备向发送方发送一个ICMP回显回复消息。ICMP数据包中缺少源和目的端口号是由于这些信息对协议的运行不必要。 Examine one of the ping request packets sent by your host. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields? 查看任意的请求 ICMP 数据包， ICMP 类型和代码是什么? 该 ICMP 数据包还有哪些其他字段? 校验和，序列号和标识符字段有多少字节? Type: 8 code: 0 回显请求。还包括检验和(2 Byte), id(2 Byte), sequence number(2 Byte) Examine the corresponding ping reply packet. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields? 查看任意的响应 ICMP 数据包， ICMP 类型和代码是什么? 该 ICMP 数据包 还有哪些其他字段? 校验和，序列号和标识符字段有多少字节? Type: 0(Echo reply) Code : 0 还包括检验和(2 Byte), id(2 Byte), sequence number**(2 Byte**) ICMP and Traceroute ICMP 协议和 Traceroute 命令 Let’s now continue our ICMP adventure by capturing the packets generated by the Traceroute program. You may recall that the Traceroute program can be used to figure out the path a packet takes from source to destination. Traceroute is discussed in Section 1.4 and in Section 5.6 of the text. 现在让我们通过捕获 Traceroute 程序生成的数据包继续我们的 ICMP 实验。 您可能 还记得 Traceroute 程序可用于确定数据包从源到目的地的路径。 Traceroute 命令可 以在课本中的 1.4 节和 5.6 节中找到 Traceroute is implemented in different ways in Unix/Linux/MacOS and in Windows. In Unix/Linux, the source sends a series of UDP packets to the target destination using an unlikely destination port number; in Windows, the source sends a series of ICMP packets to the target destination. For both operating systems, the program sends the first packet with TTL=1, the second packet with TTL=2, and so on. Recall that a router will decrement a packet’s TTL value as the packet passes through the router. When a packet arrives at a router with TTL=1, the router sends an ICMP error packet back to the source. In the following, we’ll use the native Windows tracert program. A shareware version of a much nice Windows Traceroute program is pingplotter (www.pingplotter.com). We’ll use pingplotter in our Wireshark IP lab since it provides additional functionality that we’ll need there. 每个系统有不同路由跟踪实现办法，在 Unix / Linux 中，路由跟踪 traceroute 使用 发送不可到达(无使用的)端口的 UDP 包来实现，在 Windows 中，路由跟踪 tracert 仅使用 ICMP 数据包来实现，但是对于他们来说，都是发送 TTL 增加的数据 包，例如 TTL=1,TTL=2，回想下，每经过一个路由器，TTL 就会减一，当 TTL=1 的包达到路由器，该路由器会将该包丢弃，并且发送 ICMP 错误给请求的机器，在 本次实验，我们使用 window 自带的 tracert。有一个跨平台 Windows Traceroute 程序的是 pingplotter(www.pingplotter.com)(收费但可以试用)。 我们将在 Wireshark IP 实验室中使用 pingplotter，因为它提供了我们在那里需要的其他功能。 Do the following4: 请执行以下步骤 Let’s begin by opening the Windows Command Prompt application (which can be found in your Accessories folder). 打开 windows 的命令提示符。 Start up the Wireshark packet sniffer, and begin Wireshark packet capture. 启动 Wireshark 数据包嗅探器，并开始 Wireshark 数据包捕获。 The tracert command is in c:\\windows\\system32, so type either “tracert hostname” or “c:\\windows\\system32\\tracert hostname” in the MS-DOS command line (without quotation marks), where hostname is a host on another continent. (Note that on a Windows machine, the command is “tracert” and not “traceroute”.) If you’re outside of Europe, you may want to enter www.inria.fr for the Web server at INRIA, a computer science research institute in France. Then run the Traceroute program by typing return. tracert 程序在 c:\\windows\\system32 目录中，所以您在命令提示符中输入 “tracert hostname” 或 “c:\\windows\\system32\\ tracert hostname”都是正确的(注 意命令是引号里的内容)。其中 hostname 是另一个大陆的主机名。如您如 果在非欧洲地区，建议您访问法国 INRIA(计算机科学研究所) www.inria.fr 然后按下回车执行命令。 When the Traceroute program terminates, stop packet capture in Wireshark. 当 Traceroute 程序终止时，停止在 Wireshark 中捕获数据包。 At the end of the experiment, your Command Prompt Window should look something like Figure 4. In this figure, the client Traceroute program is in Massachusetts and the target destination is in France. From this figure we see that for each TTL value, the source program sends three probe packets. Traceroute displays the RTTs for each of the probe packets, as well as the IP address (and possibly the name) of the router that returned the ICMP TTL-exceeded message. 在实验结束时，您的命令提示符窗口应如图 4 所示。在此图中，客户端 Traceroute程序主机位于马萨诸塞州，目标主机位于法国。 从该图中我们看到，对于每个 TTL 值，源程序发送三个探测包。 Traceroute 显示每个探测包的 RTT，以及返回 ICMP TTL 超出消息的路由器的 IP 地址(可能还有名称)。 Figure 5 displays the Wireshark window for an ICMP packet returned by a router. Note that this ICMP error packet contains many more fields than the Ping ICMP messages. 图 5 显示了路由器返回的 ICMP 数据包的 Wireshark 窗口。 请注意，此 ICMP 错误数据包包含的字段比 Ping ICMP 消息多得多。 If you are unable to run Wireshark live on a computer, you can download the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip and extract the file ICMP-ethereal-trace-2. The traces in this zip file were collected by Wireshark running on one of the author’s computers, while performing the steps indicated in the Wireshark lab. Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the ICMP-ethereal-trace-2 trace file. You can then use this trace file to answer the questions below. 同样如果您无法抓包，建议您下载作者的抓包结果 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 解压并且使用 Wireshark 打开 ICMP-ethereal-trace-2 进行分析。 What to Hand In: 回答问题 For this part of the lab, you should hand in a screen shot of the Command Prompt window. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读 Answer the following questions: 请回答以下问题: What is the IP address of your host? What is the IP address of the target destination host? 您的主机的 IP 地址是多少? 目标目标主机的 IP 地址是多少? If ICMP sent UDP packets instead (as in Unix/Linux), would the IP protocol number still be 01 for the probe packets? If not, what would it be? 如果 ICMP 发送了 UDP 数据包(如在 Unix / Linux 中)，那么探测数据包的 IP 协议号仍然是 01 吗? 如果没有，它会是什么? Examine the ICMP echo packet in your screenshot. Is this different from the ICMP ping query packets in the first half of this lab? If yes, how so? 检查屏幕截图中的 ICMP 响应数据包。 这与本实验的前半部分中的 ICMP ping 查询数据包不同吗? 如果不同，请解释为什么? 该ICMP Message Type:11 Code: 0 , 路由器告诉源主机你的分组由于TTL减为0被我丢掉了(Time-to-live exceeded), 这是Ping和treaceroute程序的工作原理不同导致的, Ping程序发送请求回显报文, 目标主机收到后回复(回显回答), 而traceroute程序通过发送TTL从1递增的UPD数据报来获得路由信息. Examine the ICMP error packet in your screenshot. It has more fields than the ICMP echo packet. What is included in those fields? 检查屏幕截图中的 ICMP 错误数据包。 它具有比 ICMP 响应数据包更多的字段。 这个数据包含哪些内容? 多了IP头部, IP头部包含了被丢弃的IP数据报的头部字段 Examine the last three ICMP packets received by the source host. How are these packets different from the ICMP error packets? Why are they different? 检查源主机收到的最后三个 ICMP 数据包。 这些数据包与 ICMP 错误数据包有何不同? 他们为什么不同? 找不到…最后都没有收到, 但我还是说几句. 这些同为ICMP数据包, 但TYPE和Code字段的字不同, Type:3 Code:3 目标主机告诉源主机目标端口不可达, 这是因为treaceroute程序发送了不可达的端口 Within the tracert measurements, is there a link whose delay is significantly longer than others? Refer to the screenshot in Figure 4, is there a link whose delay is significantly longer than others? On the basis of the router names, can you guess the location of the two routers on the end of this link? 在 tracert 跟踪测量中，是否有一个连接的延迟比其他连接长得多? 请参阅 图 4 中的屏幕截图，是否有连接的延迟明显长于其他连接? 根据路由器名 称，您能猜出这个连接末端的两个路由器的位置吗? 可以发现TTL为6和为10时, 延迟变化很大, 通过best trace程序发现, 这两个路由器的位置分别是中国北京和德国，黑森州，法兰克福， Extra Credit 额外问题 For one of the programming assignments you created a UDP client ping program. This ping program, unlike the standard ping program, sends UDP probe packets rather than ICMP probe packets. Use the client program to send a UDP packet with an unusual destination port number to some live host. At the same time, use Wireshark to capture any response from the target host. Provide a Wireshark screenshot for the response as well as an analysis of the response. 对于一个编程任务，您可能创建了一个 UDP 客户端 ping 程序。 与标准 ping 程序 不同，此 ping 程序发送 UDP 探测包而不是 ICMP 探测包。 使用客户端程序将具有 异常目标端口号的 UDP 数据包发送到某个活动主机。 同时，使用 Wireshark 捕获 目标主机的任何响应。 提供响应的 Wireshark 屏幕截图以及响应分析。","categories":[{"name":"学习","slug":"学习","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"},{"name":"lab","slug":"lab","permalink":"https://trevoewu.github.io/tags/lab/"}]},{"title":"Wireshark Lab: DNS","slug":"Wireshark-Lab-DNS","date":"2023-04-21T13:05:21.000Z","updated":"2023-04-21T13:18:17.607Z","comments":true,"path":"2023/04/21/Wireshark-Lab-DNS/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/Wireshark-Lab-DNS/","excerpt":"","text":"官方英文文档：Wireshark_Intro_v6.01.pdf 以下内容为笔者翻译： Wireshark 实验: DNS v6.01 《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross “不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 © 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved 如书中第2.5节所述，域名系统(DNS)将主机名转换为IP地址，在互联网基础架构中发挥关键作用。在本实验中，我们将仔细查看DNS在客户端的细节。回想一下，客户端在DNS中的角色相对简单——客户端向其本地DNS服务器发送请求，并接收一个响应。如书中的图2.21和2.22所示，由于DNS分层服务器之间相互通信，可以递归地或迭代地解析客户端的DNS查询请求，而大多数操作是不可见的。然而，从DNS客户端的角度来看，协议非常简 ——将查询指向为本地DNS服务器，并从该服务器接收到响应。 在开始本实验之前，您可能需要阅读书中的第2.5节来了解DNS。另外，您可能需要查看关于本地DNS服务器，DNS缓存，DNS记录和消息，以及DNS记录中的TYPE字段的资料。 1. nslookup 在本实验中，我们将大量使用nslookup工具，这个工具在现在的大多数Linux/Unix和Microsoft平台中都有。要在Linux/Unix中运行nslookup，您只需在命令行中键入nslookup命令即可。要在Windows中运行，请打开命令提示符并在命令行上运行nslookup。 在这是最基本的操作，nslookup工具允许主机查询任何指定的DNS服务器的DNS记录。DNS服务器可以是根DNS服务器，顶级域DNS服务器，权威DNS服务器或中间DNS服务器（有关这些术语的定义，请参阅书本）。要完成此任务，nslookup将DNS查询发送到指定的DNS服务器，然后接收DNS回复，并显示结果。 上面的屏幕截图显示了三个不同nslookup命令的结果（显示在Windows命令提示符中）。在此示例中，客户端主机位于布鲁克林理工大学校园，默认本地DNS服务器为dns-prime.poly.edu。运行nslookup时，如果没有指定DNS服务器，则nslookup会将查询发送到默认的DNS服务器（在这种情况下为dnsprime.poly.edu）。来看第一个命令： nslookup www.mit.edu 说这个命令是说，请告诉我主机 www.mit.edu 的IP地址。如屏幕截图所示，此命令的响应提供两条信息：（1）提供响应的DNS服务器的名称和IP地址；（2）响应本身，即 www.mit.edu 的主机名和IP地址。虽然响应来自理工大学的本地DNS服务器，但本地DNS服务器很可能会迭代地联系其他几个DNS服务器来获得结果，如书中第2.4节所述。 现在来看第二个命令： nslookup -type=NS mit.edu 在这个例子中，我们添加了选项&quot;-type=NS&quot;和域名&quot;mit.edu&quot;。这将使得nslookup将NS记录发送到默认的本地DNS服务器。换句话说，“请给我发送mit.edu的权威DNS的主机名” （当不使用-type选项时，nslookup使用默认值，即查询A类记录。）上述屏幕截图中，首先显示了提供响应的DNS服务器（这是默认本地DNS服务器）以及三个MIT域名服务器。这些服务器中的每一个确实都是麻省理工学院校园主机的权威DNS服务器。然而，nslookup也表明该响应是非权威的，这意味着这个响应来自某个服务器的缓存，而不是来自权威MIT DNS服务器。最后，响应结果还显示了麻省理工学院权威DNS服务器的IP地址。 （即使nslookup生成的NS类型查询没有明确要求IP地址，本地DNS服务器依然”免费“返回了这些信息，然后被nslookup显示出来。） 最后来看第三个命令： nslookup www.aiit.or.kr bitsy.mit.edu 在这个例子中，我们希望将查询请求发送到DNS服务器 bitsy.mit.edu ，而不是默认的DNS服务器（dns-prime.poly.edu）。因此，查询和响应事务直接发生在我们的主机和 bitsy.mit.edu 之间。在这个例子中，DNS服务器 bitsy.mit.edu 提供主机 www.aiit.or.kr 的IP地址，它是高级信息技术研究所（韩国）的Web服务器。 现在我们了解了一些示例，您现在可能想知道nslookup命令的一般语法。语法是： nslookup -option1 -option2 host-to-find dns-server 一般来说，nslookup可以不添加选项，或者添加一两个甚至更多选项。正如我们在上面的示例中看到的，dns-server也是可选的；如果这项没有提供，查询将发送到默认的本地DNS服务器。 现在我们提供了总览了nslookup，现在是你自己驾驭它的时候了。执行以下操作（并记下结果）： 运行nslookup以获取一个亚洲的Web服务器的IP地址。该服务器的IP地址是什么？ 查询了哈尔滨理工大学的ip地址, 通过得到的信息可以知道, 该服务器的IP地址为202.118.201.1 可以发现这是一个来自DNS服务器182.254.116.116的应答, 搜索发现, 这是腾讯的备用域名服务器. 继续查询权威名字服务器, 得到的是非权威的, 这是因为腾讯的DNS服务器不知道哈尔滨理工大学的权威名字服务器, 只能向根DNS→TLD(顶级域DNS)(.cn)→edu.cnDNS→hrbust.edu.cnDNS, 迭代查询获得 如果我们之间对这个DNS服务器发起DNS查询: 可以发现, 这样一条来自权威名字服务器的应答. 运行nslookup来确定一个欧洲的大学的权威DNS服务器。 查询了苏黎世联邦理工大学的权威DNS 可以发现权威名字服务器为: ns1.ethz.ch 运行nslookup，使用问题2中一个已获得的DNS服务器，来查询Yahoo!邮箱的邮件服务器。它的IP地址是什么？ 查不到好吧…人家是大学的权威DNS, 没有雅虎的邮件服务器地址, 只维护了大学的IP地址查询, 不当然公共DNS的指责, 即不去迭代的查询(个人猜测) 又到了问聪明的chatGPT的时间了: 使用腾讯的公共DNS服务器我们可以得到Yahoo的邮件服务器地址. 同时为发现查询www.mail.yahoo.com和mail.yahoo.com的结果不同 查询chatGPT得到以下回复: 2. ipconfig ipconfig（对于Windows）和ifconfig（对于Linux / Unix）是主机中最实用的程序，尤其是用于调试网络问题时。这里我们只讨论ipconfig，尽管Linux / Unix的ifconfig与其非常相似。 ipconfig可用于显示您当前的TCP/IP信息，包括您的地址，DNS服务器地址，适配器类型等。例如，您只需进入命令提示符，输入 ipconfig /all ipconfig对于管理主机中存储的DNS信息也非常有用。在第2.5节中，我们了解到主机可以缓存最近获得的DNS记录。要查看这些缓存记录，在 C:\\&gt; 提示符后输入以下命令： ipconfig /displaydns 每个条目显示剩余的生存时间（TTL）（秒）。要清除缓存，请输入 ipconfig /flushdns 清除了所有条目并从hosts文件重新加载条目。 3. 使用Wireshark追踪DNS 现在，我们熟悉nslookup和ipconfig，我们准备好了一些正经的事情。首先让我们捕获一些由常规上网活动生成的DNS数据包。 使用ipconfig清空主机中的DNS缓存。 打开浏览器并清空浏览器缓存。 （若使用Internet Explorer，转到工具菜单并选择Internet选项；然后在常规选项卡中选择删除文件。） 打开Wireshark，然后在过滤器中输入“ip.addr==your_IP_address”，您可以先使用ipconfig获取你的IP地址。此过滤器将删除既从你主机不发出也不发往你主机的所有数据包。 在Wireshark中启动数据包捕获。 使用浏览器访问网页： http://www.ietf.org 停止数据包捕获。 如果您无法在你的网络连接上运行Wireshark，则可以下载一个捕获了数据包的文件，这个文件是本书作者在自己计算机上 按照上述步骤捕获的（原文注：Download the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip and extract the file dnsethereal-trace-1. The traces in this zip file were collected by Wireshark running on one of the author’s computers, while performing the steps indicated in the Wireshark lab. Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the dns-ethereal-trace-1 trace file. ）。回答下列问题。您应该在解答中尽可能展示你使用了哪些你捕获到的数据包，并注释出来（原文注：What do we mean by “annotate”? If you hand in a paper copy, please highlight where in the printout you’ve found the answer and add some text (preferably with a colored pen) noting what you found in what you ‘ve highlight. If you hand in an electronic copy, it would be great if you could also highlight and annotate. ）。若要打印数据包，请使用文件-&gt;打印，只勾选仅选中分组，和概要行，并选中你所需要用于解答问题的数据包。 找到DNS查询和响应消息。它们是否通过UDP或TCP发送？ 通过UDP发送 DNS查询消息的目标端口是什么？ DNS响应消息的源端口是什么？ 目标端口通过上一问的图片可以得到为: 53, 响应DNS到源端口也是53 DNS查询消息发送到哪个IP地址？使用ipconfig来确定本地DNS服务器的IP地址。这两个IP地址是否相同？ 本地IP 地址: 10.51.172.226 DNS服务器IP地址: 182.254.116.116 相同 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ TYPE: A 不包含 检查DNS响应消息。提供了多少个&quot;answers&quot;？这些答案具体包含什么？ 三个answer 第一个answer: TYPE CNAME, 主机别名到规范主机名的对应关系 包含NAME(域名),TYPE, Class, TTL, Data. CNAME(规范主机名) 第二个answer: TYPE A, 域名和IP地址 得到了规范主机名的IP地址 第三个answer: 另一个规范主机名的IP地址 考虑从您主机发送的后续TCP SYN数据包。 SYN数据包的目的IP地址是否与DNS响应消息中提供的任何IP地址相对应？ 直接过滤ip.addr==104.16.44.99 结果如下: 可以发现我的主机向这个IP地址发起了TCP的链接请求 这个网页包含一些图片。在获取每个图片前，您的主机是否都发出了新的DNS查询？ 有一个对r3.o.lencr.org的DNS查询, 搜索发现这是一个恶意的软件发起的, 目的是给浏览器带来广告(服了…) 现在让我们玩玩nslookup（原文注：If you are unable to run Wireshark and capture a trace file, use the trace file dns-ethereal-trace-2 in the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip ）。 启动数据包捕获。 使用nslookup查询 www.mit.edu 停止数据包捕获。 我们从上面的屏幕截图看到，nslookup实际上发送了三个DNS查询，并收到了三个DNS响应。只考虑本次实验相关结果，在回答以下问题时，请忽略前两组查询/响应，因为nslookup的一些特殊性，这些查询通常不是由标准网络应用程序生成的。您应该专注于最后一个查询和响应消息。 DNS查询消息的目标端口是什么？ DNS响应消息的源端口是什么？ 查询: 响应: DNS查询消息的目标IP地址是什么？这是你的默认本地DNS服务器的IP地址吗？ 是的 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ TYPE A, 不包含 检查DNS响应消息。提供了多少个&quot;answers&quot;？这些答案包含什么？ 三个 包含主机别名到规范主机名的转化关系(TYPE:CNAME) 规范主机名到IP地址到转换关系 现在重复上一个实验，但换成以下命令： nslookup -type=NS mit.edu 回答下列问题： DNS查询消息发送到的IP地址是什么？这是您的默认本地DNS服务器的IP地址吗？ 是的 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ Type: NS 不包含 检查DNS响应消息。响应消息提供的MIT域名服务器是什么？此响应消息还提供了MIT域名服务器的IP地址吗？ ![image-20230416184356921](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416184356921.png) 现在重复上一个实验，但换成以下命令： nslookup www.aiit.or.kr bitsy.mit.edu 该DNS服务器已停用, 使用作者提供的抓包结果dns-ethereal-trace-4 回答下列问题： DNS查询消息发送到的IP地址是什么？这是您的默认本地DNS服务器的IP地址吗？如果不是，这个IP地址是什么？ 理论上不是, 因为已经指定了对应的DNS服务器,目标IP地址应该是DNS服务器名字bitsy.mit.edu 的IP地址 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ 第一个查询: TYPE: PTR 通过IP反向查询域名 第二个查询: TYPE A, 查询www.aiit.or.kr.poly.edu的IP地址, 目标IP地址是18.72.0.3 第三个查询: TYPE A, 查询www.aiit.or.kr的IP地址, 目标IP和上一个查询相同. 检查DNS响应消息。提供了多少个&quot;answers&quot;？这些答案包含什么？ 第一个响应: 提供了一个answer TYPE:PTR 回答里包含IP地址3.0.72.18对应的域名 第二个响应: TYPE: SOA(Start Of a zone of Authority) 响应结果为找不到: 第三个响应: ansewer为目标域名的IP地址.","categories":[{"name":"学习","slug":"学习","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"computer cetwork","slug":"computer-cetwork","permalink":"https://trevoewu.github.io/tags/computer-cetwork/"}]},{"title":"Wireshark Lab: TCP","slug":"Wireshark-Lab-TCP","date":"2023-04-21T12:48:28.000Z","updated":"2023-04-21T13:04:35.920Z","comments":true,"path":"2023/04/21/Wireshark-Lab-TCP/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/Wireshark-Lab-TCP/","excerpt":"","text":"在本实验中，我们将详细研究著名的 TCP 协议的行为。 我们将通过从您的电脑向 远程服务器传输一份 150KB 的文件(一份 Lewis Carrol 的“爱丽丝梦游仙境”文本)，并分析 TCP 传输内容的发送和接收过程来实现。 我们将研究 TCP 对序列和 确认号的使用，以提供可靠的数据传输;我们将看到 TCP 的拥塞控制算法 – 慢启 动和拥塞避免 – 在过程中，我们将看看 TCP 的接收器发送流量控制的机制。 我们还将简要地观察 TCP 连线的设置，我们还会研究计算机和服务器之间 TCP 连线的性能(吞吐量和往返时间)。 A first look at the captured trace 将文件传输到 gaia.cs.umass.edu 的客户端计算机使用的 IP 地址和 TCP 端口号是什么? gaia.cs.umass.edu 的 IP 地址是什么? 在哪个端口号上发送和接收此连接的 TCP 段? Client IP Addressee: 10.51.172.226 Client Port: 61084 gaia.cs.umass.edu IP Address: 128.119.245.12 客户端计算机将文件传输到 gaia.cs.umass.edu 所使用的 IP 地址和 TCP 端口号是多少? Client IP Addressee: 10.51.172.226 Client Port: 61084 用于在客户端计算机和 gaia.cs.umass.edu 之间启动 TCP 连接的 TCP SYN 段的序列号是什么? 标识为 SYN 段的段有什么功能? 如图, SYN序列号为4095602682, 标识为SYN的segment用于建立TCP链接 gaia.cs.umass.edu 发送给客户端计算机以回复 SYN 的 SYNACK 段的序列号是多少? 2017202044 SYNACK 段中的 Acknowledgment 栏位的值是多少? 为4095602683 观察到除了 SYN 标志位，ACK(Acknoledment)标志位也设 1，意思服务器接收到我约连按请求并且发 SYN-ACIK 确认，这是三次握手的第二步。 Gaia.cs.umass.edu 是如何确定此 Acknowledgment 的数值的? 收到的$$seqence number + Len.$$ 在将段标识 为 SYNACK 段的段在连线中有什么功能? 用于建立链接, 是三次握手的第二次, 表示同样连接请求 包含 HTTP POST 命令的 TCP 区段的序列号是多少? 如图为4095602683,TCP PSH 字段设为1表示要传送数据. HTTP的POST方法借助于TCP提供的服务实现, 在TCP中表现为TCP的PUSH字段设为1. 将包含 HTTP POST 的 TCP 区段视为 TCP 连接中的第一个区段。在这个 TCP 连线中前六个 TCP 区段的序列号是什么(包括包含 HTTP POST的段 每区段发送的时间是什么时候? 收到的每个区段的 ACK 是什么时候? 鉴于发送每个 TCP 区段的时间与收到确认的时间之间的差异，六个区段中每个区段的 RTT 值是多少? 如图是前6段的信息: 第一段Frame1: (发送第一个frame,在 Wireshark中序号为frame69,这是Wireshark捕获到的序号, 由于这是发送数据的第一帧记frame1) RTT: note: 这里的Timestamps是Wireshark提供的额外的功能, 和TCP段Optionfields 里的Timestamps不同. 通过Wireshark的分析, 可以知道IRTT(initial RTT 表示握手阶段的RTT)为0.39900200s ACK(对第一个frame)的ACK 发现这里的ACK number = 4095603435, 而seq1 的Next sequence = 4095603298, 而恰好, frame2的Next sequence = 4095603435 所以这是对frame1和frame2的累计确认, 这是因为TCP 采用了延迟到ACK(delay ACK), 具有所期望的序号报文到达时, 等待一段时间(通常为40ms), 如果下一个按序报文到达, 立即发送单个累计ACK, 以确认两个按序到达的报文段. 如果下一个按序报文段没有在这个时间内到达, 则发送一个ACK. 我们继续观察第一个报文段段Timestamps字段的值: 对比ACK1的Timestamps: 可以发现, 第一个报文段的TSval和ACK1的TimestampsTSerc相等, 进一步验证了之前的说法, 当接受到连续两个按序到达的报文时, 用于回复的ACK报文段段TSerc值的最早接受到的报文段的TSval, 这是为了对方更够更好的估算RTT. 时间戳选项主要的功能有两个： 用来计算往返时间RTT。 发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确计算出RTT。时间戳是一个单调增长的值，接收方只需要回显收到的内容，因此是不需要关注时间戳的单元是什么，也不需要连接双发的时钟同步。 PAWS:防止回绕的序号。 我们知道序列号只有32位，而每增加2^32个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽用来快速的传输数据。例如1Gb/s（TCP 的窗口经过窗口缩放可以最高到 1GB（2^30)）的速率发送报文段，则不到35秒钟数据字节的序列号就会重复。这样对TCP传输带来混乱的情况。这种情况之出现在高速链路上。而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。 参考文章TCP timestamp 选项那点事 接着我们观察ACK1报文的ACK分析(由wireshark提供), RTT为: 0.40989700s 第二段: 我们直接去找, 收到的第二个ACK报文 对比sequence的值, 可以发现, 这是对frame75的ACK, 也就是, 收到了对第七个报文段的ACK. 说明服务器已经收到了第七个报文段以及之前的报文. 我们还发现, 收到了一条[Windows Update]的报文, 这是TCP的流量控制, 用来告诉发送端根据这个值适当的调节发送速率. 根据wireshark的分析, 可以知道, RTT为0.409390000s 第三段: 第四段: 第五段: 第六段 收到每个 ACK 后，EstimatedRTT 值(参 见本节中的第 3.5.3 节，第 242 页)是什么? 假设第一个 EstimatedRTT 的 值等于第一个区段的测量 RTT，然后使用课本第 242 页的 EstimatedRTT 公式计算所有后续区段。 What is the length of each of the first six TCP segments?4 前六个 TCP 区段的长度是多少? What is the minimum amount of available buffer space advertised at the received for the entire trace? Does the lack of receiver buffer space ever throttle the sender? 对于整个跟踪包，收到的最小可用缓冲区空间量是多少? 缺少接收缓冲区空间是否会限制发送方传送 TCP 区段? 大部分Win都是很大的值, 太多包了, 懒得分析了.通过检查此跟踪，发送器永远不会因为接收器缓冲区空间不足而受到抑制。 Are there any retransmitted segments in the trace file? What did you check for (in the trace) in order to answer this question? 在跟踪文件中是否有重传的段? 为了回答这个问题，您检查了什么(在跟踪包中)? 观察序列号的变化: 可以发现, 序列号一直在增加, 所以没有重传的段. 通常到收到了不同的两个冗余ACK, 但这不一定意味着丢包, 这是因为分组乱序到达接受方导致的. How much data does the receiver typically acknowledge in an ACK? Can you identify cases where the receiver is ACKing every other received segment (see Table 3.2 on page 250 in the text). 接收方通常在 ACK 中确认多少数据? 您是否可以识别接收方每隔一个接收到的区段才发送确认的情况(参见本文第 250 页的表 3.2) 按照表3-2的说明, 接受方最多确认两个段, 但是观察了捕获结果, 发现很多事确认了超过两个段段情况, 比如在下图中, 收到的第一个ACK确认了69,70两段. 这是一次典型的delay ACK 但是观察收到的第二个ACK, 是对75段及之前段的累积确认, 这同时累积确认了71,72,73,74,75这五个段. 且观察后续的ACK, 除了在上一问题上出现的冗余ACK外, 无其他冗余ACK. 如果严格按照表3-2的叙述来看, 这只可能是部分ACK丢失导致的, 这就意味着网络拥塞, 但很明显这是不可能的, 因为没有发现任何一个重传的段, 网络很通畅. 让我们问问万能的chatGPT吧: 最多可以合并2~5个报文段哦!!! chatGPT yyds! What is the throughput (bytes transferred per unit time) for the TCP connection? Explain how you calculated this value.TCP 连接的吞吐量(每单位时间传输的节数)是多少? 解释你如何计算 这个值。 TCP吞吐量的计算在很大程度上取决于平均时间段的选择。作为一种常见的吞吐量计算，在本问题中，我们选择平均时间周期作为整个连接时间。然后，该TCP连接的平均吞吐量被计算为总数据量与总传输时间之间的比率。可以通过第一个TCP数据段的序列号和最后一个确认确认的序列号之间的差来计算发送的总数据量。 最后一个由我发给服务器的最后一个ACK的seqence numerber为4095755619, 我发送的报文段第一个序列号为: 4095602682 所以接受方的接受到的总数据为: 4095755619- 4095602682 = 152936Byte 总传输时间为5.455830-0.026477=2.50933秒。 因此，tcp连接的吞吐量计算为152936/2.50933=60946.945997537191202B/s = 60KB/s。 图由wireshark产生 4tcp-ethereal-trace-1 跟踪文件中的 TCP 区段都小于 1460 􏰁节。 这是因为收集跟踪 的计算机具有以太网卡，该最大 IP 数据包的长度限制为 1500 􏰁节(40 􏰁节的 TCP / IP 报头数据和 1460 􏰁节的 TCP 有效负载)。此 1500 􏰁节值是以太网允许 的标准最大长度。 如果您的跟踪包内容指示 TCP 区段长度大于 1500 􏰁节，并且 您的计算机使用以太网连接网路，则是 Wireshark 报告了错误的 TCP 区段长度;它 也可能是只显示一个大的 TCP 段而不是多个较小的区段，而您的计算机确实可能 正在发送多个较小的区段，这可以由收到的 ACK 区段来证明。 报告的区段长度的 这种不一致是由于以太网驱动程序和 Wireshark 软件之间的交互作用所导致。 如果 您有这种不一致情形，我们建议您使用本文所提供的跟踪文件来执行本实验的分析 内容。 TCP congestion control in action (TCP 拥塞控制) 现在让我们检查从客户端服务器的每单位时间发送的数据量。 而不是(繁琐 地!)从 Wireshark 窗口中的原始数据计算这些数值，我们将使用 Wireshark 的 TCP 图形工具 – 时序图(Stevens) - 来绘制数据。 使用时序图(Stevens)绘图工具查看从客户端发送到 gaia.cs.umass.edu 服务 器的区段的序列号与时间关系图。您能否确定 TCP 的慢启动阶段的开始和 结束位置，以及拥塞避免接管的位置? 评论测量数据与我们在文本中研究 的 TCP 的理想化行为的不同之处。 计算每轮发送的段数量分别为: 12,17,36,87 呈指数增长, 一只在慢启动阶段.","categories":[{"name":"学习","slug":"学习","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"}]},{"title":"MAC M1 安装Oracle数据库教程","slug":"MAC-M1-安装Oracle数据库教程","date":"2023-04-21T12:35:34.000Z","updated":"2023-04-21T12:37:22.477Z","comments":true,"path":"2023/04/21/MAC-M1-安装Oracle数据库教程/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/MAC-M1-%E5%AE%89%E8%A3%85Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%99%E7%A8%8B/","excerpt":"","text":"MAC M1 安装Oracle数据库教程 oracle目前还没有支持M1的版本, 本教程使用SSH来远程登录oracle服务器 在开始之前, 请确保你的mac安装了parallels Desktop, 并安装windows系统 如果你身边有windows环境, 比如你的室友的电脑, 你可以跳过1. 在windows电脑中安装Oracle Database Software. 安装OpenSSH服务 在window设置中 适用于 Windows Server 2019、Windows 10,11、Windows Server 2022 OpenSSH 是一款用于远程登录的连接工具，它使用 SSH 协议。 它会加密客户端与服务器之间的所有流量，从而遏止窃听、连接劫持和其他攻击。 OpenSSH 可用于将安装了 OpenSSH 客户端的 Window 10（版本 1809 及更高版本）或 Windows Server 2019 设备连接到那些安装了 OpenSSH 服务器的设备。 使用windous设置安装OpenSSSH 可以使用 Windows Server 2019 和 Windows 10 设备上的 Windows 设置安装这两个 OpenSSH 组件。 若要安装 OpenSSH 组件： 打开“设置”，选择“应用”&gt;“应用和功能”，然后选择“可选功能” 。 扫描列表，查看是否已安装 OpenSSH。 如果未安装，请在页面顶部选择“添加功能”，然后： 查找“OpenSSH 客户端”，再单击“安装” 查找“OpenSSH 服务器”，再单击“安装” 设置完成后，回到“应用”&gt;“应用和功能”和“可选功能”，你应会看到已列出 OpenSSH 。 安装 OpenSSH 服务器将创建并启用一个名为 OpenSSH-Server-In-TCP 的防火墙规则。 这允许端口 22 上的入站 SSH 流量。 如果未启用此规则且未打开此端口，那么连接将被拒绝或重置。 使用PowerShell安装OpenSSH 若要使用 PowerShell 安装 OpenSSH，请先以管理员身份运行 PowerShell。 为了确保 OpenSSH 可用，请运行以下 cmdlet： 1Get-WindowsCapability -Online | Where-Object Name -like &#x27;OpenSSH*&#x27; 如果两者均尚未安装，则此操作应返回以下输出： 12345Name : OpenSSH.Client~~~~0.0.1.0State : NotPresentName : OpenSSH.Server~~~~0.0.1.0State : NotPresent 然后，根据需要安装服务器或客户端组件： 12345# Install the OpenSSH ClientAdd-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0# Install the OpenSSH ServerAdd-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 这两者应该都会返回以下输出： 123Path :Online : TrueRestartNeeded : False 启动并配置 OpenSSH 服务器 若要启动并配置 OpenSSH 服务器来开启使用，请以管理员身份打开 PowerShell，然后运行以下命令来启动 sshd service： 12345678910111213# Start the sshd serviceStart-Service sshd# OPTIONAL but recommended:Set-Service -Name sshd -StartupType &#x27;Automatic&#x27;# Confirm the Firewall rule is configured. It should be created automatically by setup. Run the following to verifyif (!(Get-NetFirewallRule -Name &quot;OpenSSH-Server-In-TCP&quot; -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) &#123; Write-Output &quot;Firewall Rule &#x27;OpenSSH-Server-In-TCP&#x27; does not exist, creating it...&quot; New-NetFirewallRule -Name &#x27;OpenSSH-Server-In-TCP&#x27; -DisplayName &#x27;OpenSSH Server (sshd)&#x27; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22&#125; else &#123; Write-Output &quot;Firewall rule &#x27;OpenSSH-Server-In-TCP&#x27; has been created and exists.&quot;&#125; 连接到 OpenSSH 服务器 mac自带SSH服务, 所以安装后，可以使用MAC连接到 OpenSSH 服务器, 在终端中运行一下命令: 12ssh username@ipadress #username是安装了Oracle的windows电脑的用户名 #ipaddress是该电脑的ip地址 可以通过在windows的PowerShell中运行以下命令来查看ip地址: 1ipconfig 安装要求输入密码, 注意是微软用户的密码, 不是电脑的开机密码 连接后，你将看到 Windows 命令行界面提示符： 1domain\\username@SERVERNAME C:\\Users\\username&gt; 用户登录Oracle数据库 c成功链接后, 在终端输入: 1sqlplus / as sysdba 按照提示输入用户名: 1sys as sysdba 并按照提示输入口令, 这个口令是在你安装Orecle软件的过程中设置的. 产生一下输出则链接成功 123连接到: Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 使用ctrl+c退出sql服务, 输入exit退出ssh链接 用Navicat远程登陆Oracle数据库 打开Navicat, 左上角选择, 之后选择Oracle. 链接名请随意填写, 主机位置填入localhost, 端口默认为1521 服务名默认为ORCL, 如果你在安装Oracle中没有更改, 则保持不变, 我的改为了ORACLE 角色选择SYSDBA,用户名为sys, 密码就是之前提到的口令. 点击SSH选项 主机填入windows主机的IP地址, 端口默认22, 用户名是windows账户的用户名, 密码是该账户的密码 点击链接测试, 成功链接后点击保存即可.","categories":[{"name":"mac使用指南","slug":"mac使用指南","permalink":"https://trevoewu.github.io/categories/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"mac使用指南","slug":"mac使用指南","permalink":"https://trevoewu.github.io/tags/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"name":"oracle","slug":"oracle","permalink":"https://trevoewu.github.io/tags/oracle/"},{"name":"教程","slug":"教程","permalink":"https://trevoewu.github.io/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"计算机系统漫游","slug":"计算机系统漫游","date":"2023-04-21T12:31:56.000Z","updated":"2023-04-21T12:33:26.396Z","comments":true,"path":"2023/04/21/计算机系统漫游/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","excerpt":"","text":"信息就是位(bit)加上下文(context) 我们学习一门新的语言, 往往是从Hello world开始的, 我想没有一个程序员不喜欢这句话, 就像一个刚出生的婴儿, 对着这个陌生的世界微笑一样. 这次对计算机系统的学习就从一个hello world程序的生命周期开始. 从他被我们键入编辑器, 到在系统运行, 打印hello world最后interminates. 12345#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 我们的hello world程序生命的开始是源程序(source progam)或者源文件(source file), 以后缀 .c 结尾, 它是由一系列的0,1代码构成, 我们把每一位叫做bit. 每八个bit组成一个块, 我们称之为一个字节byte. 它是计算机处理信息的最小单位. 每一个byte对应着一个字符. 大多数计算机系统都采用ASCII标准来表示字符, 每一个ASCII码的值都对应着一个唯一的字符. 我们可以在linux或者like-unix系统的终端中键入man ascii来查看对应关系 我们把像hello.c这样用ASCII码表示的文件叫做文本文件(text files), 而其他形式的文件叫做二进制文件(binary files) 在计算机中, 所以的信息都是都是一连串的由0和1组成, 而唯一区分这些信息就是上下文. 在不同上下文中, 相同的一段比特序列可能表示一个整数, 浮点数, 或者一条指令. 程序被编译器翻译成不同的格式 计算机只认识二进制序列, helloworld这样的程序是不能被计算机理解的. 为了让计算机正确的执行我们的指令, 我们必须把它翻译成以二进制表示的形式, 我们把这样由二进制表示的语言叫做机器语言. 这些指令最后被打包成名叫可执行程序的形式, 存储为磁盘中的二进制文件. 在unix系统中, 这个由源文件翻译为可执行文件的过程是由一个叫编译器的程序完成. 整个边缘过程分为4个阶段, 分别是预编译处理, 编译, 汇编, 链接. 预编译阶段修改由#为开始的语句, 比如这段hello.c程序中的#include&lt;stdio.h&gt;, 预编译阶段会在目标路径中找到对应的stdio.h文件, 并直接插入到程序中, 有点内容复制粘贴到过程. ​ 这个stdio.h文件中主要包括函数声明, 宏定义, 以及结构体定义, 这个阶段会生成以.i为后缀的文本文件. ​ 默认情况下，预处理器的输出会被导入到标准输出流（也就是显示器），可以利用-o选项把它导入到某个输出文件, 在shell中键入gcc -E hello.c -o hello.i来输出到hello.i文件中 12345678extern int __vsnprintf_chk (char * restrict, size_t, int, size_t, const char * restrict, va_list);# 400 &quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h&quot; 2 3 4# 2 &quot;hello.c&quot; 2int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 产生的代码很长很长, 大概有500行,这里只截取最后一部分. 可以发现, 即使是想helloworld这样极端简单的程序, 编译之后也会比源文件大很多. 编译阶段把预编译产生的以.i结尾的文件翻译成以汇编语言表示的文本文件, 汇编是一种很有用的低一级的语言, 在不同的编译器编译不同的高级语言中, 它往往作为编译阶段的输出语言. 我们可以在shell中键入gcc -S hello.c生产汇编程序hello.s : 1234567891011121314151617181920_main: ; @main .cfi_startproc; %bb.0: sub sp, sp, #32 ; =32 stp x29, x30, [sp, #16] ; 16-byte Folded Spill add x29, sp, #16 ; =16 .cfi_def_cfa w29, 16 .cfi_offset w30, -8 .cfi_offset w29, -16 mov w8, #0 str w8, [sp, #8] ; 4-byte Folded Spill stur wzr, [x29, #-4] adrp x0, l_.str@PAGE add x0, x0, l_.str@PAGEOFF bl _printf ldr w0, [sp, #8] ; 4-byte Folded Reload ldp x29, x30, [sp, #16] ; 16-byte Folded Reload add sp, sp, #32 ; =32 ret 汇编阶段 在汇编阶段编译器会把上一阶段用ASCII表示的文本文件hello.s转化为机器语言表示的指令, 并打包生成叫做可重定位的二进制文件文件, 存储在hello.o的文件中, 如果我们打开这个文件, 文本编辑器会按照ASCII表示成对应的字符, 所以我们将会看到一堆乱码. 链接阶段 注意到我们的helloworld程序调用了一个名为printf的函数, 这个函数是C标准库函数的一部分,由编译起提供. 这个函数保持在一个单独的预编译的目标文件中, 叫做printf.o它必须和我们的hello.o合并, 这个工作由链接器完成, 生成和以直接运行可执行文件hello. 现在, 我们的源程序以及被翻译成了可执行文件, 并存储来磁盘中. 我们可以在shell中键入./hello来运行我们的程序.","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"computer system","slug":"computer-system","permalink":"https://trevoewu.github.io/tags/computer-system/"}]},{"title":"纪念拥有了自己的博客","slug":"纪念拥有了自己的博客","date":"2023-04-21T12:28:51.000Z","updated":"2023-04-21T12:30:45.584Z","comments":true,"path":"2023/04/21/纪念拥有了自己的博客/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/%E7%BA%AA%E5%BF%B5%E6%8B%A5%E6%9C%89%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"当一个由你亲手塑造的东西第一次呈现在你面前的时候, 那种兴奋感以及成就感是难以比拟的.","text":"当一个由你亲手塑造的东西第一次呈现在你面前的时候, 那种兴奋感以及成就感是难以比拟的. 比如当我第一次用自己的废旧的电脑组装成一台显示器, 当看到显示器作为switch副屏被点亮的时候. 比如自己照着教程给路由器刷插件来破解校园网, 看见Wi-Fi信号出现, 设备连接后, 绕过认证连接上互联网的时候. 那时候, 我好高兴好高兴, 我很想分享我的成果, 告诉宿舍的每一个人让他们连我的Wi-Fi, 从此实现Wi-Fi自由. 平时沉默不语的我在这时候犹豫了. 我只能强迫自己去做一些别的事来抑制这份心情. 而用于自己的博客带来的悸动是更胜过这两件事的. 我很开心当我告诉我的两位异性朋友时, 虽然她们对此并不了解, 仅仅是看见她们好奇和称赞我就好开心. 第一次听到博客这个词是在初二的时候, 老师给我们发了一份调查问卷, 其中一个问题便是有没有自己的博客, 那时候我还不知道博客是什么, 便以为是微博, 于是填上了是. 想必那时候拿到数据的人会不会惊讶于一个初二学生会拥有自己的博客呢. 上大学后, 靠搜索学习也让我遇见了很多优秀的博客, 有着精致的页面, 充满个人特色的UI, 以及那些学习和生活的记录, 每次翻阅, 我都觉得他们好优秀. 好像成为他们那样优秀的人.","categories":[{"name":"日常","slug":"日常","permalink":"https://trevoewu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"talk","slug":"talk","permalink":"https://trevoewu.github.io/tags/talk/"}]},{"title":"hexo插入图片问题","slug":"hexo插入图片问题","date":"2023-04-21T03:46:44.000Z","updated":"2023-04-21T04:47:56.326Z","comments":true,"path":"2023/04/21/hexo插入图片问题/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/","excerpt":"昨天刚搭建完博客, 发现直接写markdown, hexo 生成后图片全部都没法显示了, 毕竟图片都在本地, 以绝对路径的方式存储的, markdown的路径的hexo的路径不匹配.","text":"昨天刚搭建完博客, 发现直接写markdown, hexo 生成后图片全部都没法显示了, 毕竟图片都在本地, 以绝对路径的方式存储的, markdown的路径的hexo的路径不匹配. 以前搭博客的时候这个图片问题就老是困扰着我, 我用typora编写的文章转到html之后, 我还得把图片也引到项目目录来, 然后在一个个的该路径. 体验可以说是很差了, 这也导致哪怕写完文章, 我也懒得发布了, 太麻烦. 这次用hexo搭建也遇到了同样的问题, 按照老方法, 我能想到的就只有把图片全部拉过来了, 我直接把全部图片mv到了public目录的imag目录下, 部署到github上的时候, 由于图片太多了, 进度条老是卡住, 我只好放弃了. 我直接ctl+c, hexo clean,hexo s.这时候我还不知道hexo clean意味这什么, 只是看教程大家都是这样做的, 结果, 结果hexo把我pubilc目录下的文件全部删了…, 我的图片, 也全没了. 今天发现一个绝好的解决方案, 将Typora和hexo完美结合起来. 第一步 修改hexo的站点配置文件_config.yml 首先安装插件: 1npm install hexo-renderer-marked 在_config.yml搜索post_asset_folder改为true 如下: 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 修改之后会开启 Hexo 的文章资源文件管理功能。Hexo 将会在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹，并在执行hexo g的时候连同图片以前复制到public目录下(网站的根目录).于是我们便可以将文章所引用的相关资源放到这个同名文件夹下，然后通过相对路径引用。例如，你把一个 example.jpg 图片放在了这个同名文件夹中，使用相对路径的常规 markdown 语法 ![](example/example.jpg)即可访问 。 也就是这样 但是呢, 执行hexo g生成的时候, hexo会把sourec目录下的_posts文件的转化为成html, 并保存在pubilc对应日期的路径中, 可以看到, 此时index中的图片路径和markdown的图片路径是冲突的. 123456typora的路径使用: ![](./example/example.jpg)这样页面上的img路径就会是:/你的文章标题/example/example.jpg正确的图片地址: /example/example.jpg 这是因为hexo g把文件夹里面图片复制过来了, 但并没有复制整个图片的文件夹. 所以我只需要拿到当前博客的路径，直接加上图片名字就行. 第二步, 编写路径替换脚本 在全局js文件 themes\\next\\source\\js\\next-boot.js中，编写img 路径替换脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 脚本提供者//http://songpengpeng.comvar images = document.getElementsByTagName(&quot;img&quot;);var loHref = window.location.hreflet baseHref = loHref.substring(0,loHref.lastIndexOf(&quot;/&quot;)+1)for (let i = 0; i &lt;images.length; i++) &#123; let executeNum = 0; let src = images[i][&#x27;src&#x27;] let img = new Image(); img.src = src img.onload= ()=&gt; &#123; &#125; img.onerror= ()=&gt; &#123; executeNum ++ ; handAMark(src) if(executeNum&gt;3)&#123; return; &#125; let fileName = src.substring(src.lastIndexOf(&quot;/&quot;)+1); images[i].src= baseHref+fileName &#125;&#125;function handAMark(src)&#123; var as = document.getElementsByClassName(&quot;fancybox&quot;); for (let i = 0; i &lt;as.length; i++) &#123; let executeNum = 0; let href = as[i][&#x27;href&#x27;] if(href==src)&#123; let img = new Image(); img.src = src img.onload= ()=&gt; &#123; &#125; img.onerror= ()=&gt; &#123; executeNum ++ ; if(executeNum&gt;3)&#123; return; &#125; let fileName = src.substring(src.lastIndexOf(&quot;/&quot;)+1); as[i].href= baseHref+fileName &#125; &#125; &#125;&#125; 这样, 使用hexo g生成的时候, 就会自动将图片的路径替换. 第三步, 搭配typora才是最佳 但是还是不够方便啊, 我们得先把图片放到文章的资源文件夹中. Typora对插图片的支持非常好, 可以在复制图片的同时, 把物品保存在对应的文件夹中 打开Typora, ⌘+,进入系统偏好设置, 点击image选项卡, 修改为以下格式: 这样当插入图片的时候, 会自动把图片放到当前目录的markdown相名的文件夹中, 恰好, Hexo 在我们每一次通过 hexo new &lt;title&gt; 命令创建新文章时自动创建一个同名文件夹. 完美! 这样, 我们在Typora上写文章, 完全不用担心插入图片问题, 而且文章的图片也会有序的存放, 方面日后的管理. 现在我们只需要hexo n 'title'然后在Typora上写文章, 就可以直接推到博客了, 照片也可以正常显示. 你看, 我写完这篇文章的时候, hexo已经完美的生成网页了. 这太棒了, 不是吗?","categories":[],"tags":[{"name":"日常","slug":"日常","permalink":"https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"使用hexo重新搭建博客","slug":"使用hexo重新搭建博客","date":"2023-04-20T16:52:00.000Z","updated":"2023-04-20T16:58:45.077Z","comments":true,"path":"2023/04/21/使用hexo重新搭建博客/","link":"","permalink":"https://trevoewu.github.io/2023/04/21/%E4%BD%BF%E7%94%A8hexo%E9%87%8D%E6%96%B0%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"之前的博客是学web的时候手搓的, 导致后期管理困难, 每次发布文章我甚至得手写HTML. 后来发现大家都是用hexo搭建博客, 我也尝试了一下. 我真的好喜欢自己之前博客的风格Peekaboo的部落格 现在就先用next主题吧, 这个主题虽然不怎么好看, 但是帮助文档太友好了, 感谢感谢.","categories":[],"tags":[{"name":"Talk","slug":"Talk","permalink":"https://trevoewu.github.io/tags/Talk/"}]},{"title":"Wireshark lab HTTP","slug":"Wireshark-lab-HTTP","date":"2023-04-20T15:01:49.000Z","updated":"2023-05-15T13:16:02.833Z","comments":true,"path":"2023/04/20/Wireshark-lab-HTTP/","link":"","permalink":"https://trevoewu.github.io/2023/04/20/Wireshark-lab-HTTP/","excerpt":"","text":"Wireshark实验 - HTTP 官方英文文档：[Wireshark_HTTP_v7.0](Wireshark_HTTP_v7.0) 以下内容为笔者翻译： 《计算机网络：自顶向下方法（第6版）》补充材料，J.F. Kurose and K.W. Ross “不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 © 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved 在介Wireshark实验-入门里，我们已经初步使用了Wireshark包嗅探器，我们现在可以操作Wireshark来查看网络协议。在这个实验中，我们会探索HTTP协议的几个方面：基本的GET/response交互，HTTP消息格式，检索大型HTML文件，检索具有嵌入对象的HTML文件，HTTP认证和安全性。在开始这些实验之前，您可能想查看书中第2.2节。 1.基本HTTP GET/response交互 我们开始探索HTTP，方法是下载一个非常简单的HTML文件 非常短，并且不包含嵌入的对象。执行以下操作： 启动您的浏览器。 启动Wireshark数据包嗅探器，如Wireshark实验-入门所述（还没开始数据包捕获）。在display-filter-specification窗口中输入“http”（只是字母，不含引号标记），这样就在稍后的分组列表窗口中只捕获HTTP消息。（我们只对HTTP协议感兴趣，不想看到其他所有的混乱的数据包）。 稍等一会儿（我们将会明白为什么不久），然后开始Wireshark数据包捕获。 在浏览器中输入以下内容 http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html 您的浏览器应显示非常简单的单行HTML文件。 停止Wireshark数据包捕获。 你的Wireshark窗口应该类似于图1所示的窗口。如果你无法连接网络并运行Wireshark，您可以根据后面的步骤下载已捕获的数据包： 下载zip文件 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 解压缩文件 http-ethereal-trace-1。这个zip文件中的数据是由本书作者之一使用Wireshark在作者电脑上收集的，并且是按照Wireshark实验中的步骤做的。 如果你下载了数据文件，你可以将其加载到Wireshark中，并使用文件菜单选择打开并查看数据，然后选择http-ethereal-trace-1文件。 结果显示应与图1类似。（在不同的操作系统上，或不同的Wireshark版本上，Wireshark的界面会不同）。 图1：Wireshark显示 http://gaia.cs.umass.edu/wireshark-labs/HTTPwireshark-file1.html 已被您的浏览器打开 图1中的示例在分组列表窗口中显示了两个被捕获的HTTP消息：GET消息（从您的浏览器发送到gaia.cs.umass.edu 的web服务器）和从服务器到浏览器的响应消息。分组内容窗口显示所选消息的详细信息（在这种情况下为HTTP OK消息，其在分组列表窗口中高亮显示）。回想一下，因为HTTP消息被装载在TCP报文段内，该报文段是在IP分组封装吗，进而在以太网帧，和帧中封装，所以界面中显示了帧，以太网，IP，TCP分组信息以及HTTP报文信息。我们想最小化非HTTP数据的显示（我们这里只对HTTP感兴趣，这些其他协议将在以后的实验中研究），所以确保帧，以太网，IP和TCP行的信息被隐藏，注意左边有一个加号或一个向右的三角形（这意味着有信息被隐藏），而HTTP行具有减号或向下三角形（表示显示有关HTTP消息的所有信息）。 （注意：您应该忽略与favicon.ico相关的任何HTTP GET和response。 如果你看到一个关于这个文件的引用，这是你的浏览器自动询问服务器是否有一个图标文件应显示在浏览器的URL旁边。 我们会忽略这个引起麻烦的引用。） 通过查看HTTP GET和响应消息中的信息，回答以下问题。 在回答以下问题时，您应该打印出GET和响应消息（请参阅Wireshark-入门实验以获取信息），并指出您在消息中的哪个具体位置找到了回答以下问题的信息。 当您上交作业时，请注明输出，显示您在哪些地方表示了您的答案（例如，对于我们的课程，我们要求学生用笔标记纸质副本，或用彩色字体在电子副本的中注释文本）。 您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？ HTTP/1.1 ![image-20230416143533797](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416143533797.png) 您的浏览器会从接服务器接受哪种语言（如果有的话）？ ![image-20230416144437584](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416144437584.png) 您的计算机的IP地址是什么？ gaia.cs.umass.edu服务器地址呢？ ![image-20230416143642203](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416143642203.png) 服务器返回到浏览器的状态代码是什么？ ![image-20230416144507009](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416144507009.png) 服务器上HTML文件的最近一次修改是什么时候？ ![image-20230416144603595](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416144603595.png) 服务器返回多少字节的内容到您的浏览器？ ![image-20230416144632313](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416144632313.png) 通过检查数据包内容窗口中的原始数据，你是否看到有协议头在数据包列表窗口中未显示？ 如果是，请举一个例子。 没有 在您对上述问题5的回答中，您可能会惊讶地发现您刚才检索的文档在下载文档之前最近一次修改是一分钟前。 那是因为（对于这个特定文件），gaia.cs.umass.edu服务器将文件的最后修改时间设置为当前时间，并且每分钟执行一次。 因此，如果您在两次访问之间等待一分钟，则该文件看起来已被修改，因此您的浏览器将下载文档的“新”副本。 2.HTTP条件Get/response交互 回顾书的第2.2.5节，大多数Web浏览器使用对象缓存，从而在检索HTTP对象时执行条件GET。执行以下步骤之前，请确保浏览器的缓存为空。（要在Firefox下执行此操作，请选择“工具” - &gt; “清除最近历史记录”，然后检查缓存框，对于Internet Explorer，选择“工具” - &gt;“Internet选项” - &gt;“删除文件”；这些操作将从浏览器缓存中删除缓存文件。 现在按下列步骤操作： 启动您的浏览器，并确保您的浏览器的缓存被清除，如上所述。 启动Wireshark数据包嗅探器。 在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html 您的浏览器应显示一个非常简单的五行HTML文件。 再次快速地将相同的URL输入到浏览器中（或者只需在浏览器中点击刷新按钮）。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只捕获HTTP消息，并在数据包列表窗口中显示。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-2数据包跟踪来回答以下问题；请参见上文注释。） 回答下列问题： 检查第一个从您浏览器到服务器的HTTP GET请求的内容。您在HTTP GET中看到了“IF-MODIFIED-SINCE”行吗？ 没有 检查服务器响应的内容。服务器是否显式返回文件的内容？ 你是怎么知道的？ 是的,![image-20230416150206500](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416150206500.png) 现在，检查第二个HTTP GET请求的内容。 您在HTTP GET中看到了“IF-MODIFIED-SINCE:”行吗？ 如果是，“IF-MODIFIED-SINCE:”头后面包含哪些信息？ 看见了. 日期 ![image-20230416151334645](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416151334645.png) 针对第二个HTTP GET，从服务器响应的HTTP状态码和短语是什么？服务器是否明确地返回文件的内容？请解释。 ![image-20230416150249214](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416150249214.png) 3.检索长文件 在我们到目前为止的例子中，检索的文档是简短的HTML文件。 接下来我们来看看当我们下载一个长的HTML文件时会发生什么。 按以下步骤操作： 启动您的浏览器，并确保您的浏览器缓存被清除，如上所述。 启动Wireshark数据包嗅探器 在您的浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html 您的浏览器应显示相当冗长的美国权利法案。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-3数据包跟踪来回答以下问题；请参见上文注释。） 在分组列表窗口中，您应该看到您的HTTP GET消息，然后是对您的HTTP GET请求的多个分组的TCP响应。这个多分组响应值得进行一点解释。回顾第2.2节（见文中的图2.9），HTTP响应消息由状态行组成，后跟标题行，后跟一个空行，后跟实体主体。在我们的HTTP GET这种情况下，响应中的实体主体是整个请求的HTML文件。在我们的例子中，HTML文件相当长，4500字节太大，一个TCP数据包不能容纳。因此，单个HTTP响应消息由TCP分成几个部分，每个部分包含在单独的TCP报文段中（参见书中的图1.24）。在Wireshark的最新版本中，Wireshark将每个TCP报文段指定为独立的数据包，并且单个HTTP响应在多个TCP数据包之间分段的事实由Wireshark显示的Info列中的“重组PDU的TCP段”指示。 Wireshark的早期版本使用“继续”短语表示HTTP消息的整个内容被多个TCP段打断。我们在这里强调，HTTP中没有“继续”消息！ 回答下列问题： 您的浏览器发送多少HTTP GET请求消息？哪个数据包包含了美国权利法案的消息？ ![image-20230416151626850](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416151626850.png) 两个, 第一个 哪个数据包包含响应HTTP GET请求的状态码和短语？ ![image-20230416151652019](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416151652019.png) 第二个 响应中的状态码和短语是什么？ 200 OK 需要多少包含数据的TCP段来执行单个HTTP响应和权利法案文本？ 4个TCP段 ![image-20230416151853132](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416151853132.png) 4.具有嵌入对象的HTML文档 现在我们已经看到Wireshark如何显示捕获的大型HTML文件的数据包流量，我们可以看看当浏览器使用嵌入的对象下载文件时，会发生什么，即包含其他对象的文件（在下面的例子中是图像文件） 的服务器。 执行以下操作： 启动您的浏览器。 启动Wireshark数据包嗅探器。 在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html 您的浏览器应显示包含两个图像的短HTML文件。这两个图像在基本HTML文件中被引用。也就是说，图像本身不包含在HTML文件中；相反，图像的URL包含在已下载的HTML文件中。如书中所述，您的浏览器将不得不从指定的网站中检索这些图标。我们的出版社的图标是从 www.aw-bc.com 网站检索的。而我们第5版（我们最喜欢的封面之一）的封面图像存储在manic.cs.umass.edu服务器。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-4数据包跟踪来回答以下问题；请参见上文注释。） 回答下列问题： 您的浏览器发送了几个HTTP GET请求消息？ 这些GET请求发送到哪个IP地址？ 三个 ![image-20230416152201783](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416152201783.png) 浏览器从两个网站串行还是并行下载了两张图片？请说明。 猜测为串行, 因为这两个GET请求发送有时间差 ![image-20230416152416694](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416152416694.png) 5.HTTP认证 最后，我们尝试访问受密码保护的网站，并检查网站的HTTP消息交换的序列。URL http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html 是受密码保护的。用户名是“wireshark-students”（不包含引号），密码是“network”（再次不包含引号）。所以让我们访问这个“安全的”受密码保护的网站。执行以下操作： 请确保浏览器的缓存被清除，如上所述，然后关闭你的浏览器，再然后启动浏览器 启动Wireshark数据包嗅探器。 在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html 在弹出框中键入所请求的用户名和密码。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-5数据包跟踪来回答以下问题；请参见上文注释。） 现在来看看Wireshark输出。 您可能需要首先阅读HTTP身份验证相关信息，方法是在 http://frontier.userland.com/stories/storyReader$2159 上查看“HTTP Access Authentication Framework ”上的易读材料。 回答下列问题： 对于您的浏览器的初始HTTP GET消息，服务器响应（状态码和短语）是什么响应？ ![image-20230416152712931](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416152712931.png) 未授权 当您的浏览器第二次发送HTTP GET消息时，HTTP GET消息中包含哪些新字段？ ![image-20230416152814670](/Users/trevorwu/Library/Application Support/typora-user-images/image-20230416152814670.png) 一个Credentials: 的字段 您输入的用户名（wireshark-students）和密码（network）按照客户端HTTP GET消息中请求头的“Authorization: Basic ”的字符串（d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=）编码。虽然您的用户名和密码可能加密，但它们只是以一种称为Base64格式的格式进行编码。用户名和密码并没有加密！要确认这些，请访问 http://www.motobit.com/util/base64-decoder-encoder.asp 并输入base64编码的字符串d2lyZXNoYXJrLXN0dWRlbnRz 并进行解码。瞧！您已从Base64编码转换为ASCII编码，因此应该看到您的用户名！要查看密码，请输入字符串Om5ldHdvcms=的剩余部分，然后按解码。因为任何人都可以下载像Wireshark这样的工具，而且可以通过网络适配器嗅探数据包（不仅仅是自己的），任何人都可以从Base64转换为ASCII（你刚刚就这么做了！），所以你应该很清楚，WWW网站上的简单密码并不安全，除非采取其他措施。 wireshark自带解码… 不要害怕！ 正如我们将在第8章中看到的，有一些方法可以使WWW访问更加安全。然而，我们显然需要一些超出基本HTTP认证框架的知识！","categories":[],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"}]},{"title":"Wireshark Lab: IP v7.0","slug":"Wireshark-Lab-IP-v7-0","date":"2023-04-20T10:22:06.000Z","updated":"2023-04-21T03:44:49.965Z","comments":true,"path":"2023/04/20/Wireshark-Lab-IP-v7-0/","link":"","permalink":"https://trevoewu.github.io/2023/04/20/Wireshark-Lab-IP-v7-0/","excerpt":"Select the first ICMP Echo Request message sent by your computer, and expand the Internet Protocol part of the packet in the packet details window.(选择您的计算机发送的第一个 ICMP Echo Request 消息，并在数据包详细信息窗口中展开数据包的 Internet 协议部分) 不知道为什么, 我的电脑只能收到Time to live exceeded报文段.","text":"Select the first ICMP Echo Request message sent by your computer, and expand the Internet Protocol part of the packet in the packet details window.(选择您的计算机发送的第一个 ICMP Echo Request 消息，并在数据包详细信息窗口中展开数据包的 Internet 协议部分) 不知道为什么, 我的电脑只能收到Time to live exceeded报文段. 结果是因为我在过滤了ICMP, 而traceroute默认使用UDP而不是ICMP, 所以只能收到路由器发给我的ICMP time to live exceeded 报文,告诉我的数据包被干掉了. tracert 默认使用 ICMP 包探测，traceroute 使用 UDP 包，也可以使用 ICMP 和 TCP 包探测, 带上参数-T即可. 1-I Use ICMP ECHO instead of UDP datagrams. (A synonym for &quot;-P icmp&quot;). 12traceroute baidu.com 2000 # 使用baidu测试, 默认使用UDP, 数据报大小为2000byte What is the IP address of your computer? 在 IP header 中，上层协议字段的值是多少? 我的IP地址: 10.51.172.226 这是traceroute发送的第一个数据报, 可以得到以下信息: 该数据报是IP数据报, 上层协议为UDP 数据报被分片了, More Fragment字段被设为1 源IP是10.51.172.226, 这是host IP 目标IP是110,242,68,66, 这是Baidu.com的IP地址, 我用百度来测试. IP datagram 的有效负载中有多少 bytes? 说明如何 确定 payload bytes 的数。 payload = Total Len - header Len = 1500 - 20 = 1480, 是的, 我直接发送了2000byte的报文 此 IP 数据报是否已被分段(fragmented)?解释您如何确定数据报是否已被分段(fragmented) 是的, 前文有提到, 这里不再赘述. 接下来，通过单击 Source 列标题，根据 IP 源地址对跟踪的数据包进行排序，一个小的向下箭头应出现在 Source 旁边，如果箭头指向上方请再次单击“Source column header”。选择计算机发送的第一个 ICMP Echo Request 消息，然后展开“details of selected packet header”窗口中的 Internet 协议部分。在“listing of captured packets”窗 口中，您应该在第一个 ICMP 下面看到所有后续 ICMP 消息(可能还有计算器上运行的其他协议发送的其他散布数据包)，使用向下箭头浏览计算器发送的 ICMP 消息。 在您的计算器发送的这一系列 ICMP 消息中，IP 数据报中的哪些字段总有改变 使用 123456traceroute -I gaia.cs.umass.edu -80# 用作者给的网站测试, -I表示使用ICMP# The default probe datagram length is 40 bytes[traceroute manual]# 但是我使用作者提议用56作为数据报(ip datagrame)大小时, 收到以下警告: # traceroute: packet length must be &gt; 71# 所以这里数据报大小设为80, 实际上, 我使用不带数据报大小参数的命令时, 默认数据报大小为1380 再次抓包, 由于traceroute实际上会发送三个ICMP的数据报, 所以三个为一组. 所以可发现每一组的ID值差3, 当然是因为一组发了三个ICMP数据报啊… 第一个: 第二个: 第三个: 可以发现, Id, TTL, Header checksum改变了. 哪些字段保持不变? 哪个字段必须保持不变? 哪些字段必须更改? 为什么? Version, Header Length , TOS(Differentiate Services Field差异化服务领域), Flag, TTL, Protocol, SIP,DIP保持不变 Version, Protocol, TOS, Header Len必须保持不变. Identification, checksum,TTL必须更改 描述您在 IP 数据报的标识字段的值中看到的模式 每发一个ICMP的数据报, ID字段加一(不分片的情况下, 分片时一个IP数据报的不同片具有相同的ID) 下一步(数据包仍按来源地址排序)查找最近的(第一跳)路由器发送到您的计算器的一系列 ICMP TTL 超出的回复讯息。 ID 字段和 TTL 字段的值是多少? 对于最近(第一跳)路由器发送到您的计算器的所有 ICMP TTL 超出的回复，这些值是否保持不变?为什么? TTL保持不变, 但ID改变了. TTL都为64(可以改变, 理论上可以为1, 因为第一台路由器到我的主机一跳可达) 在不管是发回给我的time to live exceeded还是ICMP reply TTL的值都为64, 可能是默认的值. 单击“时间”列，再次按时间对数据包列表进行排序。 在将 pingplotter 中的数据包大小更改为 2000 后，查找计算机发送的第一个 ICMP Echo Request 消息。该消息是否已分片为多个 IP 数据报? 打印出碎片 IP 数据报的第一个片段。 IP 头中的哪些信息表明数据报已碎片 化? IP 头中的哪些信息表明这是第一个片段还是后一个片段? 这个 IP 数据报有多长? 打印出碎片 IP 数据报的第二个片段。 IP 标头中的哪些信息表明这不是第一 个数据报片段? 是否还有更多的片段? 你是如何知道的? 是的, 该消息被分片了, 可以通过flag字段看出, Fragmen Offset 为1480, 而More Fragment为0 ,告诉这是第二个message, 那第一个到哪里去了呢? Wireshark告诉我在frame 73, 于是我去寻找frame73 73frame和74frame的payload 和 为 1980, 因为规定了ICMP的IP数据报大小为2000, 但由于IP头部的20byte, 实际的payload恰好为1980byte 注意到发到第一个message竟然不是ICMPmessage, 而是一个IPdatagram 打开IP头部, 我们发现, 这仍然是一个ICMP的数据报, 但是在IP的数据部分并没有ICMP头部. 在第一个和第二个片段中，IP 标头中哪些字段发生了变化? 第一个fregment: 第二片: 注意到红色部分发送了改变, 而蓝色部分没有改变, IP数据报用ID来标识多个片是否属于同一个IP数据报. 现在，在将 pingplotter 中的数据包大小更改为 3500 后，找到计算机发送的第一个 ICMP Echo Request 消息。 从原始数据报创建了多少个片? 三个片 片段中 IP 标头中的哪些字段发生了变化? 和上一个结论相同, 红色部分发送了改变, 而蓝色部分没有改变, IP数据报用ID来标识多个片是否属于同一个IP数据报.","categories":[],"tags":[{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"},{"name":"lab","slug":"lab","permalink":"https://trevoewu.github.io/tags/lab/"}]}],"categories":[{"name":"Java web","slug":"Java-web","permalink":"https://trevoewu.github.io/categories/Java-web/"},{"name":"学习记录","slug":"学习记录","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"学习","slug":"学习","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"mac使用指南","slug":"mac使用指南","permalink":"https://trevoewu.github.io/categories/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://trevoewu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"日常","slug":"日常","permalink":"https://trevoewu.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://trevoewu.github.io/tags/java-web/"},{"name":"jsp","slug":"jsp","permalink":"https://trevoewu.github.io/tags/jsp/"},{"name":"servlet","slug":"servlet","permalink":"https://trevoewu.github.io/tags/servlet/"},{"name":"jdbc","slug":"jdbc","permalink":"https://trevoewu.github.io/tags/jdbc/"},{"name":"fullstack","slug":"fullstack","permalink":"https://trevoewu.github.io/tags/fullstack/"},{"name":"smbms","slug":"smbms","permalink":"https://trevoewu.github.io/tags/smbms/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://trevoewu.github.io/tags/JavaWeb/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://trevoewu.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"水课论文","slug":"水课论文","permalink":"https://trevoewu.github.io/tags/%E6%B0%B4%E8%AF%BE%E8%AE%BA%E6%96%87/"},{"name":"computer network","slug":"computer-network","permalink":"https://trevoewu.github.io/tags/computer-network/"},{"name":"lab","slug":"lab","permalink":"https://trevoewu.github.io/tags/lab/"},{"name":"computer cetwork","slug":"computer-cetwork","permalink":"https://trevoewu.github.io/tags/computer-cetwork/"},{"name":"mac使用指南","slug":"mac使用指南","permalink":"https://trevoewu.github.io/tags/mac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"},{"name":"oracle","slug":"oracle","permalink":"https://trevoewu.github.io/tags/oracle/"},{"name":"教程","slug":"教程","permalink":"https://trevoewu.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"computer system","slug":"computer-system","permalink":"https://trevoewu.github.io/tags/computer-system/"},{"name":"日常","slug":"日常","permalink":"https://trevoewu.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"talk","slug":"talk","permalink":"https://trevoewu.github.io/tags/talk/"},{"name":"Talk","slug":"Talk","permalink":"https://trevoewu.github.io/tags/Talk/"}]}